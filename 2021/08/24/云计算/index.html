<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="分布式系统模型和关键技术互联网之上的可扩展计算">
<meta property="og:type" content="article">
<meta property="og:title" content="云计算">
<meta property="og:url" content="http://example.com/2021/08/24/%E4%BA%91%E8%AE%A1%E7%AE%97/index.html">
<meta property="og:site_name" content="DL&#39;s Blog">
<meta property="og:description" content="分布式系统模型和关键技术互联网之上的可扩展计算">
<meta property="og:locale">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/05/4jqrIe.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/05/4jL2Y4.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/05/4jvtun.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/05/4jvgD1.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/07/5pQyLQ.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/07/5pQbw9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/07/5plSyD.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/07/5plCeH.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/07/5pliTA.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/07/5plf7d.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/07/59nPsJ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/14/5lZhw9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/14/5lett1.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/14/5l3M1s.md.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/14/5lN8BR.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/14/5lgDWd.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/28/5LxBdJ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/28/5LzhcV.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/28/5OkSz9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/28/5OERVx.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/28/5OVCss.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/29/5jF4Re.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/29/5jFqdP.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/10/29/5jAH4f.png">
<meta property="article:published_time" content="2021-08-24T02:58:17.000Z">
<meta property="article:modified_time" content="2021-10-29T08:33:24.772Z">
<meta property="article:author" content="DeaL">
<meta property="article:tag" content="云计算">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/10/05/4jqrIe.png">

<link rel="canonical" href="http://example.com/2021/08/24/%E4%BA%91%E8%AE%A1%E7%AE%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>云计算 | DL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to DL's Blog!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">36</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/24/%E4%BA%91%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s4.ax1x.com/2022/01/21/72Iby8.jpg">
      <meta itemprop="name" content="DeaL">
      <meta itemprop="description" content="我说的每一句话，都是错的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          云计算
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-24 10:58:17" itemprop="dateCreated datePublished" datetime="2021-08-24T10:58:17+08:00">2021-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-29 16:33:24" itemprop="dateModified" datetime="2021-10-29T16:33:24+08:00">2021-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
                </span>
            </span>

          
            <span id="/2021/08/24/%E4%BA%91%E8%AE%A1%E7%AE%97/" class="post-meta-item leancloud_visitors" data-flag-title="云计算" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/08/24/%E4%BA%91%E8%AE%A1%E7%AE%97/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/24/%E4%BA%91%E8%AE%A1%E7%AE%97/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="分布式系统模型和关键技术"><a href="#分布式系统模型和关键技术" class="headerlink" title="分布式系统模型和关键技术"></a>分布式系统模型和关键技术</h1><h2 id="互联网之上的可扩展计算"><a href="#互联网之上的可扩展计算" class="headerlink" title="互联网之上的可扩展计算"></a>互联网之上的可扩展计算</h2><span id="more"></span>

<p>一个并行的、分布式的计算系统使用大量的计算机解决<strong>互联网上的大规模计算</strong>问题。分布式计算的缺点是<strong>数据敏感</strong>和<strong>网络中心化</strong>。 </p>
<h3 id="计算范式间的区别"><a href="#计算范式间的区别" class="headerlink" title="计算范式间的区别"></a>计算范式间的区别</h3><p><strong>集中式</strong>计算:这种计算范式是将所有计算资源集中在一个物理系统之内。所有资源（处理器、内存、存储器）是<strong>全部共享</strong>的，并且紧耦合在一个集成式的操作系统中。</p>
<p><strong>并行</strong>计算：在并行计算中，所有处理器或是<strong>紧耦合于中心共享内存</strong>或是<strong>松耦合于分布式内存</strong>。</p>
<p><strong>分布式</strong>计算：一个分布式系统由众多自治的计算机组成，<strong>各自拥有其私有内存</strong>，通过计算机网络通信。分布式系统中的信息交换通过消息传递的方式完成。</p>
<p><strong>云</strong>计算：一个互联网云的资源可以是集中式的也可以是分布式的。<strong>云</strong>采用<strong>分布式计算或并行计算</strong>，或两者兼有。云可以在集中的或分布式的大规模数据中心之上，由物理的或虚拟的计算资源构建。</p>
<p>普适计算是指在任何地点和时间通过有线或者无线<strong>网络</strong>使用<strong>普遍的设备</strong>进行计算。</p>
<p>物联网是一个日常生活对象（包括计算机、传感器、人等）网络化的连接。物联网通过互联网云实现任何对象在任何地点和时间的普适计算。</p>
<p>互联网计算这一术语几乎涵盖了所有和互联网相关的计算范式。</p>
<h3 id="HPC和HTC系统需要遵从的设计原则"><a href="#HPC和HTC系统需要遵从的设计原则" class="headerlink" title="HPC和HTC系统需要遵从的设计原则"></a>HPC和HTC系统需要遵从的设计原则</h3><p>效率:在HPC系统中开发大规模并行计算时，度量执行模型内资源的利用率。对于HTC系统，效率更依赖于系统的任务吞吐量、数据访问、存储、节能。</p>
<p>可信：度量从芯片到系统到应用级别的可靠性和自管理能力。<strong>目的是提供有服务质量（QoS）</strong>保证的<strong>高吞吐量服务</strong>，即使是失效的情况下。</p>
<p>编程模型适应性：度量在海量数据集和虚拟云资源上各种负载和服务模型下支持数十亿任务请求的能力。</p>
<p>应用部署的灵活性：度量分布式系统能够同时很好地运行在HPC（科学和工程）和HTC（商业）应用上的能力。</p>
<h3 id="可扩展性计算趋势和新的范式"><a href="#可扩展性计算趋势和新的范式" class="headerlink" title="可扩展性计算趋势和新的范式"></a>可扩展性计算趋势和新的范式</h3><p>位级并行（Bit Level Parallelism，BLP）</p>
<p>指令级并行（Instruction Level Parallelism，ILP）。通过指令流水线、超标量计算、VLIW体系结构、多线程实践了ILP。ILP需要分支预测、动态规划、投机预测、提高运行效率的编译支持。</p>
<p>数据级并行（Data Level Parallelism，DLP）的流行源于SIMD和使用向量与数组指令类型的向量机</p>
<p>任务级并行（Task Level Parallelism，TLP）</p>
<p>作业级并行（Job Level Parallelism ，JLP）</p>
<h3 id="物联网和CPS"><a href="#物联网和CPS" class="headerlink" title="物联网和CPS"></a>物联网和CPS</h3><p>物联网是指日常生活中对象、工具、设备或计算机间存在网络互连。物联网为互联了所有我们生活中的对象的无线传感器网络。</p>
<p>CPS是计算过程和物理世界之间交互的结果。<strong>CPS集成了“计算节点”（同构，异构）和“物理”（并发和信息密集的）对象</strong>。CPS在物理世界和信息世界之间将“3C”技术（计算、通信、控制）融合到了一个智能闭环反馈系统中。</p>
<p>物联网强调物理对象之间的多样化连接，而CPS强调物理世界中虚拟现实应用的开发和研究。</p>
<h2 id="并行与分布式相关技术"><a href="#并行与分布式相关技术" class="headerlink" title="并行与分布式相关技术"></a>并行与分布式相关技术</h2><h3 id="多核CPU和多线程技术"><a href="#多核CPU和多线程技术" class="headerlink" title="多核CPU和多线程技术"></a>多核CPU和多线程技术</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4jqrIe"><img src="https://z3.ax1x.com/2021/10/05/4jqrIe.png" alt="4jqrIe.png"></a></p>
<p>现代CPU处理器的5种微体系结构，通过多核和多线程技术支持<strong>ILP</strong>和<strong>TLP</strong></p>
<h4 id="大规模和超大规模GPU计算"><a href="#大规模和超大规模GPU计算" class="headerlink" title="大规模和超大规模GPU计算"></a>大规模和超大规模GPU计算</h4><p>数百或数千处理核心的海量并行处理中协同CPU的GPU使用</p>
<h3 id="系统区域互连"><a href="#系统区域互连" class="headerlink" title="系统区域互连"></a>系统区域互连</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4jL2Y4"><img src="https://z3.ax1x.com/2021/10/05/4jL2Y4.png" alt="4jL2Y4.png"></a></p>
<p>分布式和云计算系统都建立于<strong>大量自治的计算机节点</strong>之上。这些节点通过<strong>SAN、LAN或WAN以层次方式</strong>互连。</p>
<h3 id="虚拟机和虚拟化中间件"><a href="#虚拟机和虚拟化中间件" class="headerlink" title="虚拟机和虚拟化中间件"></a>虚拟机和虚拟化中间件</h3><p>建立大规模集群、网格和云，我们需要以虚拟的方式访问大量的计算、存储和网络化资源。我们需要集群化这些资源，并希望提供一个<strong>单独的系统镜像</strong>。 </p>
<p>分布式计算环境中的虚拟机<strong>复用、挂起、供应和迁移</strong></p>
<h2 id="分布式和云计算系统模型"><a href="#分布式和云计算系统模型" class="headerlink" title="分布式和云计算系统模型"></a>分布式和云计算系统模型</h2><p>分布式和云计算系统都建立于<strong>大量自治的计算机节点</strong>之上。这些节点通过SAN、LAN或WAN以层次方式互连。</p>
<p>大系统被认为高可扩展，并能在物理上或逻辑上达到<strong>Web规模互连</strong>。</p>
<p>大系统被划分为四组：集群、P2P网络、计算网格、大数据中心之上的互联网云。</p>
<p>集群应该<strong>合并多个系统镜像到一个单系统镜像</strong>（SSI）。集群设计者期待一个集群操作系统或者一些中间件<strong>在各个级别支持SSI</strong>。</p>
<h3 id="网格计算"><a href="#网格计算" class="headerlink" title="网格计算"></a>网格计算</h3><p>在过去30年，用户经历了一个从互联网到Web和网格计算服务的自然发展。互联网服务（如Telnet命令）使本地计算机可以连接到一台远程计算机。一个Web服务（如HTTP）使远程访问Web页面成为可能。网格计算被预想用于同时在多台远距离计算机上运行的应用间进行近距离交互。</p>
<p>网格呈现为<strong>集成的计算资源</strong>。它们也可以被视为支持虚拟组织的虚拟平台。</p>
<h3 id="对等网络（P2P）"><a href="#对等网络（P2P）" class="headerlink" title="对等网络（P2P）"></a>对等网络（P2P）</h3><p>客户端服务器体系结构。客户机（PC和工作站）被连接到一个中央服务器，用来进行计算、电子邮件、文件访问和数据库应用。P2P体系结构提供了一个分布式的网络化系统模型。</p>
<p>在一个P2P系统中，每个节点既是客户端又是服务器，提供部分系统资源。</p>
<p>节点机器都是简单的接入互联网的客户机。所有客户机自治、自由地加入和退出系统。不存在主从关系。</p>
<p>无需中心协作或中心数据库。系统是分布式控制下自组织的。</p>
<p>P2P计算在硬件、软件和网络需求上面临三类异构问题。有太多的<strong>硬件模型和体系结构</strong>而无法选择；<strong>软件和操作系统</strong>间不相容；不同的<strong>网络连接和协议</strong>使其过于复杂而较难应用于真实应用。</p>
<h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a><strong>云计算</strong></h3><p>云是虚拟计算机资源池。云可以处理各种不同的负载，包括批处理式后端作业和交互式用户界面应用。</p>
<p>云通过迅速提供虚拟机或物理机允许负载被快速配置和划分。云支持冗余、自恢复、高可扩展编程模型，以允许负载从许多不可避免的硬件/软件错误中恢复。最终，云计算系统可以通过实时监视资源来确保分配在需要时平衡。</p>
<p>基础设施即服务（IaaS）：这个模型将用户需要的基础设施（即<strong>服务器、存储、网络</strong>和数据中心构造）组合在一起。用户可以在使用客户机操作系统的多个虚拟机上配置和运行指定应用。</p>
<p>平台即服务（PaaS）：这个模型使用户能够在一个虚拟的云平台上<strong>配置用户定制的应用</strong>。PaaS包括<strong>中间件、数据库、开发工具</strong>和一些运行时支持（如Web 2.0和Java）。</p>
<p>软件即服务（SaaS）:这是指面向数千付费云用户的初始浏览器的应用软件。<strong>SaaS模型应用于业务流程、工业应用、客户关系管理、企业资源计划、人力资源和合作应用。</strong></p>
<h2 id="分布式系统和云计算软件环境"><a href="#分布式系统和云计算软件环境" class="headerlink" title="分布式系统和云计算软件环境"></a><strong>分布式系统和云计算软件环境</strong></h2><h3 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4jvtun"><img src="https://z3.ax1x.com/2021/10/05/4jvtun.png" alt="4jvtun.png"></a></p>
<h3 id="已有并行和分布式编程模型"><a href="#已有并行和分布式编程模型" class="headerlink" title="已有并行和分布式编程模型"></a>已有并行和分布式编程模型</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4jvgD1"><img src="https://z3.ax1x.com/2021/10/05/4jvgD1.png" alt="4jvgD1.png"></a></p>
<h3 id="面向服务的体系结构（SOA）"><a href="#面向服务的体系结构（SOA）" class="headerlink" title="面向服务的体系结构（SOA）"></a>面向服务的体系结构（SOA）</h3><p>网格与云服务</p>
<p>网格和云之间的界限近年来变得越来越模糊。对于Web服务，工作流技术用于协调或编排具有指定规范的服务，其中这些规范用于定义关键业务流程模型，如两阶段事务。</p>
<p>网格系统使用<strong>静态资源</strong>，而云强调<strong>弹性资源</strong>。</p>
<p>网格和云之间的不同<strong>仅限于基于虚拟化和自治计算的动态资源管理</strong>。可以通过多个云建立网格。这种网格比一个单纯的云能更好的工作，因为它能<strong>明确支持协议资源分配</strong>。从而可以建立系统的系统，如云之云、云网格、网格云，或互联云作为一个基本SOA体系结构。</p>
<h3 id="分布式和云计算的可扩展性"><a href="#分布式和云计算的可扩展性" class="headerlink" title="分布式和云计算的可扩展性:"></a>分布式和云计算的可扩展性:</h3><p>规模可扩展性：指通过增加机器数量来获取更高的性能和更多的功能。</p>
<p>软件可扩展性：指升级操作系统或编译器，增加数学和工程库，移植新的应用软件，安装更多的用户友好的编程环境。</p>
<p>应用可扩展性：指问题的规模扩展与机器的大小扩展相匹配。</p>
<p>技术可扩展性：指系统可以适应构建技术的变化</p>
<h1 id="虚拟机和集群与数据中心虚拟化"><a href="#虚拟机和集群与数据中心虚拟化" class="headerlink" title="虚拟机和集群与数据中心虚拟化"></a>虚拟机和集群与数据中心虚拟化</h1><h2 id="虚拟化的实现层次"><a href="#虚拟化的实现层次" class="headerlink" title="虚拟化的实现层次"></a>虚拟化的实现层次</h2><p>虚拟化技术通过在同一个硬件主机上<strong>多路复用虚拟机</strong>的方式来共享昂贵的硬件资源，虚拟化的基本思想是分离软硬件以产生更好的系统性能 </p>
<p>  引入虚拟化后，不同用户应用程序由自身的操作系统（即客户操作系统）管理，并且那些客户操作系统可以独立于主机操作系统同时运行在同一个硬件上，这通常是通过新添加一个称为<strong>虚拟化层</strong>的软件来完成，该虚拟化层称为<strong>hypervisor</strong>或虚拟机监视器（Virtual Machine Monitor，<strong>VMM</strong>） </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5pQyLQ"><img src="https://z3.ax1x.com/2021/10/07/5pQyLQ.md.png" alt="5pQyLQ.md.png"></a></p>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5pQbw9"><img src="https://z3.ax1x.com/2021/10/07/5pQbw9.png" alt="5pQbw9.png"></a></p>
<h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5plSyD"><img src="https://z3.ax1x.com/2021/10/07/5plSyD.png" alt="5plSyD.png"></a></p>
<h3 id="供应（恢复）"><a href="#供应（恢复）" class="headerlink" title="供应（恢复）"></a>供应（恢复）</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5plCeH"><img src="https://z3.ax1x.com/2021/10/07/5plCeH.png" alt="5plCeH.png"></a></p>
<h3 id="动态迁移"><a href="#动态迁移" class="headerlink" title="动态迁移"></a>动态迁移</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5pliTA"><img src="https://z3.ax1x.com/2021/10/07/5pliTA.png" alt="5pliTA.png"></a></p>
<h3 id="虚拟化的层级"><a href="#虚拟化的层级" class="headerlink" title="虚拟化的层级"></a>虚拟化的层级</h3><p>指令集体系结构级：代码解释和动态二进制翻译</p>
<p>硬件抽象级：虚拟化一个计算机硬件资源</p>
<p>操作系统级：在单一物理服务器上创建隔离的容器和操作系统实例</p>
<p>库支持级：库接口的虚拟化</p>
<p>应用程序级：进程级虚拟化、高级语言（High Level Language，HLL）虚拟机</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5plf7d"><img src="https://z3.ax1x.com/2021/10/07/5plf7d.png" alt="5plf7d.png"></a></p>
<h2 id="硬件级虚拟化"><a href="#硬件级虚拟化" class="headerlink" title="硬件级虚拟化"></a>硬件级虚拟化</h2><h3 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h3><p>硬件级虚拟化在真实硬件和传统操作系统之间插入一层软件，该层软件通常称为虚拟机监视器（VMM）</p>
<p>对VMM有三个需求。第一，VMM应该为程序提供与原始硬件机器基本一致的<strong>环境</strong>；第二，运行在该环境中的程序的性能<strong>损失应较低</strong>；第三，<strong>系统资源</strong>应处于VMM的<strong>完全控制</strong>之中。</p>
<p>由VMM完全控制这些资源包括以下方面：(1) VMM负责为<strong>应用程序分配硬件资源</strong>；(2) 程序<strong>不能访问</strong>任何未分配给它的资源；(3) 在某些情况下，VMM可以获得对<strong>已分配资源</strong>的控制权。 </p>
<h3 id="硬件级虚拟化-1"><a href="#硬件级虚拟化-1" class="headerlink" title="硬件级虚拟化"></a>硬件级虚拟化</h3><p>Xen是一个由剑桥大学开发的开源hypervisor程序。Xen属于微内核hypervisor</p>
<p>提供了一种客户操作系统可以直接访问物理设备的机制</p>
<p>Xen提供了一个处于硬件和操作系统之间的虚拟环境</p>
<p>Xen系统的核心组件是hypervisor、内核和应用程序</p>
<p>具有控制特权的客户操作系统称为Domain 0，其他客户操作系统则称为Domain U</p>
<p>Domain 0被首先启动。Domain 0可以直接访问硬件和管理设备。因此，Domain 0的一个任务是为所有Domain U分配和映射硬件资源</p>
<h4 id="硬件虚拟化的两种方式"><a href="#硬件虚拟化的两种方式" class="headerlink" title="硬件虚拟化的两种方式"></a>硬件虚拟化的两种方式</h4><p>全虚拟化</p>
<p>基于主机的虚拟化</p>
<h4 id="全虚拟化的二进制翻译"><a href="#全虚拟化的二进制翻译" class="headerlink" title="全虚拟化的二进制翻译"></a>全虚拟化的二进制翻译</h4><p>客户操作系统和它们的应用由非临界和临界指令构成。</p>
<p>全虚拟化不需要修改主机操作系统。它依赖于<strong>二进制翻译来陷入和虚拟化一些敏感、不可虚拟化的指令的执行。</strong></p>
<h2 id="操作系统级的虚拟化"><a href="#操作系统级的虚拟化" class="headerlink" title="操作系统级的虚拟化"></a>操作系统级的虚拟化</h2><p><strong>操作系统级虚拟化</strong>在一个<strong>操作系统</strong>中插入一个<strong>虚拟化层来划分机器的物理资源。</strong>它使得在一个操作系统内核中可以同时运行多个隔离的虚拟机。这种虚拟机也称为VE（Virtual Execution Environment）、VPS（Virtual Private System，虚拟专用系统）或容器。</p>
<p>从用户的视角来看，VE就像真实服务器。VE有自己的进程、文件系统、用户账号、带有IP地址的网络接口、路由表、防火墙规则及其他个人设置。</p>
<p>尽管VE可为不同用户分别定制，但它们仍共享同一个操作系统内核。因此，操作系统级虚拟化也称为<strong>单操作系统镜像虚拟化</strong>。 </p>
<p>在基于主机的系统虚拟化中，主机操作系统和客户操作系统同时存在，虚拟化软件层处于两者之间。 该主机操作系统仍旧负责管理硬件。客户操作系统安装并运行在虚拟化层之上。特定的应用可运行在虚拟机中。</p>
<h2 id="CPU、内存和I-O设备的虚拟化方法"><a href="#CPU、内存和I-O设备的虚拟化方法" class="headerlink" title="CPU、内存和I/O设备的虚拟化方法"></a>CPU、内存和I/O设备的虚拟化方法</h2><p>为支持虚拟化，处理器利用硬件辅助虚拟化，引入一种特殊的运行模式和指令，使得 VMM和客户操作系统可运行在不同模式中，客户操作系统及其应用程序的所有敏感指令会陷入到VMM中。</p>
<p>虚拟化的硬件支持</p>
<p>现代操作系统和处理器允许多个进程同时运行。如果处理器中没有保护机制，那么不同进程的所有指令都可以直接访问硬件，很容易导致系统崩溃。因此，所有处理器都至少需要两种模式（<strong>用户模式和管理模式</strong>）来确保对<strong>临界区硬件</strong>的<strong>受控访问</strong>。运行在<strong>管理模式</strong>的指令称为<strong>特权指令</strong>，其他指令为<strong>非特权指令</strong>。 </p>
<h4 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h4><p>虚拟机的非特权指令直接在物理主机中运行</p>
<p>关键指令可以分为三类：<strong>特权指令、控制敏感指令和行为敏感指令</strong>。特权指令需要在特权模式中执行，当在特权模式之外执行特权指令时会发生陷入。控制敏感指令尝试改变使用资源的配置。行为敏感指令根据资源的配置情况会有不同的行为，包括在虚拟内存中进行的负载和存储操作。</p>
<p>VMM运行在管理模式时，CPU支持在用户模式运行虚拟机的特权指令和非特权指令，则该CPU体系结构是可虚拟化的。</p>
<p>RISC的所有<strong>控制敏感指令</strong>和<strong>行为敏感指令</strong>都是<strong>特权指令</strong>，因此，RISC的CPU体系结构是天然可虚拟化的。</p>
<h4 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h4><p>客户操作系统和VMM分别维护从虚拟内存到物理内存的映射和从物理内存到机器内存的映射，共两级映射。客户操作系统仍旧负责从虚拟地址到虚拟机的物理内存地址的映射，VMM负责将客户物理内存映射到实际的机器内存上 </p>
<h4 id="多核处理器的虚拟化"><a href="#多核处理器的虚拟化" class="headerlink" title="多核处理器的虚拟化"></a>多核处理器的虚拟化</h4><p>主要有两个困难：一是应用程序编程者必须完全<strong>并行地使用所有处理器核</strong>，二是软件必须明确地<strong>为处理器核分配任务</strong>。</p>
<h2 id="虚拟集群和资源管理"><a href="#虚拟集群和资源管理" class="headerlink" title="虚拟集群和资源管理"></a>虚拟集群和资源管理</h2><h3 id="物理集群与虚拟集群"><a href="#物理集群与虚拟集群" class="headerlink" title="物理集群与虚拟集群"></a>物理集群与虚拟集群</h3><p>虚拟集群由多个客户虚拟机构成，这些客户虚拟机安装在由一个或多个物理集群构成的分布式服务器上。在逻辑上，处于一个虚拟集群的客户虚拟机通过一个跨越了多个物理网络的虚拟网络互连在一起。 </p>
<p>虚拟集群节点可以是<strong>物理机器或虚拟机器</strong></p>
<p><strong>主机操作系统管理物理机器的资源，虚拟机运行其上，并且可以运行与主机相异的操作系统。</strong></p>
<p>使用虚拟机的目的是合并同一台物理服务器的多个功能。</p>
<p>虚拟机可以在多个物理服务器上备份，以提高分布式并行度、容错性，加快灾难恢复速度。</p>
<p>虚拟集群的节点数可以动态增减，与P2P网络中覆盖网络的规模变化类似。</p>
<p>物理节点的失效会使得运行在其上的虚拟机也失效，但是虚拟机的失效不会影响主机系统。</p>
<h3 id="快速部署和有效调度"><a href="#快速部署和有效调度" class="headerlink" title="快速部署和有效调度:"></a>快速部署和有效调度:</h3><p>系统应具备快速部署的能力。快速部署要求如下两点：一是在集群内的<strong>物理节点上尽快构建和发布软件栈</strong>（包括操作系统、库、应用程序）；二是运行时环境可以从一个用户虚拟集群<strong>快速切换</strong>至另一个用户虚拟集群。</p>
<p>虚拟化的另一个优点是在虚拟集群中应用程序的负载均衡。负载均衡可以通过使用负载指数和用户登录频率等指标来完成，虚拟集群的自动伸缩机制可以基于该模型实现。</p>
<h3 id="高性能虚拟存储"><a href="#高性能虚拟存储" class="headerlink" title="高性能虚拟存储"></a>高性能虚拟存储</h3><p>存储体系结构设计可以用于减少虚拟集群分布式文件系统中的复制块</p>
<h3 id="在线迁移虚拟机的步骤与性能影响"><a href="#在线迁移虚拟机的步骤与性能影响" class="headerlink" title="在线迁移虚拟机的步骤与性能影响"></a>在线迁移虚拟机的步骤与性能影响</h3><p>在虚拟集群中，虚拟机客户系统与主机系统并存，并且虚拟机运行在物理主机之上。当一个虚拟机失效时，其角色可被其他节点上的虚拟机替代，只要两个虚拟机运行相同的客户操作系统即可。</p>
<p>一个物理节点可以故障转移至另一个主机的虚拟机上。 </p>
<h3 id="管理虚拟集群共有四种方式"><a href="#管理虚拟集群共有四种方式" class="headerlink" title="管理虚拟集群共有四种方式:"></a>管理虚拟集群共有四种方式:</h3><p>第一种方式是基于<strong>客户的管理器</strong>，其中集群管理器处于客户系统中。在这种管理方式中，多个虚拟机形成一个虚拟集群。</p>
<p>第二种方式是基于<strong>主机的集群管理器</strong>。监督客户系统且能在另一个物理机器上重启客户系统。</p>
<p>第三种方式是在<strong>主机系统和客户系统中使用相互独立的集群管理器</strong>来管理虚拟集群。然而，这会使基础设施管理变得更为复杂。</p>
<p>第四种方式是在<strong>主机系统和客户系统中使用集成的集群</strong>。这表示管理器能区分虚拟资源和物理资源。 </p>
<p>  虚拟机可以从一台物理机器在线迁移至另一台物理机器。发生失效时，一个虚拟机可被另一个虚拟机替代。</p>
<p>虚拟集群可以应用在计算网格、云平台和高性能计算系统中。虚拟集群化的主要吸引力在于它可根据用户需求或节点失效后快速提供动态资源。尤其是，虚拟集群化在云计算中发挥着重要作用。当虚拟机运行在线服务时，在线虚拟机迁移方案的设计目标是最小化如下三个指标：<strong>微小的停机时间、最低的网络带宽消耗及合理的总迁移时间。</strong> </p>
<p>一台虚拟机可能处于如下四种状态之一：<strong>非活跃状态、活跃状态、中止状态、挂起状态。</strong></p>
<p>在线迁移虚拟机包括如下6个步骤 : </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/59nPsJ"><img src="https://z3.ax1x.com/2021/10/07/59nPsJ.png" alt="59nPsJ.png"></a></p>
<h3 id="内存、文件与网络资源的迁移"><a href="#内存、文件与网络资源的迁移" class="headerlink" title="内存、文件与网络资源的迁移"></a>内存、文件与网络资源的迁移</h3><p><strong>内存迁移</strong>：将虚拟机的内存实例从一个物理节点迁移至另一个物理节点</p>
<p><strong>文件系统迁移</strong>：为每个虚拟机提供一个一致的、位置无关的、在所有物理主机上都可访问的文件系统</p>
<p><strong>网络迁移</strong>：迁移虚拟机时应维持所有开放的网络连接，不应依赖原始主机转发或者依赖移动性或重定向机制的支持。</p>
<p>在线迁移机制主要使用预复制的方法，首先传输所有的内存页，然后迭代地只传输上次传输过程中被修改的内存页。 </p>
<h3 id="容器集群的动态部署"><a href="#容器集群的动态部署" class="headerlink" title="容器集群的动态部署"></a>容器集群的动态部署</h3><p><strong>处理速率排队模型和线性模型相结合的反馈控制方法来弹性供应容器，通过自动学习不同到达速率的参考模型并映射输出误差来提高输出误差的准确性。</strong></p>
<p>绝了，老师今年发的顶会，根本不会。。。</p>
<h2 id="数据中心的自动化与虚拟化"><a href="#数据中心的自动化与虚拟化" class="headerlink" title="数据中心的自动化与虚拟化"></a>数据中心的自动化与虚拟化</h2><h3 id="数据中心服务器合并"><a href="#数据中心服务器合并" class="headerlink" title="数据中心服务器合并"></a>数据中心服务器合并</h3><p><strong>服务器合并</strong>采用减少物理服务器数目的方法，是改进硬件资源低利用效率的有效途径。在许多服务器合并技术（如集中合并和物理合并）中，<strong>基于虚拟化的服务器</strong>合并是最有效的合并方式。</p>
<p>数据中心需要优化其资源管理，但是这些服务器合并技术在服务器整机级别进行，很难使资源管理得到有效优化。</p>
<p>合并增强了<strong>硬件利用效率</strong></p>
<p>使资源得到更<strong>灵活的配置和调度</strong></p>
<p>总体拥有<strong>成本得到降低</strong>。</p>
<p>可以改进<strong>可用性和业务连续性</strong> </p>
<h3 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h3><p>在系统虚拟化中，虚拟存储包括由VMM和客户操作系统管理的存储。</p>
<p>存储在该环境中的数据可被分为两类：<strong>虚拟机镜像</strong>和<strong>应用程序数据。</strong></p>
<p>系统虚拟化最重要的方面是<strong>封装和隔离</strong>。传统操作系统和运行其上的<strong>应用程序</strong>可被封装到<strong>虚拟机之中</strong>。在一个虚拟机中仅运行一个操作系统，而该操作系统中则可运行许多应用程序。<strong>系统虚拟化</strong>允许多虚拟机同时运行在一个物理机器上并且<strong>虚拟机之间完全隔离</strong>。</p>
<h3 id="虚拟化数据中心的可信管理"><a href="#虚拟化数据中心的可信管理" class="headerlink" title="虚拟化数据中心的可信管理"></a>虚拟化数据中心的可信管理</h3><p>VMM的出现改变了计算机体系结构。它在<strong>操作系统和系统硬件</strong>之间插入一层软件，可以在一个物理硬件平台上创建一个或多个虚拟机。虚拟机具有良好的<strong>封装性</strong>，运行在虚拟机中的客户操作系统的状态可以被完全封装起来。被封装的机器状态可以复制，也可以在网络上共享，或像文件一样移除，这对虚拟机的安全性提出了挑战。</p>
<p>VMM可提供<strong>安全隔离性</strong>，虚拟机访问任何硬件资源时都需要通过VMM的审核，因此VMM是一个虚拟系统的安全基础。 </p>
<h1 id="云平台、面向服务的体系结构和云编程"><a href="#云平台、面向服务的体系结构和云编程" class="headerlink" title="云平台、面向服务的体系结构和云编程"></a>云平台、面向服务的体系结构和云编程</h1><h2 id="服务模型和目标"><a href="#服务模型和目标" class="headerlink" title="服务模型和目标"></a>服务模型和目标</h2><h3 id="云计算服务模型"><a href="#云计算服务模型" class="headerlink" title="云计算服务模型"></a>云计算服务模型</h3><p>用户可以在全球任意位置以极具竞争力的成本访问和部署云应用。<br>虚拟化的云平台常常构建在<strong>大规模数据中心之上</strong>。<br>云致力于通过自动化的硬件、数据库、用户接口和应用程序环境把它们<strong>结构化为虚拟资源</strong>，来驱动下一代的数据中心。<br>云渴望通过<strong>自动化的资源配置构建更好的数据中心</strong>。</p>
<h3 id="云计算平台的特点"><a href="#云计算平台的特点" class="headerlink" title="云计算平台的特点"></a>云计算平台的特点</h3><p>云计算会大大降低小型用户及大型企业的成本。<br>无需预先购买昂贵计算机而节约的成本在很大程度上减轻了创业型公司的经济负担。<br>云用户只需支付操作费用、无需投入固定设备的事实吸引了大量的小型用户<br>对大部分企业和繁重的计算机用户来讲极具吸引力。<br>任何IT用户，若其资本支出压力大于操作费用，都应考虑将他们超出负荷的工作交给效用计算或云服务提供商。 </p>
<h3 id="云计算平台的设计目标"><a href="#云计算平台的设计目标" class="headerlink" title="云计算平台的设计目标"></a>云计算平台的设计目标</h3><p>将计算<strong>从桌面移向数据中心</strong>  计算处理、存储与软件发布<strong>从桌面和本地服务器移向互联网数据中心。</strong><br><strong>服务配置和云效益</strong>  提供商供应云服务时必须与消费者和终端用户<strong>签署服务等级协议</strong>（SLA）。<br><strong>性能可扩展性</strong>  云平台、软件和基础设施服务必须能够根据用户数的增长而相应扩容。<br><strong>数据隐私保护</strong>  能否信任数据中心处理个人数据和记录呢？云要成为可信服务必须妥善解决该问题。<br><strong>高质量的云服务</strong>  云计算的<strong>服务质量必须标准化</strong>，这才能使得云可以在多个提供商之间进行互操作。<br><strong>新标准和接口</strong>  主要解决与数据中心或云提供商相关的数据锁定问题。</p>
<h2 id="公有云、私有云和混合云"><a href="#公有云、私有云和混合云" class="headerlink" title="公有云、私有云和混合云"></a>公有云、私有云和混合云</h2><p>云计算的概念从<strong>集群</strong>、<strong>网格</strong>和<strong>效用计算</strong>发展而来。<br><strong>集群和网格计算并行使用大量计算机可以解决任何规模的问题。效用计算和SaaS（Software as a Service）将计算资源作为服务进行按需付费。云计算利用动态资源为终端用户传递大量服务。</strong><br>云计算是一种高吞吐量计算范式，它通过大的数据中心或服务器群提供服务。云计算模型使得用户可以随时随地通过他们的互连设备访问共享资源。</p>
<p>云应用的所有计算任务被分配到<strong>数据中心的服务器上</strong>。这些服务器主要是虚拟集群的虚拟机，由数据中心资源产生出来。<br>云平台是通过<strong>虚拟化分布的系统</strong>。<br>公有云和私有云都是<strong>在互联网上开发</strong>的。<br>公有云构建在互联网之上，任何已付费的用户都可以访问。公有云属于服务提供商，用户通过订阅即可访问。<br>私有云构建在局域网内部，属于一个独立的组织。由客户管理，而且其可访问范围限制在所属客户及其合作者之中。<br>混合云由公有云和私有云共同构成 </p>
<p><strong>公有云促进了标准化</strong>，节约了资金投入，为应用程序提供了很好的灵活性；私有云尝试进行定制化，可以提供更高的有效性、弹性、安全性和隐私性；混合云则处于两者中间，在资源共享方面进行了折中。<br><strong>云的核心是服务器集群</strong>（或虚拟机集群）。集群节点用作计算节点，少量的控制节点用于管理和监视云活动。用户作业的调度需要为用户创建的虚拟集群分配任务。 </p>
<h2 id="基础设施即服务-IaaS"><a href="#基础设施即服务-IaaS" class="headerlink" title="基础设施即服务(IaaS)"></a>基础设施即服务(IaaS)</h2><p>云计算将基础设施、平台和软件作为服务发布，使得用户能够以即用即付的模式使用基于定阅的服务。<br>在云上提供的服务通常可以分为三个不同的服务模型，即IaaS、PaaS（平台即服务）和SaaS（软件即服务）。<br>SaaS由用户或客户使用特殊的接口，用在应用程序端；在PaaS层，云平台必须进行计费服务，处理作业队列，启动和监视服务；底层是IaaS服务，需要配置数据库、计算实例、文件系统和存储以满足用户需求。<br>IaaS模型包括<strong>存储即服务、计算实例即服务和通信即服务</strong>。</p>
<h2 id="平台即服务-PaaS"><a href="#平台即服务-PaaS" class="headerlink" title="平台即服务 (PaaS)"></a>平台即服务 (PaaS)</h2><p>平台云是一个由硬件和软件基础设施构成的集成的计算机系统，可以在这个虚拟化的云平台上使用提供商（如Java、Python、NET）支持的一些编程语言和软件工具<strong>开发用户应用程序</strong>。<br>用户不需要管理底层的云基础设施。云提供商支持用户在一个定义良好的服务平台上进行应用程序的开发和测试。<br>该PaaS模型使得来自世界不同角落的用户<strong>可以在一个统一的软件开发平台上协同工作</strong>。该模型也鼓励第三方组织提供软件管理、集成和服务监视解决方案。</p>
<h2 id="软件即服务-SaaS"><a href="#软件即服务-SaaS" class="headerlink" title="软件即服务 (SaaS)"></a>软件即服务 (SaaS)</h2><p>软件即服务是指上千的云客户通过浏览器访问的应用程序软件。<br>PaaS提供的服务和工具 用于构建应用程序和管理它们所部署的由IaaS提供的资源。<br>SaaS模型<strong>将软件应用程序作为服务进行提供</strong>。对客户来讲，无需为服务器或软件预先投资；对提供商来讲，与传统的用户应用程序托管相比成本很低。<br>为支持PaaS和IaaS，客户数据存储在云中，云或者是专门的提供商，或者是公开地托管。 </p>
<h2 id="公有云平台：GAE、AWS和Azure"><a href="#公有云平台：GAE、AWS和Azure" class="headerlink" title="公有云平台：GAE、AWS和Azure"></a>公有云平台：GAE、AWS和Azure</h2><p>云的5个使用层次。<strong>在顶层，个人用户和组织用户请求的服务非常不同。SaaS层的应用程序提供商主要服务个人用户。大部分商业组织由IaaS和PaaS提供服务。</strong>IaaS为应用程序和组织用户提供计算、存储和通信资源。云环境由PaaS或平台提供商定义。<br>云服务依赖于机器虚拟化、SOA、网格基础设施管理和节能方面的新进展。客户购买如前所述的IaaS、PaaS或SaaS服务。<br>提供商提供的服务费用通常远低于用户频繁更换废弃的服务器的成本。 </p>
<h3 id="谷歌应用引擎（GAE）"><a href="#谷歌应用引擎（GAE）" class="headerlink" title="谷歌应用引擎（GAE）"></a>谷歌应用引擎（GAE）</h3><p>谷歌有世界上最大的搜索引擎设备。公司在大规模数据处理方面具有丰富的经验，这使得其在数据中心设计中视点新颖，且其提出的新的编程模型可适应的规模令人吃惊。<br>谷歌平台基于它的搜素引擎专家，如前所述的MapReduce，该基础设施也适用于许多其他领域。谷歌有上百个数据中心，在全世界安装了460 000多台服务器。<br>数据项存储在文本、图像和视频中，并且出于容错和故障考虑而进行了备份处理。这里我们讨论谷歌的应用程序引擎（GAE），它提供了一个支持不同的云和Web应用的PaaS平台。 </p>
<p>谷歌的云计算应用程序的构成要素包括存储大量数据的GFS、为应用程序开发者提供的MapReduce编程框架、用于分布式应用程序锁服务的Chubby和为访问结构化或半结构化数据的BigTable存储服务。<br>GAE可以看做是许多软件组件的集合。前端是应用程序框架，类似于其他Web应用框架，如ASP、J2EE和JSP。目前，GAE可以支持Python和Java编程环境。应用程序可以像Web应用程序容器一样运行。前端可以用做动态Web服务基础设施，可以提供对公共技术的完整支持。 </p>
<h3 id="微软的Windows-Azure"><a href="#微软的Windows-Azure" class="headerlink" title="微软的Windows Azure"></a>微软的Windows Azure</h3><p>在2008年，微软发布了一个Windows Azure平台来应对云计算所遇到的挑战。该平台构建在微软的数据中心之上。<br>该平台可以分为三个主要的组件平台。Windows Azure提供了一个构建在Windows操作系统之上并基于微软虚拟化技术的云平台。<br>应用程序安装在部署在数据中心服务器上的虚拟机之上。Azure管理数据中心中所有的服务器、存储器和网络资源。在这些基础设施之上是构建不同云应用的各种服务。 </p>
<p>Live服务：用户可以访问微软Live应用，并跨越多台机器并行地使用所包括的数据。<br>.NET服务：支持应用程序在本地主机上开发、在云机器上执行。<br>SQL Azure：更易于用户访问和使用与云中SQL服务器相关的关系型数据库。<br>SharePoint服务：为用户提供了一个可伸缩和可管理的平台，可以在更新的Web服务上开发他们自己特定的商业应用。<br>动态CRM服务：为软件开发者提供了一个商业平台，可以在金融、市场、销售和促销方面管理CRM应用。</p>
<h2 id="云平台管理"><a href="#云平台管理" class="headerlink" title="云平台管理"></a>云平台管理</h2><h3 id="扩展的云计算服务"><a href="#扩展的云计算服务" class="headerlink" title="扩展的云计算服务"></a>扩展的云计算服务</h3><p>6层的云服务，范围从<strong>硬件、网络和配置</strong>到基础设施、平台和软件应用。我们已经分别介绍了SaaS、PaaS和IaaS上面这三个服务层。<br>云计算平台提供的PaaS位于IaaS的基础设施顶端。顶层提供SaaS 。这些都必须所提供的云平台上实现。<br>虽然三个基本模型用法不同，<strong>但它们是逐层建立的</strong>。言外之意是，没有云平台，就没有SaaS应用。如果计算和存储基础设施不存在，就不能构建云平台。</p>
<h3 id="云成员类型"><a href="#云成员类型" class="headerlink" title="云成员类型"></a>云成员类型</h3><p>云成员可以分为三大类： （1）云服务提供商和IT管理员，（2）软件开发商或供应商， （3）终端用户或企业用户。在IaaS、PaaS和SaaS模式下，这些云成员作用不同。</p>
<p>  从软件厂商的角度来看，一个给定的云平台的<strong>应用性能</strong>是最重要的。从供应商的角度来看，云计算基础<strong>设施性能</strong>最重要。从终端用户的角度来看，<strong>服务质量</strong>（包括安全性）是最重要的。 </p>
<h3 id="运行时支持服务"><a href="#运行时支持服务" class="headerlink" title="运行时支持服务"></a>运行时支持服务</h3><p>在集群环境中，也有一些云计算环境下的运行时支持服务。<strong>集群监控用于收集整个集群的运行时状态</strong>。<br><strong>根据节点的可用性，调度器将提交给整个集群的任务排序，并将任务分配给处理节点，云应用的分布式调度器具有支持云应用程序的特性，如调度用MapReduce风格编写的程序。运行时支持系统使云集群以高效率正常运作。</strong><br>成千上万的云客户使用用浏览器启动的应用程序，运行这种应用程序时，软件需要运行时支持。 SaaS模式是让用户租用软件应用程序，而不是购买软件。 </p>
<h3 id="资源调度方法"><a href="#资源调度方法" class="headerlink" title="资源调度方法"></a>资源调度方法</h3><p>资源调度的三种方法：（1）<strong>需求驱动方法提供静态资源</strong>；（2）<strong>事件驱动方法基于不同时期预测的工作负载而定</strong>；（3）<strong>人气驱动方法基于互联网流量监测。</strong> </p>
<h4 id="基于负载预测的资源分配方法"><a href="#基于负载预测的资源分配方法" class="headerlink" title="基于负载预测的资源分配方法"></a>基于负载预测的资源分配方法</h4><p>这种方法用于添加或删除基于特定时间事件的机器实例。该方案对季节性事件或预测事件（如在西方的圣诞节和东方的农历新年）效果更好。在这些特殊事件发生期间，用户数的增长与减少是可以预测的。这种方法预测事件发生前的流量高峰。如果事件的预测正确，这种方法会导致最少量的服务质量损失；否则，由于不遵循一种固定模式的事件，浪费的资源可能更大。主要采用的方法包括：<strong>基于时间序列分析、机器学习和深度学习的负载预测方法</strong> </p>
<h4 id="基于阈值的资源分配方法"><a href="#基于阈值的资源分配方法" class="headerlink" title="基于阈值的资源分配方法"></a>基于阈值的资源分配方法</h4><p>这种方法<strong>基于已分配资源的利用水平来添加或移除资源配置量</strong>。当用户使用一个Xeon处理器超过持续期时间的60%时，需求驱动方法自动为用户的应用程序分配两个Xeon处理器。一般情况下，当资源已超过某一时间阈值时，该方案将根据需求增加资源。当资源低于某一时间阈值时，资源也可相应减少。亚马逊在其 EC2 平台实现了这种自动缩放功能。这种方法比较容易实现。<strong>如果工作负载突然改变，本方法无法实现。</strong></p>
<h4 id="基于排队模型的资源分配方法"><a href="#基于排队模型的资源分配方法" class="headerlink" title="基于排队模型的资源分配方法"></a>基于排队模型的资源分配方法</h4><p><strong>假设任务到达间隔符合一定分布，例如负指数分布</strong><br><strong>服务时间长度也符合一定的分布，例如负指数分布</strong></p>
<h4 id="基于反馈控制的资源分配方法"><a href="#基于反馈控制的资源分配方法" class="headerlink" title="基于反馈控制的资源分配方法"></a>基于反馈控制的资源分配方法</h4><p><strong>排队模型不准确性</strong><br><strong>建立反馈控制系统</strong></p>
<h3 id="分布式存储资源"><a href="#分布式存储资源" class="headerlink" title="分布式存储资源"></a>分布式存储资源</h3><p><strong>数据存储层构建在物理服务器或虚拟服务器的顶部</strong>。由于云计算应用程序通常为用户提供服务，因此不可避免地要将数据存储在云提供商的集群中。该服务可以在世界任何地方被访问。电子邮件系统就是一个例子。另一个例子是Web搜索应用。在存储技术方面，未来可能用固态驱动器增强硬盘驱动器。这将提供可靠的和高性能的数据存储。</p>
<h4 id="虚拟机模板"><a href="#虚拟机模板" class="headerlink" title="虚拟机模板"></a>虚拟机模板</h4><p>包含虚拟机的如下信息：<br>要分配给虚拟机的核或处理器的数目。<br>虚拟机要求的内存量。<br>用于启动虚拟机的操作系统内核。<br>包含虚拟机文件系统的磁盘镜像。<br>每小时使用虚拟机的价格。</p>
<h4 id="分布式虚拟机管理"><a href="#分布式虚拟机管理" class="headerlink" title="分布式虚拟机管理"></a>分布式虚拟机管理</h4><p>分布式虚拟机管理器向虚拟机发出请求并查询它们的状态。这个管理器借助用户应用程序从网关请求虚拟机。管理器从网关获取被请求的虚拟机的列表。此列表包含为每个带有安全 Shell (SSH) 隧道的虚拟机分配的公用 IP/专用 IP 地址。<br>本地网关会尝试从底层 VIE 获取资源。当一个网关安排虚拟机时，它将访问信息发送给请求者网关。最后，<strong>管理器配置虚拟机、 设置 SSH 通道，并在虚拟机上执行任务。根据对等的政策，每个网关调度器使用保守的回填来安排请求。当调度器不能立即使用本地资源启动请求时，将启动重定向算法。</strong> </p>
<h2 id="云安全与信任管理"><a href="#云安全与信任管理" class="headerlink" title="云安全与信任管理"></a>云安全与信任管理</h2><p>需要的三个基本的云安全强制策略分别为：</p>
<p><strong>数据中心的设施安全要求全年的在线安全</strong>，为此通常会部署生物扫描器、CCTV（闭路电视）、移动探测；<br><strong>网络安全要求容错外部防火墙、入侵检测系统和第三方漏洞评定</strong>；<br><strong>平台安全要求SSL和数据解密、严格的密码策略和系统信任认证。</strong></p>
<h3 id="虚拟机的安全挑战"><a href="#虚拟机的安全挑战" class="headerlink" title="虚拟机的安全挑战"></a>虚拟机的安全挑战</h3><pre><code>安全感知的云体系结构必须具备安全措施。基于恶意软件的攻击（如网络蠕虫、病毒和DDoS攻击）利用系统漏洞，损害了系统功能或为侵入者提供了对敏感信息的非授权访问。
这里是一些需要特殊安全保护的云组件：
</code></pre>
<p>保护服务器免受蠕虫、病毒等恶意软件的攻击。<br>保护虚拟机hypervisor免受基于软件的攻击和漏洞问题。<br>保护虚拟机和监视器免受服务中断和拒绝服务攻击。<br>保护数据和信息免受失窃、损坏和自然灾害等意外。<br>提供对关键数据和服务的认证和授权访问。</p>
<h3 id="分布式入侵-异常检测"><a href="#分布式入侵-异常检测" class="headerlink" title="分布式入侵/异常检测"></a>分布式入侵/异常检测</h3><p><strong>在所有云模型中，数据安全是弱链。</strong>使用公共API工具处理<strong>数据互锁问题和网络攻击</strong>或弊病需要新的云安全标准。<br>安全威胁可能主要针对运行在云之上的虚拟机、客户操作系统和软件。<strong>入侵检测系统则尝试阻止攻击发挥作用。签名匹配和异常检测系统可以在用于建造入侵检测系统的虚拟机上实现</strong>。签名匹配的入侵检测技术更为成熟，但需要频繁更新签名数据库。网络异常检测则根据正常流量模式检测不正常的交通模式，例如一段未授权的TCP连接序列。分布式入侵检测系统需要防止这两类入侵。</p>
<h1 id="面向服务的分布式体系结构"><a href="#面向服务的分布式体系结构" class="headerlink" title="面向服务的分布式体系结构"></a>面向服务的分布式体系结构</h1><h2 id="面向服务的体系结构（SOA）-1"><a href="#面向服务的体系结构（SOA）-1" class="headerlink" title="面向服务的体系结构（SOA）"></a>面向服务的体系结构（SOA）</h2><p>SOA是关于如何设计<strong>一套使用服务的软件系统</strong>，<strong>使其通过已发布或可发现的接口使用新的或已有的应用</strong>。这些应用程序通常发布在网络上。<br>SOA还旨在使得服务的互操作性变得可扩展和有效。它提示支持这一目标的体系结构风格，如松耦合、发布的接口和标准的通信模型。<br>万维网联盟（World Wide Web Consortium，W3C）定义SOA为一种分布式系统体系结构</p>
<p><strong>SOA具有以下典型属性：</strong></p>
<p><strong>逻辑视图</strong>：<strong>SOA是实际程序、数据库、商业流程等的抽象逻辑视图</strong>，定义了它所做的事情，通常执行企业级的操作。服务是依据提供商代理和请求者代理之间交换的消息来形式化定义。<br><strong>基于消息</strong>：<strong>提供商和请求者的内部结构包括实现语言、进程结构和数据库结构</strong>。这些特征在SOA中都经过精心抽象化：使用SOA的架构，一个人不必也不需要知道实现服务的代理是如何构造的。可以将任何软件组件或应用程序“包装”在消息处理代码中，并使它完全符合形式化的服务定义。</p>
<p><strong>基于描述</strong>： <strong>服务由机器可执行的元数据来描述</strong>。这个描述支持SOA的公开本质：描述中只包括那些公开可访问的并对于服务应用来说很重要的细节。服务语义应通过其描述直接或间接地文档化。</p>
<p><strong>粒度</strong>： 服务倾向于使用较<strong>少数量的操作</strong>，<strong>使用大而复杂的消息</strong>。<br><strong>网络方向</strong> ：服务往往是在<strong>网络上沿着使用的方向</strong>，尽管这不是一个必需的要求。<br><strong>平台中立性</strong>：消息按照平台中立性、标准化的格式通过接口发送。<strong>XML</strong>是满足这个约束条件的最显然格式。</p>
<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><p>在SOA范式中，软件能力以基于消息的通信模型通过松耦合、可重用、粗粒度、可发现和自我包含的服务来传递和使用。<br> <strong>Web已经成为一种利用应用程序来连接远程客户端的媒介</strong>。<br>术语“Web服务”经常指那些<strong>自我包含的、自我描述的、模块化的应用程序，它们被设计来供网络上的其他软件程序使用或访问</strong>。一旦部署了一个Web服务，其他的应用和Web服务就可以发现并激活已经部署的服务<br><strong>Web服务是SOA实现的最常见实例之一</strong>。W3C工作组将Web服务定义为一个<strong>软件系统，支持网络上机器到机器的互操作交互</strong>。 </p>
<h3 id="组成目前Web服务核心的技术"><a href="#组成目前Web服务核心的技术" class="headerlink" title="组成目前Web服务核心的技术"></a>组成目前Web服务核心的技术</h3><p><strong>简单对象访问协议（SOAP）提供了一个标准的封装结构，用来在各种不同的互联网协议（如SMTP、HTTP和FTP）上传输XML文档。</strong>通过使用这样的标准消息格式，异构的中间件系统可以实现互操作。<br><strong>Web服务描述语言（WSDL）描述了接口，即Web服务支持的一系列标准格式的操作。</strong>它标准化了操作的输入和输出参数的表示以及服务的协议绑定，消息在线传输的方式。使用WSDL，不同的客户端可以自动理解如何与Web服务交互。<br><strong>通用描述、发现和集成（UDDI）</strong> universal description discover integrate<strong>提供了一种通过搜索名称、标识符、类别或Web服务实现的规范来广告和发现Web服务的全局注册表。</strong></p>
<p>UDDI（统一描述发现和集成）规范通过创建一个平台无关的开放框架定义了一种描述、发布和发现关于Web服务信息的方法。UDDI提供了名字服务和目录服务来通过名字或<strong>特定的属性查找服务描述</strong>。版本3.0成为OASIS的公共服务注册表标准。<br><strong>UDDI规范集中在一批服务的定义</strong>，它们支持以下内容的描述和发现：商业、组织和其他Web服务提供商；它们提供的Web服务；以及用来访问那些服务的技术接口。<br>注册表主要有两类：<strong>公共注册表</strong>，这是一个逻辑的集中式分布服务，彼此之间在一个约定的基础上复制数据；<strong>私有注册表</strong>，仅仅在单个的组织内部访问，或被一群有特定目的的商业伙伴所共享。 </p>
<h3 id="WS-I协议栈"><a href="#WS-I协议栈" class="headerlink" title="WS-I协议栈"></a>WS-I协议栈</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5lZhw9"><img src="https://z3.ax1x.com/2021/10/14/5lZhw9.png" alt="5lZhw9.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5lett1"><img src="https://z3.ax1x.com/2021/10/14/5lett1.png" alt="5lett1.png"></a></p>
<p><strong>SOAP消息包含应用程序使用的一个信封，里面封装了需要发送的消息。</strong>信封包括头和体模块。编码风格元素指的是XML模式的URI地址，用于对消息元素进行编码。<br><strong>SOAP消息中的每个元素可以采用不同的编码方式</strong>，但是除非特别指定，整个消息的编码方式定义在根元素的XML模式中。头部是SOAP消息的可选部分，它包含了上面提到的辅助信息，在这个例子中没有包含头部。<br><strong>SOAP请求-响应消息的体部分包含了会话的主要信息，它是由一个或多个XML模块来组成的。</strong> </p>
<h2 id="企业多层体系结构"><a href="#企业多层体系结构" class="headerlink" title="企业多层体系结构"></a>企业多层体系结构</h2><p><strong>企业应用程序通常使用多层体系结构来封装和集成各种功能。</strong><br>多层体系结构是一种<strong>客户端/服务器体系结构</strong>，<strong>其中表述、应用处理和数据管理是逻辑分离的过程</strong>。已知最简单的多层体系结构是两层，也就是客户端/服务器系统。传统的两层客户端/服务器模型需要集群化和灾难恢复来保证可靠性。虽然在企业中使用较少的节点会简化可管理性，但是改变管理仍然很困难，因为在修理、升级和部署新应用时，都需要服务器下线。而且在胖客户端环境下，新应用和增强的部署非常复杂和消耗时间，从而降低了可用性。 </p>
<p>一个三层的信息系统包含以下的层次：</p>
<p><strong>表述层</strong>  向外部实体描述信息，并且允许它们通过提交操作和获得响应来与系统进行交互。<br><strong>商业/应用逻辑层或中间件</strong>  通过表述层完成客户端请求的实际操作的程序。中间层也可以控制用户的认证、访问资源，以及完成一些客户端查询处理，这样可以减少数据库服务器的一些负载。<br><strong>资源管理层也称为数据层</strong>  处理和实现信息系统的不同数据源。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5l3M1s"><img src="https://z3.ax1x.com/2021/10/14/5l3M1s.md.png" alt="5l3M1s.md.png"></a></p>
<h2 id="网格服务和OGSA"><a href="#网格服务和OGSA" class="headerlink" title="网格服务和OGSA"></a>网格服务和OGSA</h2><p><strong>开放网格服务体系结构</strong>（OGSA）旨在为基于网格的应用定义一个通用的、标准的和开放的体系结构。可以成为基于服务的网格。OGSA的意图在于：<br><strong>便于在分布式的异构环境上使用和管理资源。</strong><br>提供无缝的服务质量。<br>为了<strong>提供不同资源之间的互操作性，定义开放的发布接口。</strong><br>采用工业标准的集成技术。<br>开发实现互操作性的标准。<br>在分布式的异构环境中集成、虚拟化和管理各种服务与资源。<br>提供松耦合的可交互服务，并且满足工业可接受的Web服务标准。</p>
<h3 id="OGSA体系结构服务："><a href="#OGSA体系结构服务：" class="headerlink" title="OGSA体系结构服务："></a>OGSA体系结构服务：</h3><p><strong>基础设施服务</strong>  指一系列的公共功能。<br><strong>运行管理服务</strong>  与启动和管理任务这些问题有关。<br><strong>数据管理服务</strong>  用来移动数据到需要它的地方、维护复制的副本、运行查询和更新，以及转换数据到新的格式。<br><strong>资源管理服务</strong>  为网格资源提供管理功能。<br><strong>安全服务</strong>  便于一个（虚拟的）组织内有关安全的策略得以强制执行，支持安全的资源共享。<br><strong>信息服务</strong>  提供关于网格及其构成资源信息的有效产生和访问。<br><strong>自我管理服务</strong>  支持对于一系列服务(或者资源)的服务级实现，并且要尽可能的自动化。</p>
<h3 id="Web服务资源框架（WSRF）"><a href="#Web服务资源框架（WSRF）" class="headerlink" title="Web服务资源框架（WSRF）"></a>Web服务资源框架（WSRF）</h3><p>Web Services Resources Framework</p>
<p>为了实现有状态的Web服务而提出的一个标准：Web服务的状态保存在资源中，web服务和资源的映射由WS-resource管理。资源的寻址由WS-Adressing规范实现。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5lN8BR"><img src="https://z3.ax1x.com/2021/10/14/5lN8BR.png" alt="5lN8BR.png"></a></p>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST是应用于分布式系统的软件体系结构风格，尤其是像万维网这样的分布式超媒体系统。 </p>
<p>REST体系结构风格基于以下四项原则：<br><strong>通过URI的资源标识</strong>：REST的Web服务公开了一组资源，标识了与其客户端进行交互的目标。REST中信息的关键抽象是资源。<br><strong>统一的受限接口</strong>：通过客户端/服务器可缓存的协议HTTP标准来完成与REST风格的Web服务进行交互。<br><strong>自我描述的消息</strong>：REST消息包含足够的信息来描述如何处理消息。这使得中介机构不需要解析消息内容就可以对消息进行更多的操作。<br><strong>无状态的交互</strong>： REST的交互是“无状态的”，意味着消息的含义不依赖于会话状态。 </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5lgDWd"><img src="https://z3.ax1x.com/2021/10/14/5lgDWd.png" alt="5lgDWd.png"></a></p>
<h2 id="语义Web"><a href="#语义Web" class="headerlink" title="语义Web"></a>语义Web</h2><p><strong>语义Web是关于自动化发现和集成的</strong>：给数据增加机器可处理的语义，这样计算机可以理解这些信息并代表终端用户处理它，从而基于为Web页面附加丰富元数据而使Web搜索和链接更加智能。<br>语义Web旨在提供一个环境，在里面软件代理能够动态地发现、询问和互操作资源并代替人执行复杂的任务 </p>
<p>为了达到这一目的，已经进行了很多工作来保证在公共数据模型——资源描述框架（RDF）中Web资源的含义，RDF使用以公共语言（如OWL Web本体语言）表示的一致本体论，这样我们可以共享元数据，并且增加到背景知识中。<br>从这个基础上，我们应该可以<strong>查询、过滤、集成和聚集元数据</strong>，并应用规则和策略在它的上面推理出更多的元数据。<br><strong>RDF是为语义Web开发的第一个语言</strong>，使用XML来表示Web上资源的信息（包括元数据）。RDF使用Web标识符（URI），并且从简单的属性和属性值方面来描述资源。OWL是拓展了RDF模式的一个描述性本体语言。</p>
<h2 id="面向服务的体系结构中的工作流"><a href="#面向服务的体系结构中的工作流" class="headerlink" title="面向服务的体系结构中的工作流"></a>面向服务的体系结构中的工作流</h2><h3 id="工作流的基本概念"><a href="#工作流的基本概念" class="headerlink" title="工作流的基本概念"></a>工作流的基本概念</h3><p>工作流是“对服务之间交互进行编程”的方法。同称呼工作流描述了“为Web或网格编程”一样，我们也可以使用诸如“软件协调”、“服务编排”、“服务或过程协调”、“服务会话”、“Web或网格脚本”、“应用集成”或“软件总线”之类的名字。</p>
<p>必须注意工作流意味着分布式系统的两层编程模型。基本服务采用传统语言（C、C++、Fortran、Java、Python）进行编程，<strong>工作流描述了服务之间彼此交互的粗粒度编程</strong>。每一个服务使用传统的语言进行编程，而它们之间的交互用工作流描述。</p>
<h3 id="工作流体系结构和规范"><a href="#工作流体系结构和规范" class="headerlink" title="工作流体系结构和规范"></a>工作流体系结构和规范</h3><p>大多数工作流系统都有两个关键组件<br>工作流描述规范<br>工作流运行引擎</p>
<p>一般的工作流结构<strong>是有向无环图</strong>，它是顶点和有向边的集合，每一条边从一个节点连到另一个，这样里面没有环。也就是说，从某一个顶点V开始，沿着一系列的边，最终不可能再回到顶点V。<br>除了复杂的专业工作流系统外，可能使用传统语言和工具集的脚本是构建工作流的主要技术。通常这可以使用任何分布式计算（互联网）支持的环境以非正式的方式实现<br>最复杂的工作流系统支持层次化规范，即工作流的节点可以是服务或服务集（子工作流）。这和网格的网格概念一致。 </p>
<h1 id="云编程-MapReduce"><a href="#云编程-MapReduce" class="headerlink" title="云编程 MapReduce"></a>云编程 MapReduce</h1><h2 id="并行和分布式编程范式"><a href="#并行和分布式编程范式" class="headerlink" title="并行和分布式编程范式"></a>并行和分布式编程范式</h2><p>我们把并行和分布式程序定义为运行在多个计算引擎或一个分布式计算系统上的并行程序。这个术语包含计算机科学中的两个基本概念：分布式计算系统和并行计算。<strong>分布式计算系统是一系列由网络连接的计算引擎，它们完成一个共同目标：运行一个作业或者一个应用</strong>。计算机集群或工作站网络就是分布式计算系统的一个实例。并行计算是同时<strong>运用多个计算引擎（并不一定需要网络连接）来运行一个作业或者一个应用。</strong> </p>
<h3 id="并行和分布式编程范式需要考虑的因素"><a href="#并行和分布式编程范式需要考虑的因素" class="headerlink" title="并行和分布式编程范式需要考虑的因素"></a>并行和分布式编程范式需要考虑的因素</h3><p>由多个网络节点或者工作机组成用并行或分布式方式来运行并行程序，该系统包括以下方面 :<br>1.<strong>分区</strong>：分区适用于计算和数据两方面：<br><strong>计算分区</strong>：计算分区是把一个给定的<strong>任务或者程序分割成多个小任务</strong>。分区过程很大程度上依靠正确识别可以并发执行的作业或程序的每一小部分。<br><strong>数据分区</strong>：数据分区是把输入或中间<strong>数据分割成更小的部分</strong>。类似地，一旦识别出输入数据的并行性，它也可以被分割成多个部分，能在不同的工作机上运行。数据块可由程序的不同部分或者同一程序的副本来处理。 </p>
<p>2.<strong>映射</strong>：映射是把更<strong>小的程序部分或者更小的数据分块分配给底层的资源</strong>。这个过程的目的在于合理分配这些部分或者分块，使它们能够同时在不同的工作机上运行。映射通常由系统中的资源分配器来处理。</p>
<p>3.<strong>同步</strong>：因为不同工作机可以执行不同的任务，工作机之间的同步和协调就很有必要。这样可以避免竞争条件，不同工作机之间的数据依赖也能被恰当地管理。不同工作机多路访问共享资源可能引起竞争条件。然而，当一个工作机需要其他工作机处理的数据时会产生数据依赖。</p>
<p>4.<strong>通信</strong>：因为<strong>数据依赖是工作机之间通信的一个主要原因</strong>，当中间数据准备好在工作机之间传送时，通信通常就开始了。</p>
<p>5.<strong>调度</strong>：对于一项作业或一个程序，当计算部分（任务）或数据块的数量多于可用的工作机数量时，调度程序就会选择一个任务或数据块的序列来分配给工作机。值得注意的是，<strong>资源分配器完成计算或数据块到工作机的实际映射</strong>，<strong>而调度器只是基于一套称为调度策略的规则</strong>，来从没有分配的任务队列中选择下一个任务。对于多作业或多程序，调度器会选择运行在分布式计算系统上的一个任务或程序的序列。 </p>
<h3 id="设计并行和分布式编程范式的动机"><a href="#设计并行和分布式编程范式的动机" class="headerlink" title="设计并行和分布式编程范式的动机"></a>设计并行和分布式编程范式的动机</h3><p>提供并行和分布式编程范式或模型来抽象用户数据流的多个部分。<br>编写并行程序的简单性是度量并行和分布式编程范式的重要标准。并行和分布式编程模型背后的其他动机还有：（1）提高程序员的生产效率，（2）减少程序进入市场的时间，（3）更有效地利用底层资源，（4）提高系统的吞吐量，（5）支持更高层的抽象。<br>MapReduce、Hadoop和Spark等是广泛使用的并行和分布式编程模型。这些模型是为信息检索应用而开发的，不过已经显示出它们也适用于各种重要应用 </p>
<h2 id="MapReduce、Twister和迭代MapReduce"><a href="#MapReduce、Twister和迭代MapReduce" class="headerlink" title="MapReduce、Twister和迭代MapReduce"></a>MapReduce、Twister和迭代MapReduce</h2><p>MapReduce是一个软件框架，可以支持大规模数据集上的并行和分布式计算。这个软件框架抽象化了在分布式计算系统上运行一个并行程序的数据流，并以两个函数的形式提供给用户两个接口：Map(映射)和Reduce（化简）。用户可以重载这两个函数以实现交互和操纵运行其程序的数据流。</p>
<p> 图6-1说明了在MapReduce框架中从Map到 Reduce函数的逻辑数据流。在这个框架中，数据的‘value’345部分（key，value）是实际数据，‘key’部分只是被MapReduce控制器使用来控制数据流。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5LxBdJ"><img src="https://z3.ax1x.com/2021/10/28/5LxBdJ.png" alt="5LxBdJ.png"></a></p>
<h3 id="MapReduce的形式化定义"><a href="#MapReduce的形式化定义" class="headerlink" title="MapReduce的形式化定义"></a>MapReduce的形式化定义</h3><p>MapReduce软件框架向用户提供了一个具有<strong>数据流和控制流的抽象层</strong>，并<strong>隐藏了所有数据流实现的步骤</strong>，比如，数据分块、映射、同步、通信和调度。这里，虽然在这样的框架中数据流已被预定义，但抽象层还提供两个定义完善的接口，这两个接口的形式就是Map和Reduce这两个函数。这两个主函数能由用户重载以达到特定目标。</p>
<p>用户首先重载Map和Reduce函数，然后从库里调用提供的函数MapReduce(Spec, &amp; Results)来开始数据流。MapReduce函数<strong>MapReduce(Spec, &amp; Results)<strong>有一个重要的参数，这个参数是一个</strong>规范对象‘Spec’</strong>。它首先在用户的程序里初始化，然后用户编写代码来填入输入和输出文件名，以及其他可选调节参数。这个对象还填入了Map和Reduce函数的名字，以识别这些用户定义的函数和MapReduce库里提供的函数。<br>下面给出了用户程序的整个结构，包括Map、Reduce和Main函数。Map和Reduce是两个主要的子程序。它们被调用来实现在主程序中执行的所需函数。</p>
<h3 id="MapReduce逻辑数据流"><a href="#MapReduce逻辑数据流" class="headerlink" title="MapReduce逻辑数据流"></a>MapReduce逻辑数据流</h3><p>Map和Reduce函数的输入数据有特殊的结构。输出数据也一样。Map函数的输入数据是以（key, value）对的形式出现。例如，key是输入文件的行偏移量，value是行内容。Map函数的输出数据的结构类似于(key, value)对，称为中间(key, value)对。换句话说，用户自定义的Map函数处理每个输入的(key, value)对，并产生很多(zero, one, or more)中间(key, value)对。这里的目的是为Map函数并行处理所有输入的(key, value)对 </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5LzhcV"><img src="https://z3.ax1x.com/2021/10/28/5LzhcV.png" alt="5LzhcV.png"></a></p>
<p>反过来，Reduce函数以中间值群组的形式接受中间(key, value)对，这个中间值群组和一个中间key(key, [set of values])相关。<br>实际上，MapReduce框架形成了这些群组，首先是对中间(key, value)对排序，然后以相同的key来把value分组。<br>需要注意的是，<strong>数据的排序是为了简化分组过程</strong>。Reduce函数处理每个(key, [set of values])群组，并产生(key, value)对集合作为输出。 </p>
<h3 id="MapReduce真实数据和控制流"><a href="#MapReduce真实数据和控制流" class="headerlink" title="MapReduce真实数据和控制流"></a>MapReduce真实数据和控制流</h3><p>1.<strong>数据分区</strong>：MapReduce库将已存入GFS的输入数据（文件）分割成M部分，M也即映射任务的数量。</p>
<p>2.<strong>计算分区</strong>：计算分块通过强迫用户以Map和Reduce函数的形式编写程序，（在MapReduce框架中）被隐式地处理。所以，MapReduce库<strong>只生成用户程序的多个复制</strong>（例如，通过fork系统调用），它们包含了Map和Reduce函数，然后在多个可用的计算引擎上分配并启动它们</p>
<p>3.<strong>决定主服务器（master）和服务器（worker）</strong>：MapReduce体系结构是基于<strong>主服务器-服务器模式</strong>的。所以<strong>一个用户程序的复制变成了主服务器，其他则是服务器</strong>。主服务器挑选空闲的服务器，并分配Map和Reduce任务给它们。典型地，一个映射/化简服务器是一个计算引擎，例如集群节点，通过执行Map/Reduce函数来运行映射/化简任务。步骤4～7描述了映射服务器。</p>
<p>4.<strong>读取输入数据（数据分发）</strong>：<strong>每一个映射服务器读取其输入数据的相应部分</strong>，<strong>即输入数据分割</strong>，然后输入至其Map函数。虽然一个映射服务器可能运行多个Map函数，这意味着它分到了不止一个输入数据分割；通常每个服务器只分到一个输入分割。</p>
<p>5.<strong>Map函数</strong>：每个Map函数以（key，value）对集合的形式收到输入数据分割，来<strong>处理并产生中间（key, value）对。</strong><br>6.<strong>Combiner函数</strong>：Combiner函数是映射服务器中一个可选的本地函数，适用于中间(key, value)对。用户可以在用户程序里调用Combiner函数。Combiner函数运行用户为Reduce函数所写的相同代码，因为它们的功能是一样的。Combiner函数合并每个映射服务器的本地数据，然后送到网络传输，以有效减少通信成本。正如我们在逻辑数据流的讨论中提到的，MapReduce框架对数据进行排序并分组，然后数据被Reduce函数处理。类似地，如果用户调用Combiner函数，MapReduce框架也会对每个映射服务器的本地数据排序并分组。</p>
<p>7.<strong>Partitioning函数</strong>：正如在MapReduce数据流中提到的，具有相同键值的中间(key, value)对被分组到一起，因为每个组里的所有值都应只由一个Reduce函数来处理产生最终结果。然而在实际实现中，由于有M个map和R个化简任务，有相同key的中间(key, value)对可由不同的映射任务产生，尽管它们只应由一个Reduce函数来一起分组并处理。<br>由每一个映射服务器产生的中间(key, value)对被分成R个区域，这和化简任务的数量相同。分块是由Partitioning（分区）函数完成，并能保证有相同键值的所有(key, value)对都能存储在同一区域内。因此，由于化简服务器i读取所有映射服务器区域i中的数据，有相同key的所有(key, value)对将由相应的化简服务器i收集。 </p>
<p>8.<strong>同步</strong>：MapReduce使用简单的同步策略来协调映射服务器和化简服务器，<strong>当所有映射任务完成时，它们之间的通信就开始了</strong>。</p>
<p>9.<strong>通信</strong>：Reduce服务器i已经知道所有映射（Map）服务器的区域i的位置，<strong>使用远程过程调用来从所有映射服务器的各个区域中读取数据</strong>。由于所有化简服务器从所有映射服务器中读取数据，映射和化简服务器之间的多对多通信在网络中进行，会引发网络拥塞。这个问题是提高此类系统性能的一个主要瓶颈。</p>
<p>10**.排序和分组**：当化简服务器完成读取输入数据的过程时，数据首先在化简服务器的本地磁盘中缓冲。然后化简服务器根据key将数据排序来对中间(key, value)对进行分组，之后对出现的所有相同key进行分组。注意，缓冲数据已经排序并分组，因为一个映射服务器产生的唯一key的数量可能会多于R个区域，所以在每个映射服务器区域中可能有不止一个key。</p>
<p>11.<strong>Reduce函数</strong>：化简服务器在已分组的(key, value)对上进行迭代。对于每一个唯一的key，它把key和对应的value发送给Reduce函数。然后，这个函数处理输入数据，并将最后输出结果存入用户程序已经指定的文件中。</p>
<h3 id="计算-数据密切度"><a href="#计算-数据密切度" class="headerlink" title="计算-数据密切度"></a>计算-数据密切度</h3><p>MapReduce软件框架最早是由谷歌提出并实现的。首次实现是用C语言编码的。该实现是将谷歌文件系统 (GFS)的优势作为最底层。MapReduce可以完全适用于GFS。GFS是一个分布式文件系统，其中<strong>文件被分成固定大小的块</strong>，这些块被分发并存储在集群节点上。<br>如前所述，MapReduce库将输入数据（文件）分割成固定大小的块，理想状态下是在每个块上并行地执行Map函数。在这种情况下，由于GFS已经将文件保存成多个块，MapReduce框架只需要将包含Map函数的用户程序复制发给已经存有数据块的节点。这就是将计算发向数据，而不是将数据发给计算。注意，GFS块默认为64MB，这和MapReduce框架是相同的。</p>
<h3 id="Twister和迭代MapReduce"><a href="#Twister和迭代MapReduce" class="headerlink" title="Twister和迭代MapReduce"></a>Twister和迭代MapReduce</h3><p><strong>并行开销的两个主要来源是负载不均衡和通信</strong></p>
<p>在所有“经典并行的”松散同步应用中可以看到同样的现象，典型地需要在计算阶段加入一个迭代结构，然后是通信阶段。可以通过两个重要的改变来解决性能问题：</p>
<p>1.<strong>在各个步骤之间的流信息，不把中间结果写入磁盘。</strong></p>
<p>2**.使用长期运行的线程或进程与δ（在迭代之间）流进行通信。**</p>
<p>这些改变将会导致重大的性能提升，代价是较差的容错能力，同时更容易支持动态改变，如可用节点的数量。这个概念已经在多个项目中应用</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5OkSz9"><img src="https://z3.ax1x.com/2021/10/28/5OkSz9.png" alt="5OkSz9.png"></a></p>
<h2 id="Apache的Hadoop软件库"><a href="#Apache的Hadoop软件库" class="headerlink" title="Apache的Hadoop软件库"></a>Apache的Hadoop软件库</h2><p>Hadoop是Apache用Java编码和发布的MapReduce开源实现。MapReduce的Hadoop实现使用Hadoop分布式文件系统(Hadoop Distributed File System，HDFS)作为底层，而不是GFS。Hadoop内核分为两个基本层：MapReduce 引擎和HDFS。MapReduce 引擎是运行在HDFS之上的计算引擎，使用HDFS作为它的数据存储管理器。</p>
<p>HDFS: HDFS是一个源于GFS的分布式文件系统，是在一个分布式计算系统上管理文件和存储数据。</p>
<p><strong>HDFS体系结构</strong>：HDFS有一个主从体系结构，包括一个<strong>单个NameNode作为master以及多个DataNodes作为工作机(slave)<strong>。为了在这个体系结构中存储文件，HDFS将文件分割成</strong>固定大小的块</strong>（例如64MB），并将这些块存到工作机(DataNodes)中。<strong>从块到DataNodes的映射是由NameNode决定的。</strong>NameNode (master)也管理文件系统的元数据和命名空间。在这个系统中，命名空间是维护元数据的区域，而元数据是指一个文件系统存储的所有信息，它们是所有文件的全面管理所需要的。例如，<strong>元数据中的NameNode存储了所有DataNodes上关于输入块位置的所有信息</strong>。每个DataNode，通常是集群中每个节点一个，管理这个节点上的存储。<strong>每个DataNode负责它的文件块的存储和检索</strong> </p>
<p><strong>HDFS特性</strong>：分布式文件系统为了能高效地运作，会有一些特殊的需求，比如性能、可扩展性、并发控制、容错能力和安全需求[62]。然而，因为HDFS不是一个通用的文件系统，即它仅执行特殊种类的应用，所以它不需要一个通用分布式文件系统的所有需求。例如，HDFS系统从不支持安全性。下面的讨论着重突出HDFS区别于其他一般分布式文件系统的两个重要特征。<br><strong>HDFS容错能力</strong>：HDFS的一个主要方面就是容错特征。由于Hadoop设计时默认部署在廉价的硬件上，系统硬件故障是很常见的。所以，Hadoop考虑以下几个问题来达到文件系统的可靠性要求：</p>
<p><strong>块复制</strong>：为了能在HDFS上可靠地存储数据，在这个系统中文件块被复制了。换句话说，HDFS把文件存储为一个块集，每个块都有备份并在整个集群上分发。<br><strong>备份布置</strong>：备份的布置是HDFS实现所需要的容错功能的另一个因素。虽然在整个集群的不同机架的不同节点上(DataNodes)，存储备份提供了更大的可靠性，但这有时会被忽略，因为不同机架上两个节点之间的通信成本要比同一个机架上两个不同节点之间的通信相对要高。<br><strong>Heartbeat和Blockreport消息</strong>：Heartbeats和Blockreports是在一个集群中由每个DataNode传给NameNode的周期性消息。收到Heartbeat 意味着DataNode正运行正常，而每个Blockreport包括了DataNode上所有块的一个清单。</p>
<h3 id="Hadoop-上的MapReduce-体系结构"><a href="#Hadoop-上的MapReduce-体系结构" class="headerlink" title="Hadoop 上的MapReduce 体系结构"></a>Hadoop 上的MapReduce 体系结构</h3><p>Hadoop的顶层是MapReduce引擎，管理着分布式计算系统上MapReduce作业的数据流和控制流。</p>
<p>类似于HDFS，MapReduce引擎也有一个主/从（master/slave）体系结构，由一个单独的JobTracker作为主服务器并由许多的TaskTracker作为服务器(slaves)。JobTracker在一个集群上管理MapReduce作业，并负责监视作业和分配任务给TaskTracker。TaskTracker管理着集群上单个计算节点的映射和化简任务的执行。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5OERVx"><img src="https://z3.ax1x.com/2021/10/28/5OERVx.png" alt="5OERVx.png"></a></p>
<p>每个TaskTracker节点都有许多同时运行槽，每个运行是映射任务或者化简任务。插槽是由TaskTracker 节点的CPU支持同时运行的线程数量来确定的。</p>
<p>比如，一个带有N个CPU的TaskTracker节点，每个都支持M个线程，共有M×N个同时运行的槽。需要注意的是，每个数据块都是由运行在单独的一个槽上的映射任务处理的。</p>
<p>所以， <strong>在TaskTracker 上的映射任务和在各个DataNode上的数据块之间存在一一对应关系。</strong></p>
<h3 id="在Hadoop里运行一个作业"><a href="#在Hadoop里运行一个作业" class="headerlink" title="在Hadoop里运行一个作业"></a>在Hadoop里运行一个作业</h3><p>在这个系统中有三个部分共同完成一个作业的运行：用户节点、JobTracker和数个TaskTracker。数据流最初是在运行于用户节点上的用户程序中调用runJob(conf)函数，其中conf是MapReduce 框架和HDFS中一个对象，它包含了一些调节参数。runJob(conf)函数和conf如同谷歌MapReduce第一次实现中的MapReduce(Spec, &amp;Results) 函数和Spec。图6-12描述了在Hadoop上运行一个MapReduce作业的数据流 </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5OVCss"><img src="https://z3.ax1x.com/2021/10/28/5OVCss.png" alt="5OVCss.png"></a></p>
<p><strong>作业提交</strong>：每个作业都是由用户节点通过以下步骤提交给JobTracker节点，此节点可能会位于集群内一个不同的节点上：</p>
<p>一个用户节点从JobTracker请求一个新的作业ID，并计算输入文件分块。</p>
<p>用户节点复制一些资源，比如用户的JAR文件、配置文件和计算输入分块，至JobTracker文件系统。</p>
<p>用户节点通过调用submitJob()函数提交任务至JobTracker。</p>
<p><strong>任务分配</strong>：JobTracker为用户节点的每个计算输入块建立一个映射任务，并分配给TaskTracker的执行槽。当分配映射任务给TaskTracker时，JobTracker会考虑数据的定位。JobTracker也会创建化简任务，并分配给TaskTracker。 </p>
<p><strong>任务执行</strong>：把作业JAR文件复制到其文件系统之后，在TaskTracker执行一个任务（不管映射还是化简）的控制流就开始了。在启动Java虚拟机（Java Virtual Machine，JVM）来运行它的映射或化简任务后，就开始执行作业JAR文件里的指令。<br><strong>任务运行校验</strong>：通过接收从TaskTracker到JobTracker的周期性心跳监听消息来完成任务运行校验。每个心跳监听会告知JobTracker传送中的TaskTracker是可用的，以及传送中的TaskTracker是否准备好运行一个新的任务。 </p>
<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h2 id="Spark与Hadoop区别"><a href="#Spark与Hadoop区别" class="headerlink" title="Spark与Hadoop区别"></a>Spark与Hadoop区别</h2><p><strong>Spark把中间数据放到内存中</strong>，迭代运算效率高。MapReduce中计算结果需要落地，保存到磁盘上，这样势必会影响整体速度，而Spark支持DAG图的分布式并行计算的编程框架，减少了迭代过程中数据的落地，提高了处理效率。<br><strong>Spark容错性高</strong>。Spark引进了弹性分布式数据集RDD (Resilient Distributed Dataset) 的抽象，它是分布在一组节点中的只读对象集合，这些集合是弹性的，<strong>如果数据集一部分丢失，则可以根据“血统”（即充许基于数据衍生过程）对它们进行重建。</strong><br><strong>Spark更加通用。</strong>不像Hadoop只提供了Map和Reduce两种操作，Spark提供的数据集操作类型有很多种，大致分为：Transformations和Actions两大类。Transformations包括Map、Filter、FlatMap、Sample、GroupByKey、ReduceByKey、Union、Join、Cogroup、MapValues、Sort和PartionBy等多种操作类型，同时还提供Count, Actions包括Collect、Reduce、Lookup和Save等操作。另外各个处理节点之间的通信模型不再像Hadoop只有Shuffle一种模式，用户可以命名、物化，控制中间结果的存储、分区等。</p>
<h2 id="Resilient-Distributed-Dataset-（RDD）"><a href="#Resilient-Distributed-Dataset-（RDD）" class="headerlink" title="Resilient Distributed Dataset （RDD）"></a>Resilient Distributed Dataset （RDD）</h2><p>RDD是Spark的最基本抽象,是对分布式内存的抽象使用，实现了以操作本地集合的方式来操作分布式数据集的抽象实现。RDD是Spark最核心的东西，<strong>它表示已被分区，不可变的并能够被并行操作的数据集合，</strong>不同的数据集格式对应不同的RDD实现。<strong>RDD必须是可序列化的。RDD可以cache到内存中，每次对RDD数据集的操作之后的结果</strong>，都可以存放到内存中，下一个操作可以直接从内存中输入，省去了MapReduce大量的磁盘IO操作。这对于迭代运算比较常见的机器学习算法, 交互式数据挖掘来说，效率提升非常大。</p>
<p>来源：一种是从<strong>持久存储获取数据</strong>，另一种是<strong>从其他RDD生成</strong><br>只读：状态不可变，不能修改<br>分区：<strong>支持元素根据 Key 来分区</strong> ( Partitioning ) ，保存到多个结点上，<strong>还原时只会重新计算丢失分区的数据</strong>，而不会影响整个系统<br>路径：<strong>在 RDD 中叫世族或血统 ( lineage )</strong> ，即 RDD 有充足的信息关于它是如何从其他 RDD 产生而来的<br>持久化：<strong>可以控制存储级别（内存、磁盘等）来进行持久化</strong><br>操作：<strong>丰富的动作 ( Action )</strong> ，如Count、Reduce、Collect和Save 等</p>
<h2 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h2><h3 id="Transformation-采用lazy模式"><a href="#Transformation-采用lazy模式" class="headerlink" title="Transformation 采用lazy模式"></a>Transformation 采用lazy模式</h3><p>从一个RDD转换生成另一个RDD的操作不是马上执行，Spark在遇到Transformations操作时只会记录需要这样的操作，并不会去执行，<strong>需要等到有Actions操作的时候才会真正启动计算过程进行计算。</strong><br><strong>Actions操作</strong>会返回结果或把RDD数据<strong>写到存储系统中</strong>。<strong>Actions是触发Spark启动计算的动因</strong></p>
<h2 id="宽依赖和窄依赖"><a href="#宽依赖和窄依赖" class="headerlink" title="宽依赖和窄依赖"></a>宽依赖和窄依赖</h2><h3 id="窄依赖（Narrow-Dependencies-）"><a href="#窄依赖（Narrow-Dependencies-）" class="headerlink" title="窄依赖（Narrow Dependencies ）"></a>窄依赖（Narrow Dependencies ）</h3><p>Ø  子RDD 的每个分区依赖于常数个父分区（即与数据规模无关）<br>Ø  输入输出一对一的算子，且结果RDD 的分区结构不变，主要是map 、flatMap<br>Ø  输入输出一对一，但结果RDD 的分区结构发生了变化，如union 、coalesce<br>Ø  从输入中选择部分元素的算子，如filter 、distinct 、subtract 、sample</p>
<h3 id="宽依赖（Wide-Dependencies-）"><a href="#宽依赖（Wide-Dependencies-）" class="headerlink" title="宽依赖（Wide Dependencies ）"></a>宽依赖（Wide Dependencies ）</h3><p>Ø  子RDD 的每个分区依赖于所有父RDD 分区<br>Ø  对单个RDD 基于Key 进行重组和reduce，如groupByKey 、reduceByKey ；<br>Ø  对两个RDD 基于Key 进行join 和重组，如join</p>
<h2 id="存储内存管理"><a href="#存储内存管理" class="headerlink" title="存储内存管理"></a>存储内存管理</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5jF4Re"><img src="https://z3.ax1x.com/2021/10/29/5jF4Re.png" alt="5jF4Re.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5jFqdP"><img src="https://z3.ax1x.com/2021/10/29/5jFqdP.png" alt="5jFqdP.png"></a></p>
<h3 id="RDD-缓存的过程"><a href="#RDD-缓存的过程" class="headerlink" title="RDD 缓存的过程"></a>RDD 缓存的过程</h3><p>RDD 在缓存到存储内存之前，Partition 中的数据一般以迭代器（Iterator）的数据结构来访问，这是 Scala 语言中一种遍历数据集合的方法。<strong>通过 Iterator 可以获取分区中每一条序列化或者非序列化的数据项(Record)，这些 Record 的对象实例在逻辑上占用了 JVM 堆内内存的 other 部分的空间</strong>，同一 Partition 的不同 Record 的空间并不连续。<br><strong>RDD 在缓存到存储内存之后，Partition 被转换成 Block</strong>，所有Record 在堆内或堆外存储内存中占用一块连续的空间。将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll）</p>
<p>因为不能保证存储空间可以一次容纳 Iterator 中的所有数据，<strong>当前的计算任务在 Unroll 时要向 MemoryManager 申请足够的 Unroll 空间来临时占位</strong>，空间不足则 Unroll 失败，空间足够时可以继续进行。对于序列化的 Partition，其所需的 Unroll 空间可以直接累加计算，一次申请。而非序列化的 Partition 则要在遍历 Record 的过程中依次申请，即每读取一条 Record，采样估算其所需的 Unroll 空间并进行申请，空间不足时可以中断，释放已占用的 Unroll 空间。如果最终 Unroll 成功，当前 Partition 所占用的 Unroll 空间被转换为正常的缓存 RDD 的存储空间</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5jAH4f"><img src="https://z3.ax1x.com/2021/10/29/5jAH4f.png" alt="5jAH4f.png"></a></p>
<h3 id="淘汰和落盘"><a href="#淘汰和落盘" class="headerlink" title="淘汰和落盘"></a>淘汰和落盘</h3><p>由于同一个 Executor 的所有的计算任务共享有限的存储内存空间，当有新的 Block 需要缓存但是剩余空间不足且无法动态占用时，就要对 LinkedHashMap 中的旧 Block 进行淘汰（Eviction），而被淘汰的 Block 如果其存储级别中同时包含存储到磁盘的要求，则要对其进行落盘（Drop），否则直接删除该 Block。</p>
<h2 id="执行内存管理"><a href="#执行内存管理" class="headerlink" title="执行内存管理"></a>执行内存管理</h2><h3 id="多任务间内存分配"><a href="#多任务间内存分配" class="headerlink" title="多任务间内存分配"></a>多任务间内存分配</h3><p>Executor 内运行的任务同样共享执行内存，<strong>Spark 用一个 HashMap 结构保存了任务到内存耗费的映射</strong>。每个任务可占用的执行内存大小的范围为 1/2N ~ 1/N，其中 N 为当前 Executor 内正在运行的任务的个数。每个任务在启动之时，<strong>要向 MemoryManager 请求申请最少为 1/2N 的执行内存，如果不能被满足要求则该任务被阻塞</strong>，直到有其他任务释放了足够的执行内存，该任务才可以被唤醒</p>
<h3 id="Shuffle-的内存占用"><a href="#Shuffle-的内存占用" class="headerlink" title="Shuffle 的内存占用"></a>Shuffle 的内存占用</h3><p>执行内存主要用来存储任务在执行 Shuffle 时占用的内存，Shuffle 是按照一定规则对 RDD 数据重新分区的过程，我们来看 Shuffle 的 Write 和 Read 两阶段对执行内存的使用<br>Shuffle Write：若在 map 端选择普通的排序方式，会采用 ExternalSorter 进行外排，在内存中存储数据时主要占用堆内执行空间。若在 map 端选择 Tungsten 的排序方式，则采用 ShuffleExternalSorter 直接对以序列化形式存储的数据排序，在内存中存储数据时可以占用堆外或堆内执行空间，取决于用户是否开启了堆外内存以及堆外执行内存是否足够。<br>Shuffle Read：在对 reduce 端的数据进行聚合时，要将数据交给 Aggregator 处理，在内存中存储数据时占用堆内执行空间。如果需要进行最终结果排序，则要将再次将数据交给 ExternalSorter 处理，占用堆内执行空间。</p>
<h2 id="BlockManager-在-spark-中扮演的角色"><a href="#BlockManager-在-spark-中扮演的角色" class="headerlink" title="BlockManager 在 spark 中扮演的角色"></a>BlockManager 在 spark 中扮演的角色</h2><p>spark shuffle 的过程总用到了 BlockManager 作为数据的中转站<br>spark broadcast 调度 task 到多个 executor 的时候， broadCast 底层使用的数据存储层<br>如果我们对一个 rdd 进行了cache, cacheManager 也是把数据放在了 blockmanager 中， 截断了计算链依赖， 后续task 运行的时候可以直接从 cacheManager 中获取到 cacherdd ，不用再从头计算。</p>
<h2 id="Block和partition的关系"><a href="#Block和partition的关系" class="headerlink" title="Block和partition的关系"></a>Block和partition的关系</h2><p>RDD 的运算是基于 partition， 每个 task 代表一个 分区上一个 stage 内的运算闭包， task 被分别调度到 多个 executor上去运行， 那么是在哪里变成了 Block 呢， 我们以 spark 2.11 源码为准， 看看这个转变过程，一个 RDD 调度到 executor 上会运行调用 getOrCompute方法。<br>如果 Block 在 BlockManager 中存在， 就会从 BlockManager 中获取，如果不存在， 就进行计算这个Block, 然后在 BlockManager 中进行存储持久化， 方便下次使用。</p>
<p>首先根据RDD id和partition index构造出block id (rdd_xx_xx)，接着从BlockManager中取出相应的block。</p>
<blockquote>
<p>如果该block存在，表示此RDD在之前已经被计算过和存储在BlockManager中，因此取出即可，无需再重新计算。<br>如果该block不存在则需要调用RDD的computeOrReadCheckpoint()函数计算出新的block，并将其存储到BlockManager中。</p>
</blockquote>
<p>需要注意的是block的计算和存储是阻塞的，若另一线程也需要用到此block则需等到该线程block的loading结束。</p>
<p>获取的时候是先从本地的 BlockManager 中获取， 如果本地没有， 然后再 从 remote 获取， 先从 driver 上获取到元数据 Block的位置， 然后去到真正的节点上fetch。<br>如果没有，就进行计算，然后根据存储级别，存储到计算节点本地的BlockManager 的内存或磁盘中，这样RDD的transformation、action就和block数据建立了联系，虽然抽象上我们的操作是在partition层面上进行的，但是partition最终还是被映射成为block，因此实际上我们的所有操作都是对block的处理和存取。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://s4.ax1x.com/2022/01/22/7WOYV0.png" alt="DeaL 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag"># 云计算</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/03/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="prev" title="计算几何">
      <i class="fa fa-chevron-left"></i> 计算几何
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/18/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="next" title="组成原理">
      组成原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="nav-number">1.</span> <span class="nav-text">分布式系统模型和关键技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E4%B9%8B%E4%B8%8A%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E8%AE%A1%E7%AE%97"><span class="nav-number">1.1.</span> <span class="nav-text">互联网之上的可扩展计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%8C%83%E5%BC%8F%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.1.</span> <span class="nav-text">计算范式间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HPC%E5%92%8CHTC%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81%E9%81%B5%E4%BB%8E%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.1.2.</span> <span class="nav-text">HPC和HTC系统需要遵从的设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E8%AE%A1%E7%AE%97%E8%B6%8B%E5%8A%BF%E5%92%8C%E6%96%B0%E7%9A%84%E8%8C%83%E5%BC%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">可扩展性计算趋势和新的范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E8%81%94%E7%BD%91%E5%92%8CCPS"><span class="nav-number">1.1.4.</span> <span class="nav-text">物联网和CPS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="nav-number">1.2.</span> <span class="nav-text">并行与分布式相关技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B8CPU%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">多核CPU和多线程技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%92%8C%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1GPU%E8%AE%A1%E7%AE%97"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">大规模和超大规模GPU计算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%9F%9F%E4%BA%92%E8%BF%9E"><span class="nav-number">1.2.2.</span> <span class="nav-text">系统区域互连</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.2.3.</span> <span class="nav-text">虚拟机和虚拟化中间件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E4%BA%91%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">分布式和云计算系统模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97"><span class="nav-number">1.3.1.</span> <span class="nav-text">网格计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C%EF%BC%88P2P%EF%BC%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">对等网络（P2P）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97"><span class="nav-number">1.3.3.</span> <span class="nav-text">云计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%92%8C%E4%BA%91%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83"><span class="nav-number">1.4.</span> <span class="nav-text">分布式系统和云计算软件环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">分布式操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%B2%E6%9C%89%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">已有并行和分布式编程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88SOA%EF%BC%89"><span class="nav-number">1.4.3.</span> <span class="nav-text">面向服务的体系结构（SOA）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-number">1.4.4.</span> <span class="nav-text">分布式和云计算的可扩展性:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E9%9B%86%E7%BE%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">虚拟机和集群与数据中心虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%B1%82%E6%AC%A1"><span class="nav-number">2.1.</span> <span class="nav-text">虚拟化的实现层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7"><span class="nav-number">2.1.2.</span> <span class="nav-text">挂起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9B%E5%BA%94%EF%BC%88%E6%81%A2%E5%A4%8D%EF%BC%89"><span class="nav-number">2.1.3.</span> <span class="nav-text">供应（恢复）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%BF%81%E7%A7%BB"><span class="nav-number">2.1.4.</span> <span class="nav-text">动态迁移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="nav-number">2.1.5.</span> <span class="nav-text">虚拟化的层级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">硬件级虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E9%9C%80%E6%B1%82"><span class="nav-number">2.2.1.</span> <span class="nav-text">设计需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">硬件级虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">硬件虚拟化的两种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BF%BB%E8%AF%91"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">全虚拟化的二进制翻译</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">操作系统级的虚拟化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E3%80%81%E5%86%85%E5%AD%98%E5%92%8CI-O%E8%AE%BE%E5%A4%87%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">CPU、内存和I&#x2F;O设备的虚拟化方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">2.4.0.1.</span> <span class="nav-text">CPU虚拟化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">2.4.0.2.</span> <span class="nav-text">内存虚拟化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">2.4.0.3.</span> <span class="nav-text">多核处理器的虚拟化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E9%9B%86%E7%BE%A4%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">虚拟集群和资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%99%9A%E6%8B%9F%E9%9B%86%E7%BE%A4"><span class="nav-number">2.5.1.</span> <span class="nav-text">物理集群与虚拟集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E5%92%8C%E6%9C%89%E6%95%88%E8%B0%83%E5%BA%A6"><span class="nav-number">2.5.2.</span> <span class="nav-text">快速部署和有效调度:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8"><span class="nav-number">2.5.3.</span> <span class="nav-text">高性能虚拟存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E8%BF%81%E7%A7%BB%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%B8%8E%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="nav-number">2.5.4.</span> <span class="nav-text">在线迁移虚拟机的步骤与性能影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E9%9B%86%E7%BE%A4%E5%85%B1%E6%9C%89%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">2.5.5.</span> <span class="nav-text">管理虚拟集群共有四种方式:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="nav-number">2.5.6.</span> <span class="nav-text">内存、文件与网络资源的迁移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2"><span class="nav-number">2.5.7.</span> <span class="nav-text">容器集群的动态部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">2.6.</span> <span class="nav-text">数据中心的自动化与虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%88%E5%B9%B6"><span class="nav-number">2.6.1.</span> <span class="nav-text">数据中心服务器合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.2.</span> <span class="nav-text">虚拟存储管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8F%AF%E4%BF%A1%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.3.</span> <span class="nav-text">虚拟化数据中心的可信管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%91%E5%B9%B3%E5%8F%B0%E3%80%81%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E4%BA%91%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">云平台、面向服务的体系结构和云编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="nav-number">3.1.</span> <span class="nav-text">服务模型和目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">云计算服务模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">3.1.2.</span> <span class="nav-text">云计算平台的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="nav-number">3.1.3.</span> <span class="nav-text">云计算平台的设计目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E6%9C%89%E4%BA%91%E3%80%81%E7%A7%81%E6%9C%89%E4%BA%91%E5%92%8C%E6%B7%B7%E5%90%88%E4%BA%91"><span class="nav-number">3.2.</span> <span class="nav-text">公有云、私有云和混合云</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%8D%B3%E6%9C%8D%E5%8A%A1-IaaS"><span class="nav-number">3.3.</span> <span class="nav-text">基础设施即服务(IaaS)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E5%8F%B0%E5%8D%B3%E6%9C%8D%E5%8A%A1-PaaS"><span class="nav-number">3.4.</span> <span class="nav-text">平台即服务 (PaaS)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1-SaaS"><span class="nav-number">3.5.</span> <span class="nav-text">软件即服务 (SaaS)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E6%9C%89%E4%BA%91%E5%B9%B3%E5%8F%B0%EF%BC%9AGAE%E3%80%81AWS%E5%92%8CAzure"><span class="nav-number">3.6.</span> <span class="nav-text">公有云平台：GAE、AWS和Azure</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%B7%E6%AD%8C%E5%BA%94%E7%94%A8%E5%BC%95%E6%93%8E%EF%BC%88GAE%EF%BC%89"><span class="nav-number">3.6.1.</span> <span class="nav-text">谷歌应用引擎（GAE）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E8%BD%AF%E7%9A%84Windows-Azure"><span class="nav-number">3.6.2.</span> <span class="nav-text">微软的Windows Azure</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%91%E5%B9%B3%E5%8F%B0%E7%AE%A1%E7%90%86"><span class="nav-number">3.7.</span> <span class="nav-text">云平台管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%9A%84%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.7.1.</span> <span class="nav-text">扩展的云计算服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%91%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.7.2.</span> <span class="nav-text">云成员类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.7.3.</span> <span class="nav-text">运行时支持服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.4.</span> <span class="nav-text">资源调度方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%B4%9F%E8%BD%BD%E9%A2%84%E6%B5%8B%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.4.1.</span> <span class="nav-text">基于负载预测的资源分配方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.4.2.</span> <span class="nav-text">基于阈值的资源分配方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%92%E9%98%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.4.3.</span> <span class="nav-text">基于排队模型的资源分配方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.4.4.</span> <span class="nav-text">基于反馈控制的资源分配方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E8%B5%84%E6%BA%90"><span class="nav-number">3.7.5.</span> <span class="nav-text">分布式存储资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.7.5.1.</span> <span class="nav-text">虚拟机模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86"><span class="nav-number">3.7.5.2.</span> <span class="nav-text">分布式虚拟机管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%91%E5%AE%89%E5%85%A8%E4%B8%8E%E4%BF%A1%E4%BB%BB%E7%AE%A1%E7%90%86"><span class="nav-number">3.8.</span> <span class="nav-text">云安全与信任管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98"><span class="nav-number">3.8.1.</span> <span class="nav-text">虚拟机的安全挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A5%E4%BE%B5-%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="nav-number">3.8.2.</span> <span class="nav-text">分布式入侵&#x2F;异常检测</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">面向服务的分布式体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88SOA%EF%BC%89-1"><span class="nav-number">4.1.</span> <span class="nav-text">面向服务的体系结构（SOA）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.2.</span> <span class="nav-text">Web服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E6%88%90%E7%9B%AE%E5%89%8DWeb%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="nav-number">4.2.1.</span> <span class="nav-text">组成目前Web服务核心的技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WS-I%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="nav-number">4.2.2.</span> <span class="nav-text">WS-I协议栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%81%E4%B8%9A%E5%A4%9A%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.</span> <span class="nav-text">企业多层体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E6%A0%BC%E6%9C%8D%E5%8A%A1%E5%92%8COGSA"><span class="nav-number">4.4.</span> <span class="nav-text">网格服务和OGSA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OGSA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="nav-number">4.4.1.</span> <span class="nav-text">OGSA体系结构服务：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web%E6%9C%8D%E5%8A%A1%E8%B5%84%E6%BA%90%E6%A1%86%E6%9E%B6%EF%BC%88WSRF%EF%BC%89"><span class="nav-number">4.4.2.</span> <span class="nav-text">Web服务资源框架（WSRF）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#REST"><span class="nav-number">4.5.</span> <span class="nav-text">REST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E4%B9%89Web"><span class="nav-number">4.6.</span> <span class="nav-text">语义Web</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">4.7.</span> <span class="nav-text">面向服务的体系结构中的工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.7.1.</span> <span class="nav-text">工作流的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%A7%84%E8%8C%83"><span class="nav-number">4.7.2.</span> <span class="nav-text">工作流体系结构和规范</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%91%E7%BC%96%E7%A8%8B-MapReduce"><span class="nav-number">5.</span> <span class="nav-text">云编程 MapReduce</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">并行和分布式编程范式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-number">5.1.1.</span> <span class="nav-text">并行和分布式编程范式需要考虑的因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%9A%84%E5%8A%A8%E6%9C%BA"><span class="nav-number">5.1.2.</span> <span class="nav-text">设计并行和分布式编程范式的动机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce%E3%80%81Twister%E5%92%8C%E8%BF%AD%E4%BB%A3MapReduce"><span class="nav-number">5.2.</span> <span class="nav-text">MapReduce、Twister和迭代MapReduce</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MapReduce%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="nav-number">5.2.1.</span> <span class="nav-text">MapReduce的形式化定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapReduce%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">5.2.2.</span> <span class="nav-text">MapReduce逻辑数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapReduce%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE%E5%92%8C%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">5.2.3.</span> <span class="nav-text">MapReduce真实数据和控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97-%E6%95%B0%E6%8D%AE%E5%AF%86%E5%88%87%E5%BA%A6"><span class="nav-number">5.2.4.</span> <span class="nav-text">计算-数据密切度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Twister%E5%92%8C%E8%BF%AD%E4%BB%A3MapReduce"><span class="nav-number">5.2.5.</span> <span class="nav-text">Twister和迭代MapReduce</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Apache%E7%9A%84Hadoop%E8%BD%AF%E4%BB%B6%E5%BA%93"><span class="nav-number">5.3.</span> <span class="nav-text">Apache的Hadoop软件库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hadoop-%E4%B8%8A%E7%9A%84MapReduce-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.1.</span> <span class="nav-text">Hadoop 上的MapReduce 体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8Hadoop%E9%87%8C%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%BD%9C%E4%B8%9A"><span class="nav-number">5.3.2.</span> <span class="nav-text">在Hadoop里运行一个作业</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spark"><span class="nav-number">6.</span> <span class="nav-text">Spark</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spark%E4%B8%8EHadoop%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.</span> <span class="nav-text">Spark与Hadoop区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Resilient-Distributed-Dataset-%EF%BC%88RDD%EF%BC%89"><span class="nav-number">6.2.</span> <span class="nav-text">Resilient Distributed Dataset （RDD）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDD%E6%93%8D%E4%BD%9C"><span class="nav-number">6.3.</span> <span class="nav-text">RDD操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Transformation-%E9%87%87%E7%94%A8lazy%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.3.1.</span> <span class="nav-text">Transformation 采用lazy模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E7%AA%84%E4%BE%9D%E8%B5%96"><span class="nav-number">6.4.</span> <span class="nav-text">宽依赖和窄依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%84%E4%BE%9D%E8%B5%96%EF%BC%88Narrow-Dependencies-%EF%BC%89"><span class="nav-number">6.4.1.</span> <span class="nav-text">窄依赖（Narrow Dependencies ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%BD%E4%BE%9D%E8%B5%96%EF%BC%88Wide-Dependencies-%EF%BC%89"><span class="nav-number">6.4.2.</span> <span class="nav-text">宽依赖（Wide Dependencies ）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">6.5.</span> <span class="nav-text">存储内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDD-%E7%BC%93%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">6.5.1.</span> <span class="nav-text">RDD 缓存的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E5%92%8C%E8%90%BD%E7%9B%98"><span class="nav-number">6.5.2.</span> <span class="nav-text">淘汰和落盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">6.6.</span> <span class="nav-text">执行内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E9%97%B4%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">6.6.1.</span> <span class="nav-text">多任务间内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shuffle-%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="nav-number">6.6.2.</span> <span class="nav-text">Shuffle 的内存占用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockManager-%E5%9C%A8-spark-%E4%B8%AD%E6%89%AE%E6%BC%94%E7%9A%84%E8%A7%92%E8%89%B2"><span class="nav-number">6.7.</span> <span class="nav-text">BlockManager 在 spark 中扮演的角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Block%E5%92%8Cpartition%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.8.</span> <span class="nav-text">Block和partition的关系</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="DeaL"
      src="https://s4.ax1x.com/2022/01/21/72Iby8.jpg">
  <p class="site-author-name" itemprop="name">DeaL</p>
  <div class="site-description" itemprop="description">我说的每一句话，都是错的</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DeaL</span>
</div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'n1avRfMnMFekaY9HkDEah1gK-gzGzoHsz',
      appKey     : '8TdUTGPEfa4SXGnj2yiJUMPJ',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
