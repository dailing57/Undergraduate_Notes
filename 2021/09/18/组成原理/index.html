<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="运算器">
<meta property="og:type" content="article">
<meta property="og:title" content="组成原理">
<meta property="og:url" content="http://example.com/2021/09/18/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="DL&#39;s Blog">
<meta property="og:description" content="运算器">
<meta property="og:locale">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/41T5uV.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/41ToHU.png">
<meta property="og:image" content="c:/Users/daili/AppData/Roaming/Typora/typora-user-images/image-20210919081328258.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/417JK0.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/417aaF.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/4170PJ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/417hPH.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/417qZ8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/417jiQ.png">
<meta property="og:image" content="c:/Users/daili/AppData/Roaming/Typora/typora-user-images/image-20210919083757579.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/41LFdf.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/19/41LVJg.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/26/4yNO9H.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/26/4yUPUS.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/26/4yUkCQ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/09/26/4yUVvn.png">
<meta property="og:image" content="https://s1.ax1x.com/2021/12/10/ooUfL6.png">
<meta property="og:image" content="https://s1.ax1x.com/2021/12/11/oofTDU.png">
<meta property="og:image" content="https://s1.ax1x.com/2021/12/11/oof4g0.png">
<meta property="og:image" content="https://s1.ax1x.com/2021/12/11/oTnDDs.png">
<meta property="og:image" content="https://s1.ax1x.com/2021/12/11/oTK9OJ.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/11/oHARvd.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/11/oHAHPS.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/11/oHQBSP.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/11/oHQWYn.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/13/oLs2id.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/13/oLsqij.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/13/oL6FHS.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/13/oL6Vhj.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/13/oLTN28.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/05/oDTZDK.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/05/oDTC4J.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/05/oDTpEF.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/05/oDozHU.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/05/oDovuV.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/05/oDoD0O.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/05/oDo1mT.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/05/oDbkgs.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/06/ordZyq.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/06/orsI9U.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/06/oryG5V.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/06/or6yes.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/06/orTtTU.png">
<meta property="article:published_time" content="2021-09-18T08:59:40.000Z">
<meta property="article:modified_time" content="2021-12-13T03:48:21.791Z">
<meta property="article:author" content="Dai Ling">
<meta property="article:tag" content="组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/09/19/41T5uV.png">

<link rel="canonical" href="http://example.com/2021/09/18/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>组成原理 | DL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to DL's Blog!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/18/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/06/glJAZd.png">
      <meta itemprop="name" content="Dai Ling">
      <meta itemprop="description" content="记录碎片">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          组成原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-18 16:59:40" itemprop="dateCreated datePublished" datetime="2021-09-18T16:59:40+08:00">2021-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-13 11:48:21" itemprop="dateModified" datetime="2021-12-13T11:48:21+08:00">2021-12-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h1><span id="more"></span>

<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><h2 id="定点除法"><a href="#定点除法" class="headerlink" title="定点除法"></a>定点除法</h2><p>对定点小数要求： |被除数|＜|除数|</p>
<p>对定点整数要求： |被除数|＞|除数|</p>
<h3 id="原码恢复余数法"><a href="#原码恢复余数法" class="headerlink" title="原码恢复余数法"></a>原码恢复余数法</h3><p>①判溢出，要求|被除数|＜|除数|；</p>
<p>②符号位单独按两数符号的模2相加求得（异或）</p>
<p>③被除数减去除数；</p>
<p><strong>④若所得余数为正，表示够减，相应位上商为1， 余数左移一位(相当于除数右移)减去除数；若所 得余数为负，表示不够减，相应位上商为0，余 数加上除数(恢复余数)，再左移一位减去除数；</strong></p>
<p>⑤重复第④步，直到求得所要求的商的各位为止</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/41T5uV"><img src="https://z3.ax1x.com/2021/09/19/41T5uV.png" alt="41T5uV.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/41ToHU"><img src="https://z3.ax1x.com/2021/09/19/41ToHU.png" alt="41ToHU.png"></a><img src="C:\Users\daili\AppData\Roaming\Typora\typora-user-images\image-20210919081328258.png" alt="image-20210919081328258"></p>
<h3 id="原码不恢复余数法（加减交替法）"><a href="#原码不恢复余数法（加减交替法）" class="headerlink" title="原码不恢复余数法（加减交替法）"></a>原码不恢复余数法（加减交替法）</h3><p>① 判溢出，比较被除数和除数。若在定点小数运 算时，|被除数|＞|除数|，则除法将发生溢出， 不能进行除法运算。</p>
<p>② 符号位单独处理，商的符号由被除数和除数符 号的异或运算求得。</p>
<p>③ 用被除数和除数的数值部分进行运算，被除数 减去除数。</p>
<p><strong>④ 若所得余数为正，表示够减，相应位上商为1， 将余数左移一位后，减去除数； 若所得余数为负，表示不够减，相应位上商为0， 将余数左移一位后，加上除数。</strong></p>
<p>⑤ 重复第④步，直到求得所要求的商的各位 为止。如果最后一次所得余数仍为负，则需再 做一次加除数的操作，以得到正确的余数。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/417JK0"><img src="https://z3.ax1x.com/2021/09/19/417JK0.png" alt="417JK0.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/417aaF"><img src="https://z3.ax1x.com/2021/09/19/417aaF.png" alt="417aaF.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4170PJ"><img src="https://z3.ax1x.com/2021/09/19/4170PJ.png" alt="4170PJ.png"></a></p>
<hr>
<h3 id="原码不恢复余数法（整数）"><a href="#原码不恢复余数法（整数）" class="headerlink" title="原码不恢复余数法（整数）"></a>原码不恢复余数法（整数）</h3><p>因为2n位被除数除以n位除数，可以得到n位的商。 在整数除法中，为了得到n位整数商，被除数位 数的长度应该是除数位数长度的两倍，并且为了 使商不超过n位，要求被除数的<strong>高n位比除数（n 位）小</strong>，否则商将超过n位，即运算结果<strong>溢出</strong>。</p>
<p>如果被除数和除数的位数都为n位，则应在被除 数前面加上n个0，使被除数的长度扩展为2n后再 进行运算。</p>
<p>在小数除法中，也可以使被除数位数的长度为除 数位数长度的两倍。 </p>
<p>在字长为n的计算机中，称被除数采用双字长、 除数采用单字长的除法为<strong>双精度除法</strong>。相应地称 被除数和除数均采用单字长的除法为<strong>单精度除法。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/417hPH"><img src="https://z3.ax1x.com/2021/09/19/417hPH.png" alt="417hPH.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/417qZ8"><img src="https://z3.ax1x.com/2021/09/19/417qZ8.png" alt="417qZ8.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/417jiQ"><img src="https://z3.ax1x.com/2021/09/19/417jiQ.png" alt="417jiQ.png"></a></p>
<p><img src="C:\Users\daili\AppData\Roaming\Typora\typora-user-images\image-20210919083757579.png" alt="image-20210919083757579"></p>
<p>A寄存器：存放被除数和余数，最终结果是余数。</p>
<p>B寄存器：存放除数。</p>
<p>C寄存器：存放被除数和商，最终结果是商。</p>
<p>运算过程中寄存器A、C联合左移。  商的符号Cf：Cf＝Af⊕Bf </p>
<p>运算过程中用Ff控制上商。</p>
<p>Ff＝0，说明余数r≥0，商1，作－B操作， 即 B＋1。 </p>
<p>Ff＝1，说明余数r＜0，商0，作＋B操作。</p>
<p> 在实现定点小数和定点整数除法时，寄存器的分配使用略有不同。</p>
<h2 id="补码除法运算"><a href="#补码除法运算" class="headerlink" title="补码除法运算"></a>补码除法运算</h2><p>在补码除法运算中，参加运算的数均为补 码数，所得商也是补码形式，符号位参加 运算。</p>
<h3 id="补码不恢复余数除法"><a href="#补码不恢复余数除法" class="headerlink" title="补码不恢复余数除法"></a>补码不恢复余数除法</h3><p>进行补码除法运算应考虑的几个问题。</p>
<p>比较规则 —— 如何判别是否够减 </p>
<p>由于上商是根据比较被除数(或余数)与除 数的绝对值的大小确定的，所以需要解决 如何比较两个补码数的绝对值的大小，也 就是如何判别是否够减的问题。</p>
<h4 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h4><p>当x与y同号时，作[x]补－[y]补进行比较</p>
<p>若所得余数与除数同号，表示够减</p>
<p>若所得余数与除数异号，表示不够减</p>
<h4 id="上商算法"><a href="#上商算法" class="headerlink" title="上商算法"></a>上商算法</h4><p>由于是补码运算，所以：</p>
<p>当x与y同号时，商为正，够减时上商为1，不够减时上商为0</p>
<p>当x与y异号时，商为负，够减时上商为0，不够减时上商为1 </p>
<p> • 上商算法</p>
<p> • 每次加减所得的余数与除数同号时，上商为1</p>
<p> • 每次加减所得的余数与除数异号时，上商为0</p>
<h4 id="商的符号"><a href="#商的符号" class="headerlink" title="商的符号"></a>商的符号</h4><p>若x与y同号，商为正。</p>
<p> 第一次运算时作 [x]补－[y]补，因为除法要求 |x|＜|y|，所以所得余数R0必不够减，即R0与 [y]补异号，应上商为0，就是正商的符号“0” 。 </p>
<p>若x与y异号，商为负。</p>
<p>第一次运算时作 [x]补＋[y]补，因为除法要求 |x|＜|y|，所以所得余数R0必不够减，即R0与 [y]补同号，应上商为1，就是负商的符号“1” 。</p>
<p>① 当被除数[x]补与除数[y]补<strong>同号</strong>时，如果余数[r]补与[y]补<strong>同号</strong>，且上商为“<strong>1</strong>” ，则表示商溢出。 </p>
<p>② 当被除数[x]补与除数[y]补<strong>异号</strong>时，如果余数[r]补与[y]补<strong>异号</strong>，且上商为“<strong>0</strong>” ，则表示商溢出。</p>
<h4 id="求新余数算法"><a href="#求新余数算法" class="headerlink" title="求新余数算法"></a>求新余数算法</h4><p>每次加减所得的余数与除数同号时，将余数左 移一位，减去除数。</p>
<p>每次加减所得的余数与除数异号时，将余数左 移一位，加上除数。</p>
<h4 id="商的校正"><a href="#商的校正" class="headerlink" title="商的校正"></a>商的校正</h4><h5 id="末尾恒置1"><a href="#末尾恒置1" class="headerlink" title="末尾恒置1"></a>末尾恒置1</h5><h5 id="校正法"><a href="#校正法" class="headerlink" title="校正法"></a>校正法</h5><p>① 若在所要求的位数内<strong>能够除尽</strong>，则除数<strong>y</strong>为正时，商不必校正；y为负时，商加$2^{-n}$校正。</p>
<p>② 若在所要求的位数内<strong>不能除尽</strong>，则<strong>商</strong>为正时，不必校正；商为负时，则商加$2^{-n}$校正。</p>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/41LFdf"><img src="https://z3.ax1x.com/2021/09/19/41LFdf.png" alt="41LFdf.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/41LVJg"><img src="https://z3.ax1x.com/2021/09/19/41LVJg.png" alt="41LVJg.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4yNO9H"><img src="https://z3.ax1x.com/2021/09/26/4yNO9H.png" alt="4yNO9H.png"></a></p>
<h3 id="布斯除法"><a href="#布斯除法" class="headerlink" title="布斯除法"></a>布斯除法</h3><p>① 余数(初始为被除数)与除数同号，上商为1， 余数左移一位，减去除数；</p>
<p>​    余数(初始为被除数)与除数异号，上商为0， 余数左移一位，加上除数；</p>
<p>② 重复上述步骤，直到求得所需位数为止；</p>
<p>③ 将<strong>商符变反</strong>，若采用校正法，则对商校正。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4yUPUS"><img src="https://z3.ax1x.com/2021/09/26/4yUPUS.png" alt="4yUPUS.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4yUkCQ"><img src="https://z3.ax1x.com/2021/09/26/4yUkCQ.png" alt="4yUkCQ.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4yUVvn"><img src="https://z3.ax1x.com/2021/09/26/4yUVvn.png" alt="4yUVvn.png"></a></p>
<h1 id="浮点数四则运算"><a href="#浮点数四则运算" class="headerlink" title="浮点数四则运算"></a>浮点数四则运算</h1><h2 id="两个浮点数加减运算的步骤"><a href="#两个浮点数加减运算的步骤" class="headerlink" title="两个浮点数加减运算的步骤"></a>两个浮点数加减运算的步骤</h2><h3 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h3><p>把两数的小数点对齐，称为对阶。</p>
<p>两个浮点数的加减运算，首先必须对阶。 对阶的标志是使两数阶码相等。</p>
<p>对阶时，首先应求出两数阶码之差，即：</p>
<p>对阶的基本方法是：<strong>小阶向大阶看齐。</strong></p>
<h3 id="尾数求和"><a href="#尾数求和" class="headerlink" title="尾数求和"></a>尾数求和</h3><p>若求和，则将两数尾数直接相加。</p>
<p>若求差，则将对阶后的减数的尾数变补与被减 数的尾数相加。</p>
<h3 id="结果规格化"><a href="#结果规格化" class="headerlink" title="结果规格化"></a>结果规格化</h3><p>向左破坏规格化：尾数发生溢出。</p>
<p>向右破坏规格化：尾数未溢出，但不满足规格化 条件。</p>
<p>设浮点数尾数[S]原＝Sf.S1S2…Sn</p>
<p>如果尾数发生溢出，则为向左破坏规格化；</p>
<p>如果尾数未溢出，但S1＝0，则为向右破坏规格化。</p>
<p>设浮点数尾数[S]补＝Sf.S1S2…Sn</p>
<p>如果尾数发生溢出，则称为向左破坏规格化；</p>
<p>如尾数未溢出，但Sf⊕S1＝0，即Sf与S1相同，则为向右破坏规格化。</p>
<p><strong>在浮点运算中，通过规格化处理，溢出将不会 影响正确的运算。</strong></p>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>为减少对阶和向右规格化时，因尾数右移而造 成的误差，可进行舍入处理（即找到可以表示 的最接近的值）。</p>
<p>舍入的原则：<br>⑴ 误差不超过所允许的范围，一般要求不超 过最低位的1。<br>⑵ 误差应有正有负，不会产生积累误差。</p>
<h4 id="截断法"><a href="#截断法" class="headerlink" title="截断法"></a>截断法</h4><p>将丢掉的部分一律舍去，保留的部分不作任何 改变。<br>这种方法简单，但精度较低。<br>趋近0</p>
<h4 id="0舍1入法"><a href="#0舍1入法" class="headerlink" title="0舍1入法"></a>0舍1入法</h4><p>若右移时被丢掉数位的最高位为0，则舍去；<br>若右移时被丢掉数位的最高位为1，则将1加到 尾数的最低位。<br>这种方法精度较高，但在加1时，会产生进位， 使运算速度减慢。而且可能造成尾数溢出，需要再次右规。<br>趋近+∞ 或−∞  </p>
<h4 id="末位恒置1"><a href="#末位恒置1" class="headerlink" title="末位恒置1"></a>末位恒置1</h4><p>末位恒置1法也称冯·诺依曼舍入法。<br>尾数右移时，无论被丢掉的数位的最高位为0  还是为1，都将保留的尾数的最低位恒置为1。<br>优点：舍入处理不用做加法运算，方法简单、 速度快且不会有再次右规的可能，并且没有积 累误差，是常用的舍入方法。<br>趋近于+∞ 或−∞<br>缺点：可能会有较大的积累误差。因为从绝对 值来看，每次舍入都可能是增加的 </p>
<h4 id="查表舍入法"><a href="#查表舍入法" class="headerlink" title="查表舍入法"></a>查表舍入法</h4><p>根据尾数的低K位的代码值及被丢掉数位的最 高位值，按一定舍入规则，编制成舍入表，并 存入只读存储器。<br>当需要舍入操作时，以尾数低K位及被丢掉数 位的最高位作为ROM地址，通过查舍入表，得 到舍入后尾数低K位值。<br>实现一种舍入函数</p>
<h3 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h3><p><strong>浮点数溢出与否是由阶码的符号决定的</strong></p>
<p>为便于判断移码加/减运算的溢出情况，可采 用双符号位进行运算。<br>设移码的双符号位为sf1sf2，并规定初始时，  移码的一个符号位sf1恒为0，并参加运算</p>
<p>若运算结果的sf1为1，表示溢出。<br> sf1sf2＝10，结果上溢<br> sf1sf2＝11，结果下溢<br>若运算结果的sf1为0，表示无溢出。<br> sf1sf2＝00，结果为负<br> sf1sf2＝01，结果为正</p>
<h2 id="尾数运算"><a href="#尾数运算" class="headerlink" title="尾数运算"></a>尾数运算</h2><h3 id="浮点乘法尾数运算"><a href="#浮点乘法尾数运算" class="headerlink" title="浮点乘法尾数运算"></a>浮点乘法尾数运算</h3><p>在浮点乘法运算中，乘积的尾数是相乘的两个 浮点数的尾数之积，并按定点小数的乘法规则 进行运算。<br>浮点乘法尾数运算的运算步骤：</p>
<h4 id="检测被乘数和乘数的尾数是否为0"><a href="#检测被乘数和乘数的尾数是否为0" class="headerlink" title="检测被乘数和乘数的尾数是否为0"></a>检测被乘数和乘数的尾数是否为0</h4><p>若有一 个为0，则乘积必然为0，不需再进行计算。只 有当两数皆不为0时，方可进行运算。 </p>
<h4 id="被乘数和乘数的尾数相乘"><a href="#被乘数和乘数的尾数相乘" class="headerlink" title="被乘数和乘数的尾数相乘"></a>被乘数和乘数的尾数相乘</h4><p>根据尾数采用的是原码表示还是补码表示，可采用任意一种相应的定点小数乘法完成运算。</p>
<h4 id="运算结果规格化"><a href="#运算结果规格化" class="headerlink" title="运算结果规格化"></a>运算结果规格化</h4><p>如果尾数采用补码表示，由于－1是规格化数，  而当两尾数均为－1时，由于(－1)×(－1)＝1， 因此需要对运算结果进行一次右规，如果在右规调整阶码时，出现阶码上溢，则表示浮点数上溢， 应转入溢出中断处理。 </p>
<h4 id="舍入处理"><a href="#舍入处理" class="headerlink" title="舍入处理"></a>舍入处理</h4><p>两个n位（除符号位外）尾数相乘，乘积为2n位。 如果只需要取乘积的高n位，则需要对乘法运算  结果进行舍入处理。</p>
<h3 id="浮点除法尾数运算"><a href="#浮点除法尾数运算" class="headerlink" title="浮点除法尾数运算"></a>浮点除法尾数运算</h3><h4 id="检测被除数和除数的尾数是否为0"><a href="#检测被除数和除数的尾数是否为0" class="headerlink" title="检测被除数和除数的尾数是否为0"></a>检测被除数和除数的尾数是否为0</h4><p>若被除 数为0，商必然为0，不需再进行计算；若除数 为0，则商为无穷大，转入除数0中断处理。只 有当两数皆不为0时，方可进行运算。（IEEE754标准可以处理这种情况）  </p>
<h4 id="被除数和除数的尾数相除"><a href="#被除数和除数的尾数相除" class="headerlink" title="被除数和除数的尾数相除"></a>被除数和除数的尾数相除</h4><p>根据尾数采用 的是原码表示还是补码表示，可采用任意一种 相应的定点小数除法完成运算。</p>
<h4 id="运算结果规格化-1"><a href="#运算结果规格化-1" class="headerlink" title="运算结果规格化"></a>运算结果规格化</h4><p>如果商的绝对值小于1/2， 则需对运算结果进行左规。如果在左规调整阶 码时，出现阶码下溢，则应将运算结果作机器 零处理。</p>
<h1 id="控制系统与CPU"><a href="#控制系统与CPU" class="headerlink" title="控制系统与CPU"></a>控制系统与CPU</h1><p>控制器是计算机的指挥和控制中心，由它把计算机的运算器、存储器、I/O设备等联系成一个有机的系统，并根据各部件具体要求，适时地发出各种控制命令，控制计算机各部件自动、协调地进行工作。</p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><h3 id="指令执行基本步骤"><a href="#指令执行基本步骤" class="headerlink" title="指令执行基本步骤"></a>指令执行基本步骤</h3><ol>
<li><p>取指令<br> 根据指令地址（由PC提供），从存储器中取出所要执行的指令。</p>
</li>
<li><p>分析指令</p>
</li>
</ol>
<p>  ① 对取出的指令进行译码分析。确定指令应完成的操作，产生相应操作的控制电位，参与形成该指令功能所需要的<strong>全部控制命令</strong>（<strong>微操作控制信号</strong>）。<br>  ② 根据寻址方式的分析和指令功能要求，形成<strong>操作数的有效地址</strong>，并按此地址取出操作数据（运算型指令）或形成转移地址(转移类指令)，以实现程序转移。</p>
<ol start="3">
<li><p>执行指令</p>
<p>根据指令分析所产生的操作控制信号和形成的有效地址，按一定的算法形成指令<strong>操作控制序列</strong>，控制有关部件完成指令规定的功能。<br>一条指令执行结束，若没有异常情况和特殊请求，则按程序顺序，再去取出并执行下一条指令。</p>
</li>
</ol>
<h3 id="控制器的任务"><a href="#控制器的任务" class="headerlink" title="控制器的任务"></a>控制器的任务</h3><p>按<strong>取指令、分析指令、执行指令</strong>这样的步骤进行周而复始的控制过程，直到完成程序所规定的任务并停机为止。</p>
<h3 id="控制器的基本功能"><a href="#控制器的基本功能" class="headerlink" title="控制器的基本功能"></a>控制器的基本功能</h3><h4 id="控制指令正确执行"><a href="#控制指令正确执行" class="headerlink" title="控制指令正确执行"></a>控制指令正确执行</h4><h5 id="指令流出控制"><a href="#指令流出控制" class="headerlink" title="指令流出控制"></a>指令流出控制</h5><p>(PC)-&gt;MAR,Read</p>
<p>(MDR)-&gt;IR</p>
<p>(PC)+1-&gt;PC</p>
<h5 id="分析指令和执行指令的控制"><a href="#分析指令和执行指令的控制" class="headerlink" title="分析指令和执行指令的控制"></a>分析指令和执行指令的控制</h5><p>IR中的指令经<strong>指令译码器（ID）</strong>译码分析，确定操作性质，判明寻址方式并形成操作数的有效地址。</p>
<p>控制器根据分析结果和形成的有效地址产生相应的<strong>操作控制信号序列</strong>。</p>
<h5 id="指令流向控制"><a href="#指令流向控制" class="headerlink" title="指令流向控制"></a>指令流向控制</h5><p>指令流向控制即下条指令地址的形成控制</p>
<p>① 按指令序列顺序执行时，通过PC自动增量形成下条指令的地址。<br>② 当需要改变指令流向时，需改变程序计数器PC中的内容。</p>
<p>转移指令的执行：把形成的转向地址送入PC；<br>转子指令的执行：把子程序入口地址送入PC；<br>中断处理：将中断服务程序入口地址送入PC。<br>为了正确返回，转子和中断还需保留PC被改变之前的内容(即返回地址)。</p>
<h4 id="控制程序和数据的输入及结果的输出"><a href="#控制程序和数据的输入及结果的输出" class="headerlink" title="控制程序和数据的输入及结果的输出"></a>控制程序和数据的输入及结果的输出</h4><p>为完成某项任务而编制的程序及所需数据，必须通过某些输入设备预先存放在存储器中，运算结果要用输出设备输出。所以<strong>必须由控制器统一指挥</strong>，完成程序和数据的输入及结果的输出。</p>
<h4 id="异常情况和特殊请求处理"><a href="#异常情况和特殊请求处理" class="headerlink" title="异常情况和特殊请求处理"></a>异常情况和特殊请求处理</h4><p>控制器必须具有检测和处理这些异常情况和特殊请求的功能。</p>
<h4 id="指令部件"><a href="#指令部件" class="headerlink" title="指令部件"></a>指令部件</h4><p>PC：</p>
<p><strong>由于PC可以指向主存中任一单元的地址，因此它的位数应能表示主存的最大容量并与主存地址寄存器MAR的位数相同。</strong></p>
<p>IR：</p>
<p>指令寄存器用于存放当前正在执行的指令。<br>当指令从主存取出后，经MDR传送到指令寄存器中，以便实现对一条指令执行的全部过程的控制</p>
<p>ID：</p>
<p>对指令寄存器中的指令<strong>操作码进行译码分析</strong>，产生相应操作的控制电位，提供给微操作控制信号形成部件。<strong>对寻址方式字段进行译码分析</strong></p>
<p>地址形成部件：</p>
<p>根据机器所规定的各种寻址方式，形成操作数有效地址。</p>
<h4 id="时序控制部件"><a href="#时序控制部件" class="headerlink" title="时序控制部件"></a>时序控制部件</h4><p>用于产生一系列时序信号，为各个微操作定时，以保证各个微操作的执行顺序。</p>
<p>微操作：机器最简单的基本操作</p>
<h4 id="微操作控制信号形成部件"><a href="#微操作控制信号形成部件" class="headerlink" title="微操作控制信号形成部件"></a>微操作控制信号形成部件</h4><p>微操作控制信号形成部件：根据指令部件提供的操作控制电位、时序部件所提供的各种时序信号以及有关的状态条件，产生机器所需要的各种微操作控制信号。</p>
<h4 id="中断机构"><a href="#中断机构" class="headerlink" title="中断机构"></a>中断机构</h4><h4 id="程序状态寄存器PSR"><a href="#程序状态寄存器PSR" class="headerlink" title="程序状态寄存器PSR"></a>程序状态寄存器PSR</h4><p>它所存放的内容称为PSW</p>
<h4 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h4><p>实现人机之间的通信联系</p>
<h3 id="控制器的组成方式"><a href="#控制器的组成方式" class="headerlink" title="控制器的组成方式"></a>控制器的组成方式</h3><p>控制器的组成方式主要是指<strong>微操作控制信号形成部件采用何种组成方式产生微操作控制信号</strong></p>
<p>组合、存储、结合（PLA）</p>
<h2 id="控制器的控制方式与时序系统"><a href="#控制器的控制方式与时序系统" class="headerlink" title="控制器的控制方式与时序系统"></a>控制器的控制方式与时序系统</h2><p><strong>如何在时间上对各种微操作信号加以控制</strong>。</p>
<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p>任何指令的运行或指令中各个微操作的执行，均由确定的<strong>具有统一基准时标的时序信号所控制</strong>。</p>
<p>典型的同步控制方式：<br><strong>以微操作序列最长的指令和执行时间最长的微操作为标准</strong>，</p>
<h4 id="1-采用中央控制与局部控制相结合的方法"><a href="#1-采用中央控制与局部控制相结合的方法" class="headerlink" title="(1) 采用中央控制与局部控制相结合的方法"></a>(1) 采用中央控制与局部控制相结合的方法</h4><p><strong>中央控制</strong>：统一节拍的控制<br>根据大多数指令的微操作序列的情况，设置一个统一的节拍数，使之大多数指令均能在统一的节拍内完成。</p>
<p><strong>局部控制</strong>：在延长节拍内的控制<br>对于少数在统一节拍内不能完成的指令，采用延长节拍或增加节拍数，使之在延长节拍内完成，执行完毕再返回中央控制。</p>
<h4 id="2-采用不同的机器周期和延长节拍的方法"><a href="#2-采用不同的机器周期和延长节拍的方法" class="headerlink" title="(2) 采用不同的机器周期和延长节拍的方法"></a>(2) 采用不同的机器周期和延长节拍的方法</h4><p><strong>把一条指令执行过程划分为若干机器周期</strong>，如取指、取数、执行等周期。根据所执行指令的不同需要，选取不同的机器周期数。在节拍安排上，<strong>每个周期划分为固定的节拍，每个节拍都可根据需要延长一个节拍</strong>。</p>
<h4 id="3-采用分散节拍的方法"><a href="#3-采用分散节拍的方法" class="headerlink" title="(3) 采用分散节拍的方法"></a>(3) 采用分散节拍的方法</h4><p><strong>分散节拍：运行不同指令时，需要多少节拍，时序部件就发生多少节拍。</strong><br>这种方法可完全避免节拍轮空，是提高指令运行速度的有效方法，但这种方法使时序部件复杂化。同时还不能解决节拍内那些简单的微操作因等待所浪费的时间。</p>
<h3 id="异步控制"><a href="#异步控制" class="headerlink" title="异步控制"></a>异步控制</h3><p>没有统一的同步信号，<strong>采用问答方式进行时序协调</strong>，将前一操作的回答信号作为下一操作的启动信号。<br>异步控制方式不仅要区分不同指令对应的微操作序列的长短，而且要区分其中每个微操作的繁简，每条指令、每个微操作需要多少时间就占用多少时间。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ooUfL6"><img src="https://s1.ax1x.com/2021/12/10/ooUfL6.png" alt="ooUfL6.png"></a></p>
<h3 id="联合控制"><a href="#联合控制" class="headerlink" title="联合控制"></a>联合控制</h3><p>联合控制是将同步控制和异步控制相结合。</p>
<p>在功能部件内部采用同步方式或以同步方式为主的控制方式<br>在功能部件之间采用异步方式<br>通常对可以统一的微操作采用同步控制，对难以统一的微操作采用异步控制。</p>
<h3 id="同步异步时序的衔接关系"><a href="#同步异步时序的衔接关系" class="headerlink" title="同步异步时序的衔接关系"></a>同步异步时序的衔接关系</h3><p>当CPU要访问主存时，在发读信号READ同时发<strong>“等待”信号</strong>，等待信号使时序由同步转异步操作，并<strong>冻结同步时序</strong>，使节拍间的相位关系不再发生变化，直到存储器按自己速度操作结束，并向CPU发回答信号MOC才<strong>解除对同步时序的冻结</strong>，机器回到同步时序按原时序关系继续运行。</p>
<h2 id="时序系统"><a href="#时序系统" class="headerlink" title="时序系统"></a>时序系统</h2><p>时序系统是控制器的心脏，由它为指令的执行提供各种定时信号。通常，<strong>设计时序系统主要是针对同步控制方式的。</strong></p>
<h3 id="指令周期与机器周期"><a href="#指令周期与机器周期" class="headerlink" title="指令周期与机器周期"></a>指令周期与机器周期</h3><p><strong>指令周期</strong>：从取指令、分析指令到执行完一条指令所需的全部时间。</p>
<p><strong>机器周期（CPU周期）</strong>：指令周期中的某一工作阶段所需的时间。在指令执行过程中，各机器周期相对独立。</p>
<p><strong>一般机器的CPU周期有取指周期、取数周期、执行周期，中断周期等。</strong></p>
<p><strong>节拍</strong></p>
<p>把<strong>一个机器周期等分成若干个时间区间</strong>，每一时间区间称为一个节拍。<br>一个节拍对应一个电位信号，<strong>控制一个或几个微操作的执行</strong>。</p>
<p><strong>一个节拍电位信号的宽度取决于CPU完成一个基本操作的时间。</strong> </p>
<p><strong>脉冲：一个节拍内设置的一个或几个工作脉冲。</strong></p>
<p>常见的设计是在<strong>每个节拍的末尾发一次工作脉冲</strong>，<strong>脉冲前沿可用来打入运算结果（或传送），脉冲后沿则实现周期的切换。</strong></p>
<p>外频：超频超的就是这个，主板上石英晶体振荡器，基准时钟频率<br>内存频率：依赖于外频，DDR，DDR2<br>前端总线FSB：CPU与北桥之间的传输速度，QDR（Quad Date Rate）技术（4倍并发）<br>双通道内存：在北桥芯片有两个内存控制器<br>主频：外频*倍频<br>倍频：一般主板锁定<br>南桥芯片和北桥芯片：前者接口，如声卡等；后者内存、显卡等</p>
<h2 id="CPU总体结构"><a href="#CPU总体结构" class="headerlink" title="CPU总体结构"></a>CPU总体结构</h2><p>CPU即中央处理器，它包含运算器和控制器两个部分。其功能为：<br>⑴ <strong>程序控制</strong>：标准程序按所要求的次序正确执行。<br>⑵ <strong>操作控制</strong>：管理何产生每条指令所需的操作信号，送往有关部件，控制完成指令规定的操作。<br>⑶ <strong>时序控制</strong>：对各种操作实施时间上的定时，使计算机有条不紊地工作。<br>⑷ <strong>数据加工</strong>：对数据进行算逻运算处理。</p>
<h3 id="寄存器的设置"><a href="#寄存器的设置" class="headerlink" title="寄存器的设置"></a>寄存器的设置</h3><p>不同计算机的CPU结构存在差别，但在CPU中一般都设置下列寄存器：<br>(1)指令寄存器 IR<br>(2)程序计数器 PC<br>(3)累加寄存器 AC<br>(4)程序状态寄存器 PSR<br>(5)地址寄存器 MAR<br>(6)数据缓冲寄存器 MDR(或MBR)</p>
<h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><p>在CPU内部，数据通路通常是指运算器与寄存器之间的信息传输通道。（总线）</p>
<p>单总线</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oofTDU"><img src="https://s1.ax1x.com/2021/12/11/oofTDU.png" alt="oofTDU.png"></a></p>
<p>双总线</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oof4g0"><img src="https://s1.ax1x.com/2021/12/11/oof4g0.png" alt="oof4g0.png"></a></p>
<h3 id="指令流程分析"><a href="#指令流程分析" class="headerlink" title="指令流程分析"></a>指令流程分析</h3><p>指令流程：指令的操作过程。</p>
<p>影响指令流程的因素：<br><strong>指令功能</strong><br><strong>寻址方式</strong><br><strong>数据通路</strong><br><strong>ALU的功能</strong><br><strong>指令执行的基本步骤等。</strong></p>
<p>例：指令</p>
<p>ADD (R1),R0</p>
<p>(PC)-&gt;MAR,Read,(PC)+1-&gt;Z</p>
<p>(Z)-&gt;PC</p>
<p>(M-&gt;MDR)-&gt;IR</p>
<p>(R1)-&gt;MAR,Read</p>
<p>(M-&gt;MDR)-&gt;Y</p>
<p>(Y)+(R0)-&gt;Z</p>
<p>(Z)-&gt;R0</p>
<h2 id="模型机的总体结构"><a href="#模型机的总体结构" class="headerlink" title="模型机的总体结构"></a>模型机的总体结构</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oTnDDs"><img src="https://s1.ax1x.com/2021/12/11/oTnDDs.png" alt="oTnDDs.png"></a></p>
<h3 id="模型机数据通路结构"><a href="#模型机数据通路结构" class="headerlink" title="模型机数据通路结构"></a>模型机数据通路结构</h3><p>字长：16位<br>① 内部总线：双总线结构<br>BUS1：输入总线， BUS2：输出总线<br>○：输出控制门信号，如MDR→BUS1<br>CP：输入控制信号，如CPY<br>② 系统总线：<br>地址总线：ABUS，数据总线：DBUS<br>I/O与主存共享总线，用 MREQ 控制访存；用IOREQ 控制访问I/O，<br>R/W=1，读， R/W=0，写</p>
<h3 id="模型机的ALU的功能"><a href="#模型机的ALU的功能" class="headerlink" title="模型机的ALU的功能"></a>模型机的ALU的功能</h3><p>由SN74181构成，在控制信号S3～S0及M、C0的控制下，可完成16种逻辑运算和16种算术运算。<br>M＝0：算术运算  M＝1：逻辑运算 </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oTK9OJ"><img src="https://s1.ax1x.com/2021/12/11/oTK9OJ.png" alt="oTK9OJ.png"></a></p>
<h2 id="微程序控制器原理"><a href="#微程序控制器原理" class="headerlink" title="微程序控制器原理"></a>微程序控制器原理</h2><p>微程序设计的实质<br>用程序设计的思想方法来组织操作控制逻辑，用规整的存储逻辑代替繁杂的组合逻辑。 </p>
<p><strong>相容</strong><br>指在同时或同一个CPU时钟单位（周期）内并行执行的微操作。<br><strong>不相容</strong>（互斥）<br>指不能同时或不能在同一个CPU时钟周期内并行执行的微操作。</p>
<h3 id="常用的微指令编译方法"><a href="#常用的微指令编译方法" class="headerlink" title="常用的微指令编译方法"></a>常用的微指令编译方法</h3><p><strong>直接控制法</strong>（不译法）<br>微指令操作控制字段的每一位都直接表示一个微命令，该位为“1”，表示执行这个微命令，为“0”表示不执行该微命令。由于这种方法不需译码，所以也称不译法。</p>
<p><strong>字段直接编码法</strong></p>
<p>将微指令操作控制字段划分为若干个子字段，每个子字段的所有微命令进行统一编码。因此在这种方法中，不同的子字段的不同编码，表示不同的微命令。</p>
<p><strong>子字段的划分原则</strong></p>
<p>① <strong>把互斥的微命令（即不允许同时出现的微命令）划分在同一字段内</strong>，相容的微命令（即允许同时出现的微命令）划分在不同字段内。<br>例：各Ri→BUS1是互斥的，可以划分在同一字段；RS→BUS1和CPRS是相容的，应划分在不同字段。<br>② 字段的划分应<strong>与数据通路结构相适应</strong>。<br>③ 一般每个子字段应<strong>留出一个状态</strong>，表示本字段不发任何微命令。<br>④ 每个子字段所定义的微命令数不宜太多，否则将使微命令译码复杂。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oHARvd"><img src="https://s4.ax1x.com/2021/12/11/oHARvd.png" alt="oHARvd.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oHAHPS"><img src="https://s4.ax1x.com/2021/12/11/oHAHPS.png" alt="oHAHPS.png"></a></p>
<h3 id="微程序的顺序控制方式"><a href="#微程序的顺序控制方式" class="headerlink" title="微程序的顺序控制方式"></a>微程序的顺序控制方式</h3><p>微程序的初始微地址（微程序的入口地址）：指令所对应微程序的第一条微指令所在控制存储器单元的地址。<br>现行微指令：执行微程序过程中，当前正在执行的微指令。<br>现行微地址：现行微指令所在控制存储器单元的地址。<br>后继微指令：现行微指令执行完毕后，下一条要执行的微指令。<br>后继微地址：后继微指令所在控存单元的地址。</p>
<p>1．初始微地址的形成</p>
<p>“取指令”微程序（通常由一条或几条微指令组成）是公用的，一般安排在从0号控存单元或其它特定的控存单元开始。</p>
<p>(1) 一级功能转移</p>
<p>根据指令操作码，直接转移到相应微程序的入口，即指令操作码直接参与形成微程序的入口地址。</p>
<p>(2) 二级功能转移</p>
<p>先按指令类型标志转移，以区分出是哪一类指令。规定每类指令中位置和位数是固定的，在第二级按操作码区分出具体是哪条指令，转移到相应微程序入口。</p>
<p>2．后继微地址的形成</p>
<p>找到初始微地址后，开始执行相应的微程序。每条微指令执行完毕，都要根据要求形成后继微地址，以保证微程序的正常执行。<br>后继微地址的形成方法对微程序编制的灵活性影响很大。<br>后继微地址的形成方法主要有两种基本类型：<strong>增量方式</strong>和<strong>断定方式</strong>。</p>
<p>(1) 增量方式</p>
<p>增量方式：当微程序按地址递增顺序一条条地执行微指令时，后继微地址是现行微地址加上一个增量（通常为1）。</p>
<p> (2)断定方式</p>
<p>断定方式：后继微地址可由设计者指定或由设计者指定的测试判定字段控制产生。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oHQBSP"><img src="https://s4.ax1x.com/2021/12/11/oHQBSP.png" alt="oHQBSP.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oHQWYn"><img src="https://s4.ax1x.com/2021/12/11/oHQWYn.png" alt="oHQWYn.png"></a></p>
<h2 id="MIPS数据通路"><a href="#MIPS数据通路" class="headerlink" title="MIPS数据通路"></a>MIPS数据通路</h2><h3 id="单周期"><a href="#单周期" class="headerlink" title="单周期"></a>单周期</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oLs2id"><img src="https://s4.ax1x.com/2021/12/13/oLs2id.png" alt="oLs2id.png"></a></p>
<h3 id="多周期"><a href="#多周期" class="headerlink" title="多周期"></a>多周期</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oLsqij"><img src="https://s4.ax1x.com/2021/12/13/oLsqij.png" alt="oLsqij.png"></a></p>
<h2 id="RISC-V数据通路"><a href="#RISC-V数据通路" class="headerlink" title="RISC-V数据通路"></a>RISC-V数据通路</h2><h3 id="单周期-1"><a href="#单周期-1" class="headerlink" title="单周期"></a>单周期</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oL6FHS"><img src="https://s4.ax1x.com/2021/12/13/oL6FHS.png" alt="oL6FHS.png"></a></p>
<h3 id="多周期-1"><a href="#多周期-1" class="headerlink" title="多周期"></a>多周期</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oL6Vhj"><img src="https://s4.ax1x.com/2021/12/13/oL6Vhj.png" alt="oL6Vhj.png"></a></p>
<h2 id="流水线处理技术"><a href="#流水线处理技术" class="headerlink" title="流水线处理技术"></a>流水线处理技术</h2><h3 id="指令的执行方式"><a href="#指令的执行方式" class="headerlink" title="指令的执行方式"></a>指令的执行方式</h3><p>前面所述的控制器同步、异步和联合控制三种控制方式是<strong>根据微操作序列的时序来划分的。</strong><br>根据各条<strong>指令之间的衔接关系</strong>指令的执行又可分为顺序、重叠、流水三种方式。<br>$$<br>T=\sum_{i=1}^{n}(t_{IF}+t_{ID}+t_{EX})<br>$$</p>
<h3 id="重叠方式"><a href="#重叠方式" class="headerlink" title="重叠方式"></a>重叠方式</h3><p>一次重叠：<br>$$<br>T=t_{IF}+nt_{ID}+(n-1)max(t_{IF},t_{EX})+t_{EX}<br>$$<br>二次重叠：<br>$$<br>T=t_{IF}+max(t_{IF},t_{ID})+(n-2)max(t_{IF},t_{ID},t_{EX})+max(t_{ID},t_{EX})+t_{EX}<br>$$<br>就是重叠的地方max</p>
<h2 id="流水方式"><a href="#流水方式" class="headerlink" title="流水方式"></a>流水方式</h2><p>在采用五段流水线对指令解释执行时，在一个时钟周期内，同时有五条指令分别在不同的功能部件上被解释。<br>流水线稳定工作后，<strong>每个时钟周期都有一条指令的执行结果从流水线流出</strong>。</p>
<p>流水线吞吐率：<br>$$<br>\frac {1}{\Delta t} (\Delta t是流水线时钟周期)<br>$$</p>
<h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><p>处理级别：操作部件级，指令级，处理机间</p>
<p>按功能：单功能，多功能</p>
<p>工作方式：静态，动态（允许在同一时间将不同的功能段组合成具有多功能的流水子集</p>
<p>结构：线性，非线性</p>
<h3 id="流水线的性能"><a href="#流水线的性能" class="headerlink" title="流水线的性能"></a>流水线的性能</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oLTN28"><img src="https://s4.ax1x.com/2021/12/13/oLTN28.png" alt="oLTN28.png"></a></p>
<h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>单位时间内流水线能完成的指令数<br>$$<br>T_P = \frac {n}{m\Delta t + (n-1)\Delta t}<br>$$</p>
<h4 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h4><p>串行用时：流水线用时<br>$$<br>S_P = \frac {T_S} {T_C} = \frac {nm\Delta t}{m\Delta t+(n-1)\Delta t}<br>$$</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>任务时空区：总时空区<br>$$<br>\eta = \frac {nm\Delta t}{m(m+n-1)\Delta t}<br>$$</p>
<h3 id="标准流水线"><a href="#标准流水线" class="headerlink" title="标准流水线"></a>标准流水线</h3><p>流水线性能重要元素：流水线中功能段数量</p>
<h3 id="高级流水线"><a href="#高级流水线" class="headerlink" title="高级流水线"></a>高级流水线</h3><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p>将流水线细分，增加流水线的段数，减少每段的延迟时间</p>
<h4 id="超长指令字技术"><a href="#超长指令字技术" class="headerlink" title="超长指令字技术"></a>超长指令字技术</h4><p>经过编译优化，将多条能够并行执行的指令合并成一条具有多个操作码的超长指令</p>
<h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p>用多套相同的指令流水</p>
<h3 id="流水线的相关问题"><a href="#流水线的相关问题" class="headerlink" title="流水线的相关问题"></a>流水线的相关问题</h3><p>如果一段程序的相近指令之间存在某种依赖关系，称为指令之间存在相关关系（冒险）</p>
<p><strong>使流水断流的相关问题</strong></p>
<p>局部相关：资源冲突，数据相关</p>
<p>全局相关：控制转移相关，如转移指令、中断处理</p>
<h4 id="资源相关（结构冒险）"><a href="#资源相关（结构冒险）" class="headerlink" title="资源相关（结构冒险）"></a>资源相关（结构冒险）</h4><p>争用同一个部件</p>
<p>解决办法：插气泡</p>
<p>增加缓冲部件，存储冲突还可以设置两个不同的存储器</p>
<h4 id="数据相关（数据冒险）"><a href="#数据相关（数据冒险）" class="headerlink" title="数据相关（数据冒险）"></a>数据相关（数据冒险）</h4><p>多条指令进入流水线之后，指令的操作重叠</p>
<p>解决办法：</p>
<p>（1）使后续相关的指令延迟进入流水线（推后法）。<br>（2）增加快速直接通道（零延迟量法、定向技术-设置专用旁路）。</p>
<h4 id="控制转移相关（控制冒险）"><a href="#控制转移相关（控制冒险）" class="headerlink" title="控制转移相关（控制冒险）"></a>控制转移相关（控制冒险）</h4><p>控制相关是指有分支指令、转子指令和中断等引起的相关冲突。</p>
<p>解决办法：</p>
<p>加快和提及前形成条件码</p>
<p>预取转移成功分支序列的指令</p>
<p>延迟转移</p>
<p>动态转移预测（根据历史预测转移方向）</p>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="机器指令格式"><a href="#机器指令格式" class="headerlink" title="机器指令格式"></a>机器指令格式</h2><p>指令字（指令代码）：表示一条指令的一串二进制代码。</p>
<p><strong>一条指令中应包含的信息：</strong><br>① <strong>操作码</strong>：表示指令的操作特性和功能。<br>② <strong>操作数的地址</strong>：指示操作数或操作数所在的地址。<br>③ <strong>存放操作结果的地址。</strong><br>④ <strong>下一条指令的地址。</strong><br>指令的基本格式：</p>
<p>OP + A</p>
<p>各字段的指定方法：<br>显式指定：在指令字中明显地指定。<br>隐含指定：由设计者用约定的方法指定。<br>指令操作码均采用显式指定。<br>下一条指令的地址多采用隐含指定。<br>信息的存储结构不同，指定的地址也不一样，地址的结构也不同。</p>
<h2 id="指令字的长度"><a href="#指令字的长度" class="headerlink" title="指令字的长度"></a>指令字的长度</h2><p>指令字长度：一个指令字所包含的二进制信息的位数。<br>定长指令字：机器的指令系统中各种指令字的长度均为固定的。<br>可变长指令字：机器的指令系统中各种指令字的长度随指令的功能而异。 </p>
<p><strong>单字长指令</strong>：指令长度等于<strong>机器字长</strong>。<br>双字长指令：指令长度等于两个机器字长。</p>
<p>指令基本格式：操作码（OP），地址码（A）</p>
<p>显式指令：指令字中明显地指定</p>
<p>隐含指定：由设计者用约定的方法指定</p>
<h2 id="指令地址码"><a href="#指令地址码" class="headerlink" title="指令地址码"></a>指令地址码</h2><p>CPU可直接访问的存储结构：</p>
<p>主存储器：访问时给出存储单元地址</p>
<p>CPU寄存器：包括通用寄存器和专用寄存器</p>
<p>I/O接口寄存器：包括数据寄存器和状态寄存器</p>
<p>堆栈</p>
<p><strong>例</strong>：设机器指令字长为16位，指令中地址字段的长度为4位，共有11条三地址指令，72条二地址指令，64条零地址指令。问最多还能规定多少条一地址指令？<br>解：三地址指令的地址字段共需12位，所以可有4位操作码，可规定16条三地址指令。现有11条三地址指令，所以还有 16－11＝5 个编码用于二地址指令。<br>二地址指令的地址字段共需8位，可有8位操作码，去掉三地址指令用掉的操作码，可规定5×16＝80 条二地址指令。现有72条二地址指令，所以还有80－72＝8 个编码用于一地址指令。</p>
<p>一地址指令的地址字段共需4位，可有12位操作码，去掉二、三地址指令用掉的操作码，可规定 8×16＝128 条单地址指令。<br>由于要求有64条零地址指令，而4位操作码只能提供16条指令，所以需要由单地址指令提供64/16＝4个操作码编码，因此还能规定 128－4＝124 条单地址指令。</p>
<h2 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h2><p>顺序方式：采用PC增量的方式形成下一条指令地址。 </p>
<p>跳越方式：当程序发生转移时，修改PC的内容。</p>
<h2 id="操作数的寻址方式"><a href="#操作数的寻址方式" class="headerlink" title="操作数的寻址方式"></a>操作数的寻址方式</h2><p>常用寻址方式：</p>
<p>OP+MOD+A</p>
<p><strong>立即寻址</strong>：</p>
<p>立即寻址方式是指指令的地址码部分给出的不是操作数的地址而是操作数本身。即指令所需的操作数由指令的形式地址直接给出。</p>
<p><strong>直接寻址</strong>：</p>
<p>直接寻址方式是指操作数的有效地址在指令字中直接给出，指令的地址码部分给出的形式地址A就是操作数的有效地址EA。 </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oDTZDK"><img src="https://s4.ax1x.com/2021/12/05/oDTZDK.png" alt="oDTZDK.png"></a></p>
<p><strong>间接寻址</strong>：</p>
<p>间接寻址方式是指指令的地址码部分给出的是操作数的有效地址EA所在的存储单元的地址或是指示操作数地址的地址指示字。即有效地址EA是由形式地址A间接提供的。<br>间接寻址分为一级间接寻址和多级间接寻址。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oDTC4J"><img src="https://s4.ax1x.com/2021/12/05/oDTC4J.png" alt="oDTC4J.png"></a></p>
<p><strong>寄存器直接寻址</strong>：</p>
<p>寄存器直接寻址也称寄存器寻址。寄存器直接寻址是指在指令地址码中给出的是某一通用寄存器的编号（也称寄存器地址），该寄存器的内容即为指令所需的操作数。采用寄存器寻址方式时，有效地址EA是寄存器的编号。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oDTpEF"><img src="https://s4.ax1x.com/2021/12/05/oDTpEF.png" alt="oDTpEF.png"></a></p>
<p><strong>寄存器间接寻址</strong>：</p>
<p>寄存器间接寻址方式是指指令中地址码部分所指定的寄存器中的内容是操作数的有效地址。 </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oDozHU"><img src="https://s4.ax1x.com/2021/12/05/oDozHU.png" alt="oDozHU.png"></a></p>
<p><strong>变址寻址</strong>：</p>
<p>变址寻址方式是指操作数的有效地址是由指令中指定的变址寄存器的内容与指令字中的形式地址相加形成的。<br>变址寄存器Rx可以是专用寄存器，也可以是通用寄存器中的某一个。 </p>
<p><strong>相对寻址</strong>：</p>
<p>相对寻址方式是将程序计数器 PC 的当前内容与指令中给出的形式地址相加形成操作数的有效地址。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oDovuV"><img src="https://s4.ax1x.com/2021/12/05/oDovuV.png" alt="oDovuV.png"></a></p>
<p><strong>基址寻址</strong>：</p>
<ul>
<li><strong>基址寻址主要用于为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序运行过程中，值是不可变的，而指令字中的地址码是可变的。</strong></li>
<li><strong>变址寻址中，变址寄存器的内容是用户自己设定的，在程序运行过程中是可变的，而指令字中的地址码是不可变的。编制寻址主要用于处理数组等问题，并且特别适合编制循环程序。</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oDoD0O"><img src="https://s4.ax1x.com/2021/12/05/oDoD0O.png" alt="oDoD0O.png"></a> </p>
<p><strong>基址加变址寻址</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oDo1mT"><img src="https://s4.ax1x.com/2021/12/05/oDo1mT.png" alt="oDo1mT.png"></a></p>
<p><strong>堆栈寻址</strong>：</p>
<p><strong>寄存器堆栈：</strong></p>
<p>计算机在CPU中设置一组专门用于堆栈的寄存器，每个寄存器按照机器字长可以保存一个字的数据，相邻的寄存器具有位对位的移位功能，CPU可以通过进栈指令和出栈指令，控制将数据压入和弹出堆栈。<br>寄存器堆栈由于栈顶位置固定，所以不必设置堆栈的栈顶指针。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oDbkgs"><img src="https://s4.ax1x.com/2021/12/05/oDbkgs.png" alt="oDbkgs.png"></a></p>
<p><strong>存储器堆栈</strong>：</p>
<p>存储器堆栈就是一组连续的存储器单元的有序集合。<br>堆栈通常位于主存的一个特定区域，它既可以是固定的区域，也可以是浮动的区域，可以用软件加以定义，而且需要时可以定义多个存储器堆栈。<br>为了表示栈顶的位置，通常用一个寄存器或存储器单元指出栈顶的地址，这个寄存器或存储器单元称为堆栈指针SP，SP的内容永远指向堆栈当前的栈顶。<br>由于堆栈遵循先进后出原则进行信息的存取，堆栈的压入和弹出操作总是按地址自动增量和自动减量方式在栈顶进行。  </p>
<p><strong>堆栈寻址</strong>：</p>
<p>堆栈寻址方式就是按照堆栈指示器SP的内容确定操作数的访存地址。<br>例如在堆栈支持的运算型零地址指令中，操作数隐含指定在堆栈，当CPU执行这种指令时，自动地按当前SP值从堆栈的栈顶和次栈顶弹出数据，进行操作码指示的操作，然后再将所得结果自动压入堆栈。<br>堆栈除了可为零地址指令提供操作数外，还有很多用途。如在子程序的调用中，用堆栈存放返回地址，可以实现子程序的嵌套和递归调用；在程序中断的处理中，用堆栈存放多级中断的有关信息，可以实现多级中断的嵌套等。  </p>
<h2 id="指令类型及功能"><a href="#指令类型及功能" class="headerlink" title="指令类型及功能"></a>指令类型及功能</h2><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ol>
<li>完备性<br> 任何运算都可以用指令编程实现。即要求指令系统的指令丰富、功能齐全、使用方便，应具有所有基本指令。</li>
<li>有效性<br> 用指令系统中的指令编写的程序能高效率运行，占用空间小、执行速度快。</li>
<li>规整性<br> 指令系统具有对称性、匀齐性，指令与数据格式的一致性。</li>
<li>对称性：所有寄存器和存储单元均同等对待，所有指令可以使用所有寻址方式，减少特殊操作和例外情况。</li>
<li>匀齐性：一种操作可支持各种数据类型。如算术指令可支持字节、字、双字、十进制数、浮点单精度数、浮点双精度数等。</li>
<li>指令与数据格式的一致性：指令长度与数据长度有一定的关系，以便于存取和处理。</li>
<li>兼容性：系列机的各机种之间有基本相同的指令集。至少作到向后兼容，即先推出的机器上的程序可以在后推出的机器上运行。</li>
</ol>
<h1 id="I-O系统组织"><a href="#I-O系统组织" class="headerlink" title="I/O系统组织"></a>I/O系统组织</h1><h2 id="I-O系统的功能"><a href="#I-O系统的功能" class="headerlink" title="I/O系统的功能"></a>I/O系统的功能</h2><p>I/O系统的基本功能</p>
<p>为数据传输操作选择I/O设备</p>
<p>控制被选的I/O设备与主机之间的信息交换</p>
<p>关键问题：解决主机与外部设备间的信息通讯问题，提供主机与外设间的信息通路，使外围设备与主机能够协调一致地工作。</p>
<p>I/O系统主要用于解决主机与外部设备间的数据交换的问题，使外设与主机能够协调一致地工作。<br> （1） 使处理机与外设在数据处理的<strong>速度上能够相互匹配</strong>。解决方法：缓冲技术<br>（2） 使处理机与外设<strong>能够并行工作</strong>，以提高整个计算机系统的工作效率。解决方法：减少处理机对外设的直接控制，甚至处理机不再干预对外设的控制，而交由专门的硬件装置去实现对外部设备的管理与监督。</p>
<p>典型计算机系统中I/O系统的组成：<br><strong>系统总线</strong>、<strong>I/O设备接口控制器</strong>、<strong>I/O设备</strong>、<strong>相关控制软件</strong>。 </p>
<p>现代计算机系统中I/O系统的组成：<br><strong>扩展总线</strong>、<strong>I/O设备接口控制器</strong>、I/O设备、相关控制软件。 </p>
<p>主机与外围设备的连接方式大致可分为：</p>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p><strong>总线方式，通道方式，I/O处理机方式（IOP）</strong></p>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>有些种类的I/O接口控制器可以控制多台I/O设备，如多用户卡。这种方式称之为现代星型I/O设备的连接方式</p>
<h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>通道控制器是专门负责I/O操作的控制器，它执行由专门的通道指令编制并存放在<strong>内存之中的通道程序</strong>实现对外设的控制。<br>通道控制连接方式下，由通道控制器控制实现<strong>主存与外设之间的直接数据交换</strong>， <strong>CPU不再负责具体的I/O控制</strong>，实现了处理机与通道控制器和外设的并行工作。</p>
<h4 id="IOP"><a href="#IOP" class="headerlink" title="IOP"></a>IOP</h4><p>I/O处理机(IOP)<br><strong>一种具有比I/O通道更强独立性的专用CPU。</strong><br>IOP有自己的指令系统，可编程控制，适应性强、通用性好。其程序的执行可与CPU并行，可使CPU彻底摆脱对I/O的控制处理。</p>
<h3 id="I-O信息传送的控制方式"><a href="#I-O信息传送的控制方式" class="headerlink" title="I/O信息传送的控制方式"></a>I/O信息传送的控制方式</h3><p>I/O数据传送控制方式也称I/O信息交换方式。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ordZyq"><img src="https://s4.ax1x.com/2021/12/06/ordZyq.png" alt="ordZyq.png"></a></p>
<h4 id="由程序控制的数据传送"><a href="#由程序控制的数据传送" class="headerlink" title="由程序控制的数据传送"></a>由程序控制的数据传送</h4><p>这种控制方式是指在主机和设备之间的I/O数据传送，<strong>需要通过处理机执行具体的I/O指令来完成</strong>。即由处理机执行所谓的I/O程序，实现对整个I/O数据传送过程的<strong>全程监督与管理</strong>。<br>程序控制方式一般在<strong>总线型连接方式中采用</strong>。<br>由程序控制的数据传送可进一步分为直接程序控制方式和程序中断传送方式。 </p>
<h3 id="由专有硬件控制的数据传输"><a href="#由专有硬件控制的数据传输" class="headerlink" title="由专有硬件控制的数据传输"></a>由专有硬件控制的数据传输</h3><p>这种控制方式需要在系统中设置<strong>专门用于控制I/O数据传输的硬件装置</strong>，处理机只要启动这些装置，就会在它们的控制下完成I/O数据传输，因此具体的I/O数据传输过程无需处理机的控制。</p>
<h2 id="接口的功能"><a href="#接口的功能" class="headerlink" title="接口的功能"></a>接口的功能</h2><p>接口：通常指设备(硬件)之间的界面。</p>
<p>I/O接口：主机(系统总线)与外设或其它外部系统之间的接口逻辑。</p>
<p>当主机与外设相连时，必须要有相应的接口逻辑部件来解决两者之间的<strong>操作同步与协调</strong>、<strong>工作速度的匹配</strong>以及<strong>数据格式的转换</strong>等问题。</p>
<h3 id="I-O接口基本功能："><a href="#I-O接口基本功能：" class="headerlink" title="I/O接口基本功能："></a>I/O接口基本功能：</h3><p>⑴ 实现<strong>数据的传送</strong>、缓冲、隔离和锁存。<br>⑵ 实现信号形式和数<strong>据格式转换</strong>。<br>⑶ 控制主机与外设之间的通信联络，实现控制命令和状态信息的交换，保证<strong>时序协调</strong>。<br>⑷ 寻址，即<strong>识别设备地址</strong>，选择指定的设备和I/O端口。</p>
<h3 id="CPU和外设之间传送的信息"><a href="#CPU和外设之间传送的信息" class="headerlink" title="CPU和外设之间传送的信息"></a>CPU和外设之间传送的信息</h3><h4 id="数据信息"><a href="#数据信息" class="headerlink" title="数据信息"></a>数据信息</h4><p>①  数字量<br>数字量是指用二进制码形式提供的信息，如用二进制形式表示的数据、以ASCII码形式表示的字符等。通常有8位、16位和32位数据。<br>②  模拟量<br>模拟量是指连续变化的物理量，如温度、湿度、位移、压力、流量等。</p>
<p>③ 开关量<br>开关量有两个状态：“0”和“1”，可以用1位二进制数表示。具有两种状态的量</p>
<h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>状态信息就是反映当前<strong>外设所处的工作状态的信息</strong>。<br>在与外设进行数据信息的交换时，CPU需要通过状态信息了解外设的<strong>工作状态</strong>。通常外设用准备好（READY）信号来表明是否准备就绪；用忙（BUSY）信号表示是否处于空闲状态。</p>
<h4 id="控制命令信息"><a href="#控制命令信息" class="headerlink" title="控制命令信息"></a>控制命令信息</h4><p>在外设的工作过程中，CPU需要<strong>通过控制信息控制外设的工作</strong>，如对外设的启动和停止等。不同外设所需的控制信息各不相同，因此CPU需要<strong>通过接口将控制信息传送给外设</strong>。 </p>
<h4 id="同步信号"><a href="#同步信号" class="headerlink" title="同步信号"></a>同步信号</h4><p>当主机或外设将数据发送到接口后，接口需要<strong>给出数据已经“就绪”的信号</strong>通知对方可以取走数据进行处理，即需要有同步信号实现同步控制。</p>
<h4 id="设备选择信号"><a href="#设备选择信号" class="headerlink" title="设备选择信号"></a>设备选择信号</h4><p>设备选择信号<strong>用于指示选中的设备</strong>。<br>它通常作为数据选通信号被送到三态门电路的控制端上使三态门电路脱离高阻状态，以便选中的设备可以参与数据交换。因此，每个设备接口中都有一个专门的设备选择电路。</p>
<h4 id="中断及DMA控制逻辑"><a href="#中断及DMA控制逻辑" class="headerlink" title="中断及DMA控制逻辑"></a>中断及DMA控制逻辑</h4><p>如果系统中采用中断方式控制主机与外设之间的信息交换，接口中则应有中断控制逻辑。</p>
<p>如果系统中采用的DMA方式控制主机与外设之间的信息交换，则接口中就应有DMA控制逻辑。</p>
<h3 id="I-O信息的传送"><a href="#I-O信息的传送" class="headerlink" title="I/O信息的传送"></a>I/O信息的传送</h3><p>数据信息、状态信息和控制信息各不相同，应该分别传送。<br>为了便于处理，将状态信息、控制信息也<strong>广义地看成数据信息</strong>，通过数据总线来传送。为了区别这三种信息，在接口线路中将它们分别送入不同的寄存器。<br>CPU同外设之间的信息传送<strong>实质上是对相应的寄存器进行“读”或“写”操作。</strong><br><strong>端口</strong>（Port或I/O端口）：接口中可以由<strong>CPU进行读或写</strong>的<strong>寄存器</strong>。</p>
<h3 id="I-O端口寻址方式"><a href="#I-O端口寻址方式" class="headerlink" title="I/O端口寻址方式"></a>I/O端口寻址方式</h3><h4 id="与主存统一编址"><a href="#与主存统一编址" class="headerlink" title="与主存统一编址"></a>与主存统一编址</h4><p>将一个I/O端口作为存储器中的一个单元对待，每一个I/O端口占用一个存储器单元地址。编址时将I/O端口与存储器单元一起进行编址。<br>又称为存储器对应的输入输出方式或存储器映象编址方式。</p>
<h4 id="I-O端口独立编址"><a href="#I-O端口独立编址" class="headerlink" title="I/O端口独立编址"></a>I/O端口独立编址</h4><p>将I/O端口与存储器单元分别独立进行编址，CPU访问外设时，需使用<strong>专门的I/O指令</strong>，并需要有与接口电路联系的单独的控制信号。<br>也称为I/O端口寻址输入输出方式。</p>
<h3 id="I-O接口的分类"><a href="#I-O接口的分类" class="headerlink" title="I/O接口的分类"></a>I/O接口的分类</h3><h4 id="按数据传送格式分"><a href="#按数据传送格式分" class="headerlink" title="按数据传送格式分"></a>按数据传送格式分</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/orsI9U"><img src="https://s4.ax1x.com/2021/12/06/orsI9U.png" alt="orsI9U.png"></a></p>
<h4 id="按时序的控制方式分"><a href="#按时序的控制方式分" class="headerlink" title="按时序的控制方式分"></a>按时序的控制方式分</h4><p>同步接口：一般与同步总线相连，<strong>接口与总线采用统一时钟信号</strong>，无论CPU与I/O设备，还是存储器与I/O设备交换信息，都与总线同步时钟脉冲同步。<br>异步接口：与异步总线相连，接口与系统总线之间采用异步应答方式。</p>
<h4 id="按信息传送交换的控制方式分"><a href="#按信息传送交换的控制方式分" class="headerlink" title="按信息传送交换的控制方式分"></a>按信息传送交换的控制方式分</h4><p>直接程序控制接口：采用直接程序控制方式进行信息交换的接口。<br>程序中断接口：主机与外设以程序中断方式进行信息交换控制的接口。<br>直接存储器存取接口：以直接存储器存取(DMA)方式控制信息传送的接口。</p>
<h3 id="接口基本组成"><a href="#接口基本组成" class="headerlink" title="接口基本组成"></a>接口基本组成</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oryG5V"><img src="https://s4.ax1x.com/2021/12/06/oryG5V.png" alt="oryG5V.png"></a></p>
<p>⑴  <strong>设备选择电路</strong><br>用于接收总线传来的地址信息，经译码后，决定选择哪个设备或I/O接口内部的部件。<br>⑵ <strong>数据缓冲寄存器</strong>（数据端口）<br>用于存放主机与外设之间要传递的数据信息。<br>⑶ <strong>命令寄存器</strong>（控制端口）<br>用于存放主机向外设发送的控制命令。<br>⑷ <strong>状态寄存器</strong>（状态端口）<br>用于存放外设或接口的工作状态。<br>⑸ <strong>其它有关部件</strong><br>如中断控制逻辑、DMA控制逻辑以及各类特殊部件。</p>
<h2 id="程序控制方式"><a href="#程序控制方式" class="headerlink" title="程序控制方式"></a>程序控制方式</h2><p>程序控制方式的特点：<br><strong>数据传输操作通过在处理机上执行的I/O指令来实现。</strong><br>程序控制方式下数据传输的过程：</p>
<p>⑴ <strong>输入数据</strong><br>① CPU执行<strong>I/O输入指令</strong>，启动输入操作总线周期，将I/O接口<strong>数据缓冲寄存器</strong>中的数据取到<strong>CPU中的累加器中</strong>。<br>② CPU执行写存储器指令，<strong>启动写存储器总线周期</strong>，<strong>将累加器中存放的输入数据写到内存某个单元中</strong>。</p>
<p>⑵ <strong>输出数据</strong><br>① CPU执行<strong>读存储器指令</strong>，启动读存储器总线周期，将内存某个单元中存放的待输出数据取到<strong>CPU的累加器</strong>中。<br>② CPU执行I/O输出指令，启动输出操作总线周期，将累加器中存放的待输出数据写到设备接口的数据缓冲寄存器中。<br>★在程序控制方式下，<strong>内存与外设交换一个数据需要使用两次总线</strong>，即需要执行一个访问存储单元的总线周期和一个访问I/O的总线周期。 </p>
<h3 id="直接程序控制方式"><a href="#直接程序控制方式" class="headerlink" title="直接程序控制方式"></a>直接程序控制方式</h3><p>直接程序控制方式完全通过程序来控制主机与外设之间信息传送。<br>通常是在用户程序中安排一段由I/O指令和其它指令组成的I/O程序，通过执行I/O程序实现对外设的直接控制。  </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/or6yes"><img src="https://s4.ax1x.com/2021/12/06/or6yes.png" alt="or6yes.png"></a></p>
<h4 id="程序中断传送方式"><a href="#程序中断传送方式" class="headerlink" title="程序中断传送方式"></a>程序中断传送方式</h4><p>中断是指处理机<strong>暂时中止执行现行程序而转去执行处理更加紧迫事件的服务程序</strong>，待处理完毕后，再自动返回执行原来的程序的过程。</p>
<p>相对于在CPU上运行的程序，<strong>中断具有随机性</strong>（不可预测性）、<strong>异步性</strong>和<strong>不可再现性</strong>。</p>
<h4 id="中断机构的建立"><a href="#中断机构的建立" class="headerlink" title="中断机构的建立"></a>中断机构的建立</h4><p>中断机构是指在一个计算机系统中，为解决中断问题而制定的一整套软/硬机制、策略和方法。<br>设计、实现中断机构的主要要素：<br>(1) 中断源的设置。定义当系统中出现了<strong>哪些情形将会引发中断</strong>；<br>(2) <strong>中断的分类与分级</strong>。决定如何对中断源分类，以及对各类中断应该赋予什么级别的优先级；<br>(3) 中断信号的建立与传送。即<strong>如何记录中断请求</strong>以及<strong>如何将中断请求发送给CPU</strong>；</p>
<p>(4) 实现<strong>优先级比较</strong>的方式方法；<br>(5) CPU响应中断的<strong>条件和时机</strong>，以及CPU在响应中断时要做的工作；<br>(6) CPU<strong>识别各个中断的方法</strong>，以及如何找到处理相应中断的中断处理程序；<br>(7) 是否允许正在执行的中断处理程序被其他高级别的中断请求打断，即系统<strong>是否允许中断嵌套</strong>。</p>
<h3 id="中断源设置"><a href="#中断源设置" class="headerlink" title="中断源设置"></a>中断源设置</h3><p>中断源是指能引起<strong>中断事件的原因</strong>。</p>
<p>① 在硬件装置上，如I/O设备接口控制器。此时中断由在硬件装置上发生的事件所引起。<br>② 隐藏在指令中，如自陷指令或中断指令。<br>③  CPU内部某个状态寄存器，如浮点数计算溢出标志寄存器。<br>②③两类中断源所引发的中断，都是在CPU执行某条指令时由某种特殊情况而引起的，此时中断产生在<strong>CPU内部</strong>，而不像<strong>设备中断</strong>那样产生于<strong>CPU外部</strong>。</p>
<p>中断源在CPU外部，如设备中断、存储器故障中断、电源故障中断等等。<br>设备中断具有随机性（不可预测性）、异步性和不可再现性。<br>故障中断具有可再现性，比如两次分别对内存故障单元的访问都会引发存储器故障中断。</p>
<h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>中断请求</p>
<p>中断判优</p>
<p>保护现场</p>
<p>中断服务</p>
<p>恢复现场</p>
<p>中断返回</p>
<h3 id="中断请求信号的建立与传送"><a href="#中断请求信号的建立与传送" class="headerlink" title="中断请求信号的建立与传送"></a>中断请求信号的建立与传送</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/orTtTU"><img src="https://s4.ax1x.com/2021/12/06/orTtTU.png" alt="orTtTU.png"></a></p>
<h4 id="外设发出请求中断信号的条件"><a href="#外设发出请求中断信号的条件" class="headerlink" title="外设发出请求中断信号的条件"></a>外设发出请求中断信号的条件</h4><p>外设准备就绪</p>
<p>外设的中断请求没有被屏蔽</p>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><p>中断请求信号是否能够传送给CPU，要看当时占有CPU执行程序的优先级。<br>如程序的优先级高于或等于当前中断请求的优先级，则不应将中断请求信号传给CPU，即需进行中断屏蔽。<br>如占有CPU进程的优先级低于请求中断的优先级，则不应屏蔽这个中断，而使CPU能够响应这个中断。</p>
<ol>
<li>先屏蔽：在中断请求触发器IRQ的D端进行屏蔽</li>
<li>后屏蔽：在IRQ的输出端进行屏蔽</li>
<li>集中屏蔽：在公共接口逻辑中设置一个中断控制器</li>
</ol>
<h4 id="中断判优"><a href="#中断判优" class="headerlink" title="中断判优"></a>中断判优</h4><p>内部优于外部</p>
<p>故障由于设备请求</p>
<p>非屏蔽由于屏蔽</p>
<p>输入由于输出</p>
<p>数据有效时间短又于时间长的</p>
<h5 id="CPU现行程序于中断请求间的判优"><a href="#CPU现行程序于中断请求间的判优" class="headerlink" title="CPU现行程序于中断请求间的判优"></a>CPU现行程序于中断请求间的判优</h5><p><strong>通过设置CPU内部的“中断允许”状态进行判优</strong></p>
<p>在CPU内部设置“允许中断”触发器IEN，指令系统提供开中断和关中断的功能</p>
<p>如果CUP处于关中断状态，则所有外部中断都没有现行程序的任务重要</p>
<p><strong>在现行程序的程序状态字PSW中设置现行程序的优先级</strong></p>
<p>若中断请求的优先级高于现行程序的优先级，则予以响应</p>
<h5 id="中断请求之间的排队与判优"><a href="#中断请求之间的排队与判优" class="headerlink" title="中断请求之间的排队与判优"></a>中断请求之间的排队与判优</h5><p>软件查询：响应中断请求后，先转入中断查询程序，按优先顺序依次询问各中断源是否提出请求。</p>
<p>多用于公共请求线方式，但是设备多时响应速度太慢</p>
<p><strong>并行优先排队逻辑</strong></p>
<p>采用硬件并行优先排队逻辑对独立中断请求线的中断请求进行判优</p>
<p><strong>链式排队</strong></p>
<p><strong>二维优先排队</strong></p>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><h5 id="中断响应过程中应该完成的操作"><a href="#中断响应过程中应该完成的操作" class="headerlink" title="中断响应过程中应该完成的操作"></a>中断响应过程中应该完成的操作</h5><p>关中断：不允许新的中断请求</p>
<p>保存断电和程序状态字</p>
<p>转入中断服务程序入口</p>
<h4 id="中断服务程序入口地址的获取方式"><a href="#中断服务程序入口地址的获取方式" class="headerlink" title="中断服务程序入口地址的获取方式"></a>中断服务程序入口地址的获取方式</h4><ol>
<li><p>非向量中断：CPU在响应中断时只产生一个固定的地址，该地址时中断查询程序的入口地址。</p>
<ol>
<li>软件查询方法：CPU响应中断请求后，先转入中断查询程序。</li>
<li>通过硬件排队与编码电路获得优先级最高的中断源的设备码</li>
</ol>
</li>
<li><p>向量中断：</p>
<ol>
<li>中断向量：所有中断源对应的中断服务程序的入口地址及其程序状态字PSW的有序集合</li>
<li>中断向量表：存放中断向量的表。所有中断服务程序入口地址组织成的一个一维表</li>
<li>中断向量地址：访问中断向量表的地址码，即读取中断向量所需的地址，也成为中断指针。</li>
</ol>
<p>向量中断：将各个中断服务程序的入口地址组织成中断向量表；响应中断时，由硬件直接产生对应于中断源的向量地址；据此访问中断向量表，从中读取服务程序入口地址，由此转向中断服务程序。</p>
<p>向量中断的响应工作一般在中断周期中由硬件直接实现。</p>
<p>特点：<strong>能够根据中断请求信号快速/直接的转向应对中断服务程序</strong></p>
<p>⑴ 中断源提出中断请求。<br>⑵ 若CPU允许中断，则发出中断回答信号。<br>⑶ 优先级编码电路形成优先级最高的中断请求的中断向量地址存入中断向量地址寄存器VAR。<br>⑷ 保护断点和现场，PC、PSW入栈。<br>⑸ 根据中断向量地址，将对应的中断服务程序入口地址和PSW送入PC和PSR。<br>⑹ 转入中断服务程序，进行中断服务。<br>⑺ 中断返回，将保存的PC和PSW弹回PC和PSR。</p>
</li>
</ol>
<h4 id="中断服务"><a href="#中断服务" class="headerlink" title="中断服务"></a>中断服务</h4><p>取得中断服务程序的入口地址之后，CPU开始执行中断服务程序</p>
<h5 id="起始"><a href="#起始" class="headerlink" title="起始"></a>起始</h5><p>判断中断原因，识别中断源</p>
<p>设置屏蔽字</p>
<p>保护中断现场</p>
<p>开中断：以便在本次中断处理过程中，允许响应更高级的中断请求</p>
<h5 id="主体部分"><a href="#主体部分" class="headerlink" title="主体部分"></a>主体部分</h5><p>执行具体的中断源服务程序</p>
<h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><p>关中断</p>
<p>恢复中断现场</p>
<p>清中断请求信号</p>
<p>清屏蔽字</p>
<p>开中断</p>
<p>恢复PSW,PC</p>
<p>总的说，就是：关，保护，开，处理，关，恢复，开，返回</p>
<h4 id="中断响应的及时性"><a href="#中断响应的及时性" class="headerlink" title="中断响应的及时性"></a>中断响应的及时性</h4><p>中断源提出中断申请后到中断处理程序的第一条指令开始执行之间的时间</p>
<p><strong>程序中断对流水线的影响</strong></p>
<p>不精确断点法</p>
<p>不论在哪一条指令中的哪个流水功能段上发生中断请求，都不再允许未流入流水线的后继指令进入流水线。但已经在流水线中的所有指令，允许它们继续流动到执行完毕。</p>
<p>精确断点法</p>
<p>流水线都停下来，用大量寄存器保存现场</p>
<h2 id="DMA的基本概念"><a href="#DMA的基本概念" class="headerlink" title="DMA的基本概念"></a>DMA的基本概念</h2><p><strong>程序直接控制方式</strong>受“踏步”现象的限制，效率低下，不适合高速设备和主机间的数据传送。<br><strong>中断控制方式</strong>虽比程序直接控制方式有效，CPU和外设有一定的并行度，但由于下列原因也不适合高速设备和主机间的数据传送。</p>
<p>DMA方式：<br>      <strong>以主存为中心</strong>，采用硬件手段在主存与I/O设备之间建立直接的数据传送通路，<strong>由DMA控制器（DMAC）取得总线控制权</strong>，控制主存与I/O设备之间的数据传送，在传送过程中不需要CPU的程序干预的数据传送控制方式。</p>
<h3 id="DMA方式的特点与应用场合"><a href="#DMA方式的特点与应用场合" class="headerlink" title="DMA方式的特点与应用场合"></a>DMA方式的特点与应用场合</h3><ol>
<li>DMA方式的特点<br> ⑴ 以响应随机请求的方式，实现主存与I/O设备间的快速数据传送。<br> ⑵ 采用DMA方式控制数据传送时，仅需占用系统总线，不切换程序，不存在保存断点、保护现场、恢复现场、恢复断点等操作。因此DMA传送的插入不影响CPU的程序执行状态，除了访问主存的冲突外，CPU可以继续执行自己的程序，提高了CPU的利用率。<br> ⑶ DMA方式只能处理简单的数据传送，难以识别与处理复杂的情况。  </li>
<li>DMA方式的应用<br> DMA方式一般应用于主存与高速I/O设备间的简单数据传送(高速I/O设备如磁盘、磁带、光盘等外存储器)，以及其它带有局部存储器的外围设备、通信设备等。如：<br> ⑴ 磁盘与主存的成块数据传送<br> ⑵ 通信设备的批量数据传送<br> ⑶ 动态存储器的刷新<br> ⑷ 大批量数据采集系统</li>
</ol>
<h3 id="DMA的传送方式"><a href="#DMA的传送方式" class="headerlink" title="DMA的传送方式"></a>DMA的传送方式</h3><p>周期挪用（周期窃取）方式</p>
<p>当I/O设备无DMA传送请求时，CPU正常访问主存。当I/O设备需要使用总线传送数据时，产生DMA请求，DMAC把总线请求发给CPU。<br>① 若CPU本身无使用总线的要求，CPU就把总线交给DMAC，由DMAC控制I/O设备使用总线<br>② 如果此时CPU也要使用总线，则CPU自身进入一个或几个“空闲总线周期”状态，<strong>即CPU让出一个或几个总线周期给DMAC</strong>（也称DMAC“挪用”一个总线周期），DMAC利用此总线周期控制传送一个数据字后，再把总线交还给CPU，以便CPU可以继续执行总线操作。 </p>
<p>采用周期挪用方式时，外设要求DMA传送的三种情况：<br>⑴ 外设要求DMA传送时，CPU不需访问主存(如CPU正在执行乘法指令，由于乘法指令执行时间较长，此时CPU不需访问主存)，故外设访存与CPU不发生冲突。<br>⑵ 外设要求DMA传送时，CPU正在访存，此时必须<strong>等CPU存取周期结束后</strong>，CPU才能让出总线控制权。<br>⑶ 外设要求访存时，CPU也要求访存，这就出现了访存冲突。此时要求外设访存优先于CPU访存。因为外设不立即访存就可能丢失数据，这时D<strong>MAC要窃取</strong>一、二个存取周期，使CPU延缓一、二个存取周期再访存。</p>
<p><strong>缺点</strong></p>
<p>每传送一个数据，DMA都要产生访问请求，待到CPU响应后才能传送，因此判优操作及总线切换操作非常频繁，其花费的时间开销较大。往往在传输一个数据块时，需要DMA控制器多次申请使用总线，这影响了DMA的数据传输速度。</p>
<p>周期挪用方式适用于I/O设备接口控制器中<strong>数据缓冲器容量不大</strong>的场合，例如在接口控制器中仅设置一个数据寄存器的情形，对具有较大容量数据缓冲存储器的高速外设来说是不合适的。 </p>
<h3 id="DMA的硬件组织"><a href="#DMA的硬件组织" class="headerlink" title="DMA的硬件组织"></a>DMA的硬件组织</h3><p>在目前的计算机系统中，通常专门设置了DMA控制器，并且较多采取DMA控制器与DMA接口相分离的方式。 </p>
<ol>
<li>DMA控制器（DMAC）<br> DMAC负责申请、接管总线的控制权、发送地址和操作命令以及控制DMA传送过程的起始与终止。<br> DMA控制器独立于具体I/O设备，可以为各个设备通用。 </li>
</ol>
<p>  (1) 主存地址寄存器MAR<br>  用于存放主存中需要交换数据的地址。<br>  在DMA传送前，须通过程序将数据在主存中的首地址送到主存地址寄存器。在DMA传送过程中，每交换一次数据，将地址寄存器内容加/减1，指向下一单元，直到一批数据传送完毕为止。</p>
<p>  (2) 传输量计数器 WC<br>  用于记录传送数据的总字数。<br>  传输量计数器一般采用相反数的补码（变补）表示要传送的数据量。在DMA传送过程中，每传送一个字（或字节）,计数器自动加1，当WC内容溢出时，表示数据已全部传送完毕，DMAC发出DMA传送结束信号。</p>
<p>  (3) 数据缓冲寄存器DBR<br>  用于暂存每次传送的数据。<br>  通常DMA接口与主存之间采用字传送，而DMA与设备之间可能是字节或位传送。因此DMA接口中还可能包括有<strong>装配或拆卸字信息</strong>的硬件逻辑，如数据移位缓冲寄存器、字节计数器等。有的系统采用外设控制器上的数据缓冲器与内存单元之间通过数据总线直传的方法，这样就可以不用数据缓冲寄存器。 </p>
<p>  (4) 设备地址寄存器DAR<br>  存放I/O设备的设备码或表示设备信息存储区的寻址信息。如磁盘数据所在的区号、盘面号和柱面号。具体内容取决于设备的数据格式和地址的编址方式</p>
<ol start="2">
<li><p>接口类型</p>
<p>选择型（只可以接一个设备），多路型（允许接多个设备）</p>
</li>
</ol>
<h3 id="DMA控制方式下的数据传送过程"><a href="#DMA控制方式下的数据传送过程" class="headerlink" title="DMA控制方式下的数据传送过程"></a>DMA控制方式下的数据传送过程</h3><p>DMA预处理</p>
<p>在DMAC开始工作之前，CPU必须给它预置的信息：</p>
<p>控制寄存器写入DMA操作命令，给DMA控制逻辑指明数据床送方向是输入还是输出。</p>
<p>向DMA设备地址寄存器送入设备号</p>
<p>向DMA主存地址寄存器送入交换数据的主存起始地址</p>
<p>向传输量计数器送入交换数据的个数</p>
<p><strong>预处理工作由CPU执行几条输入输出指令完成</strong>，称为初始化工作。初始化工作完成后，CPU继续执行原来的程序。</p>
<p>DMAC获得总线后，即可按规定的传送方式，进行数据的输入或输出操作，<strong>直到将所有数据传输完毕</strong>，DMAC将总线交还给CPU。需要时还向CPU发出中断请求</p>
<p><strong>CPU响应中断后</strong>，为DMA传送作结束处理工作。<br>① 校验送入主存的数据是否正确<br>② 决定是否继续用DMA方式传送，还是结束传送<br>③ 测试在传送过程中是否发生了错误<br>④ 判断传送工作是否正常结束</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"># 组成原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/24/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="prev" title="云计算">
      <i class="fa fa-chevron-left"></i> 云计算
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="next" title="编译原理">
      编译原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">运算器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%98%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">乘法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%A4%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E9%99%A4%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">定点除法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">原码恢复余数法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%8D%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95%EF%BC%88%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95%EF%BC%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">原码不恢复余数法（加减交替法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%8D%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">原码不恢复余数法（整数）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="nav-number">1.4.</span> <span class="nav-text">补码除法运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E4%B8%8D%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E9%99%A4%E6%B3%95"><span class="nav-number">1.4.1.</span> <span class="nav-text">补码不恢复余数除法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">比较规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E5%95%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">上商算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%95%86%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">商的符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E6%96%B0%E4%BD%99%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">求新余数算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%95%86%E7%9A%84%E6%A0%A1%E6%AD%A3"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">商的校正</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AB%E5%B0%BE%E6%81%92%E7%BD%AE1"><span class="nav-number">1.4.1.5.1.</span> <span class="nav-text">末尾恒置1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%A1%E6%AD%A3%E6%B3%95"><span class="nav-number">1.4.1.5.2.</span> <span class="nav-text">校正法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E6%96%AF%E9%99%A4%E6%B3%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">布斯除法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="nav-number">2.</span> <span class="nav-text">浮点数四则运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.1.</span> <span class="nav-text">两个浮点数加减运算的步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%98%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">对阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E6%95%B0%E6%B1%82%E5%92%8C"><span class="nav-number">2.1.2.</span> <span class="nav-text">尾数求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="nav-number">2.1.3.</span> <span class="nav-text">结果规格化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%88%8D%E5%85%A5"><span class="nav-number">2.1.4.</span> <span class="nav-text">舍入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%AA%E6%96%AD%E6%B3%95"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">截断法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#0%E8%88%8D1%E5%85%A5%E6%B3%95"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">0舍1入法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AB%E4%BD%8D%E6%81%92%E7%BD%AE1"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">末位恒置1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%A1%A8%E8%88%8D%E5%85%A5%E6%B3%95"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">查表舍入法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD"><span class="nav-number">2.1.5.</span> <span class="nav-text">溢出判断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.</span> <span class="nav-text">尾数运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E4%B9%98%E6%B3%95%E5%B0%BE%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.1.</span> <span class="nav-text">浮点乘法尾数运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E8%A2%AB%E4%B9%98%E6%95%B0%E5%92%8C%E4%B9%98%E6%95%B0%E7%9A%84%E5%B0%BE%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA0"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">检测被乘数和乘数的尾数是否为0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A2%AB%E4%B9%98%E6%95%B0%E5%92%8C%E4%B9%98%E6%95%B0%E7%9A%84%E5%B0%BE%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">被乘数和乘数的尾数相乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">运算结果规格化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%88%8D%E5%85%A5%E5%A4%84%E7%90%86"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">舍入处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E9%99%A4%E6%B3%95%E5%B0%BE%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.2.</span> <span class="nav-text">浮点除法尾数运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E8%A2%AB%E9%99%A4%E6%95%B0%E5%92%8C%E9%99%A4%E6%95%B0%E7%9A%84%E5%B0%BE%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA0"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">检测被除数和除数的尾数是否为0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A2%AB%E9%99%A4%E6%95%B0%E5%92%8C%E9%99%A4%E6%95%B0%E7%9A%84%E5%B0%BE%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">被除数和除数的尾数相除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E8%A7%84%E6%A0%BC%E5%8C%96-1"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">运算结果规格化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%8ECPU"><span class="nav-number">3.</span> <span class="nav-text">控制系统与CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.1.</span> <span class="nav-text">指令执行基本步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.1.2.</span> <span class="nav-text">控制器的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="nav-number">3.1.3.</span> <span class="nav-text">控制器的基本功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">控制指令正确执行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E5%87%BA%E6%8E%A7%E5%88%B6"><span class="nav-number">3.1.3.1.1.</span> <span class="nav-text">指令流出控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E6%8C%87%E4%BB%A4%E5%92%8C%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="nav-number">3.1.3.1.2.</span> <span class="nav-text">分析指令和执行指令的控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E5%90%91%E6%8E%A7%E5%88%B6"><span class="nav-number">3.1.3.1.3.</span> <span class="nav-text">指令流向控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E5%8F%8A%E7%BB%93%E6%9E%9C%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">控制程序和数据的输入及结果的输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E5%92%8C%E7%89%B9%E6%AE%8A%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">异常情况和特殊请求处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%83%A8%E4%BB%B6"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">指令部件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6%E9%83%A8%E4%BB%B6"><span class="nav-number">3.1.3.5.</span> <span class="nav-text">时序控制部件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E5%BD%A2%E6%88%90%E9%83%A8%E4%BB%B6"><span class="nav-number">3.1.3.6.</span> <span class="nav-text">微操作控制信号形成部件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="nav-number">3.1.3.7.</span> <span class="nav-text">中断机构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8PSR"><span class="nav-number">3.1.3.8.</span> <span class="nav-text">程序状态寄存器PSR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="nav-number">3.1.3.9.</span> <span class="nav-text">控制台</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.4.</span> <span class="nav-text">控制器的组成方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.2.</span> <span class="nav-text">控制器的控制方式与时序系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">同步控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%87%87%E7%94%A8%E4%B8%AD%E5%A4%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6%E7%9B%B8%E7%BB%93%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">(1) 采用中央控制与局部控制相结合的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%87%87%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%E5%92%8C%E5%BB%B6%E9%95%BF%E8%8A%82%E6%8B%8D%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">(2) 采用不同的机器周期和延长节拍的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%87%87%E7%94%A8%E5%88%86%E6%95%A3%E8%8A%82%E6%8B%8D%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">(3) 采用分散节拍的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">异步控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6"><span class="nav-number">3.2.3.</span> <span class="nav-text">联合控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E6%97%B6%E5%BA%8F%E7%9A%84%E8%A1%94%E6%8E%A5%E5%85%B3%E7%B3%BB"><span class="nav-number">3.2.4.</span> <span class="nav-text">同步异步时序的衔接关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.3.</span> <span class="nav-text">时序系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F"><span class="nav-number">3.3.1.</span> <span class="nav-text">指令周期与机器周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text">CPU总体结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.4.1.</span> <span class="nav-text">寄存器的设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="nav-number">3.4.2.</span> <span class="nav-text">数据通路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">3.4.3.</span> <span class="nav-text">指令流程分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%9C%BA%E7%9A%84%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.</span> <span class="nav-text">模型机的总体结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%9C%BA%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.1.</span> <span class="nav-text">模型机数据通路结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%9C%BA%E7%9A%84ALU%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">3.5.2.</span> <span class="nav-text">模型机的ALU的功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8E%9F%E7%90%86"><span class="nav-number">3.6.</span> <span class="nav-text">微程序控制器原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.1.</span> <span class="nav-text">常用的微指令编译方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">3.6.2.</span> <span class="nav-text">微程序的顺序控制方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MIPS%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="nav-number">3.7.</span> <span class="nav-text">MIPS数据通路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%91%A8%E6%9C%9F"><span class="nav-number">3.7.1.</span> <span class="nav-text">单周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F"><span class="nav-number">3.7.2.</span> <span class="nav-text">多周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RISC-V%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="nav-number">3.8.</span> <span class="nav-text">RISC-V数据通路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%91%A8%E6%9C%9F-1"><span class="nav-number">3.8.1.</span> <span class="nav-text">单周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F-1"><span class="nav-number">3.8.2.</span> <span class="nav-text">多周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF"><span class="nav-number">3.9.</span> <span class="nav-text">流水线处理技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">3.9.1.</span> <span class="nav-text">指令的执行方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%8F%A0%E6%96%B9%E5%BC%8F"><span class="nav-number">3.9.2.</span> <span class="nav-text">重叠方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E6%96%B9%E5%BC%8F"><span class="nav-number">3.10.</span> <span class="nav-text">流水方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.10.1.</span> <span class="nav-text">流水线的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">3.10.2.</span> <span class="nav-text">流水线的性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E7%8E%87"><span class="nav-number">3.10.2.1.</span> <span class="nav-text">吞吐率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%80%9F%E6%AF%94"><span class="nav-number">3.10.2.2.</span> <span class="nav-text">加速比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%88%E7%8E%87"><span class="nav-number">3.10.2.3.</span> <span class="nav-text">效率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">3.10.3.</span> <span class="nav-text">标准流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">3.10.4.</span> <span class="nav-text">高级流水线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%B5%81%E6%B0%B4%E6%8A%80%E6%9C%AF"><span class="nav-number">3.10.4.1.</span> <span class="nav-text">超流水技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97%E6%8A%80%E6%9C%AF"><span class="nav-number">3.10.4.2.</span> <span class="nav-text">超长指令字技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%A0%87%E9%87%8F%E6%8A%80%E6%9C%AF"><span class="nav-number">3.10.4.3.</span> <span class="nav-text">超标量技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.5.</span> <span class="nav-text">流水线的相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3%EF%BC%88%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9%EF%BC%89"><span class="nav-number">3.10.5.1.</span> <span class="nav-text">资源相关（结构冒险）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%EF%BC%88%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9%EF%BC%89"><span class="nav-number">3.10.5.2.</span> <span class="nav-text">数据相关（数据冒险）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E7%9B%B8%E5%85%B3%EF%BC%88%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9%EF%BC%89"><span class="nav-number">3.10.5.3.</span> <span class="nav-text">控制转移相关（控制冒险）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">机器指令格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%AD%97%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">4.2.</span> <span class="nav-text">指令字的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E7%A0%81"><span class="nav-number">4.3.</span> <span class="nav-text">指令地址码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">4.4.</span> <span class="nav-text">指令的寻址方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">4.5.</span> <span class="nav-text">操作数的寻址方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8A%9F%E8%83%BD"><span class="nav-number">4.6.</span> <span class="nav-text">指令类型及功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82"><span class="nav-number">4.6.1.</span> <span class="nav-text">基本要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O%E7%B3%BB%E7%BB%9F%E7%BB%84%E7%BB%87"><span class="nav-number">5.</span> <span class="nav-text">I&#x2F;O系统组织</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">5.1.</span> <span class="nav-text">I&#x2F;O系统的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">连接方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%81%93"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">通道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IOP"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">IOP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%81%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.2.</span> <span class="nav-text">I&#x2F;O信息传送的控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B1%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">由程序控制的数据传送</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B1%E4%B8%93%E6%9C%89%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">5.1.3.</span> <span class="nav-text">由专有硬件控制的数据传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">5.2.</span> <span class="nav-text">接口的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="nav-number">5.2.1.</span> <span class="nav-text">I&#x2F;O接口基本功能：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU%E5%92%8C%E5%A4%96%E8%AE%BE%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%81%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">5.2.2.</span> <span class="nav-text">CPU和外设之间传送的信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">数据信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">状态信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4%E4%BF%A1%E6%81%AF"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">控制命令信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.2.2.4.</span> <span class="nav-text">同步信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%80%89%E6%8B%A9%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.2.2.5.</span> <span class="nav-text">设备选择信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%8F%8ADMA%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="nav-number">5.2.2.6.</span> <span class="nav-text">中断及DMA控制逻辑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BC%A0%E9%80%81"><span class="nav-number">5.2.3.</span> <span class="nav-text">I&#x2F;O信息的传送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E7%AB%AF%E5%8F%A3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">5.2.4.</span> <span class="nav-text">I&#x2F;O端口寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E4%B8%BB%E5%AD%98%E7%BB%9F%E4%B8%80%E7%BC%96%E5%9D%80"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">与主存统一编址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E7%AB%AF%E5%8F%A3%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">I&#x2F;O端口独立编址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">5.2.5.</span> <span class="nav-text">I&#x2F;O接口的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%A0%BC%E5%BC%8F%E5%88%86"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">按数据传送格式分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E6%97%B6%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E5%88%86"><span class="nav-number">5.2.5.2.</span> <span class="nav-text">按时序的控制方式分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%81%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E5%88%86"><span class="nav-number">5.2.5.3.</span> <span class="nav-text">按信息传送交换的控制方式分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-number">5.2.6.</span> <span class="nav-text">接口基本组成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">程序控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text">直接程序控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">程序中断传送方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">中断机构的建立</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%BA%90%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.3.2.</span> <span class="nav-text">中断源设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-number">5.3.3.</span> <span class="nav-text">中断处理过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%BC%A0%E9%80%81"><span class="nav-number">5.3.4.</span> <span class="nav-text">中断请求信号的建立与传送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E8%AE%BE%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">外设发出请求中断信号的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">中断屏蔽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%88%A4%E4%BC%98"><span class="nav-number">5.3.4.3.</span> <span class="nav-text">中断判优</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU%E7%8E%B0%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%BA%8E%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E9%97%B4%E7%9A%84%E5%88%A4%E4%BC%98"><span class="nav-number">5.3.4.3.1.</span> <span class="nav-text">CPU现行程序于中断请求间的判优</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%92%E9%98%9F%E4%B8%8E%E5%88%A4%E4%BC%98"><span class="nav-number">5.3.4.3.2.</span> <span class="nav-text">中断请求之间的排队与判优</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94"><span class="nav-number">5.3.4.4.</span> <span class="nav-text">中断响应</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%AE%8C%E6%88%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.4.4.1.</span> <span class="nav-text">中断响应过程中应该完成的操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-number">5.3.4.5.</span> <span class="nav-text">中断服务程序入口地址的获取方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1"><span class="nav-number">5.3.4.6.</span> <span class="nav-text">中断服务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%B7%E5%A7%8B"><span class="nav-number">5.3.4.6.1.</span> <span class="nav-text">起始</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BD%93%E9%83%A8%E5%88%86"><span class="nav-number">5.3.4.6.2.</span> <span class="nav-text">主体部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E5%B0%BE"><span class="nav-number">5.3.4.6.3.</span> <span class="nav-text">结尾</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E7%9A%84%E5%8F%8A%E6%97%B6%E6%80%A7"><span class="nav-number">5.3.4.7.</span> <span class="nav-text">中断响应的及时性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">5.4.</span> <span class="nav-text">DMA的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E5%90%88"><span class="nav-number">5.4.1.</span> <span class="nav-text">DMA方式的特点与应用场合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%E7%9A%84%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F"><span class="nav-number">5.4.2.</span> <span class="nav-text">DMA的传送方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="nav-number">5.4.3.</span> <span class="nav-text">DMA的硬件组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E8%BF%87%E7%A8%8B"><span class="nav-number">5.4.4.</span> <span class="nav-text">DMA控制方式下的数据传送过程</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dai Ling"
      src="https://z3.ax1x.com/2021/05/06/glJAZd.png">
  <p class="site-author-name" itemprop="name">Dai Ling</p>
  <div class="site-description" itemprop="description">记录碎片</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dai Ling</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
