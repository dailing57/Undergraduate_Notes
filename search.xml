<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF Bitmask</title>
    <url>/2022/02/07/CF-Bitmask/</url>
    <content><![CDATA[<p>位运算的一些思维</p>
<span id="more"></span>

<h3 id="And-Matching"><a href="#And-Matching" class="headerlink" title="And Matching"></a><a href="https://codeforces.com/problemset/problem/1630/A">And Matching</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">3</span> &amp;&amp; n == <span class="number">4</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k != n - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; k &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (k) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ((n - <span class="number">1</span>) &amp; (~k)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                vis[<span class="number">0</span>] = vis[((n - <span class="number">1</span>) &amp; (~k))] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n - <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1 3\n&quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ((n - <span class="number">1</span>) &amp; (~<span class="number">3</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            vis[n - <span class="number">1</span>] = vis[n - <span class="number">2</span>] = vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = vis[<span class="number">3</span>] = vis[((n - <span class="number">1</span>) &amp; (~<span class="number">3</span>))] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[n - <span class="number">1</span>] = vis[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                vis[i] = vis[((n - <span class="number">1</span>) &amp; (~i))] = <span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ((n - <span class="number">1</span>) &amp; (~i)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AGAGA-XOOORRR"><a href="#AGAGA-XOOORRR" class="headerlink" title="AGAGA XOOORRR"></a><a href="https://codeforces.com/problemset/problem/1516/B">AGAGA XOOORRR</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], pre[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cin &gt;&gt; a[i], a[i] ^= a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">bool</span> fg = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] ==( a[n] ^ a[i]))</span><br><span class="line">                fg = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j, i+<span class="number">1</span>, n<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == (a[j] ^ a[i]) &amp;&amp; a[i] == (a[n] ^ a[j]))</span><br><span class="line">                    fg = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[n] == <span class="number">0</span>)</span><br><span class="line">            fg = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; (fg ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="And-It’s-Non-Zero"><a href="#And-It’s-Non-Zero" class="headerlink" title="And It’s Non-Zero"></a><a href="https://codeforces.com/problemset/problem/1615/B">And It’s Non-Zero</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll cnt[<span class="number">25</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">200001</span>) &#123;</span><br><span class="line">        ll t = i;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((t &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                cnt[j][i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[j][i] += cnt[j][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">20</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cnt[i][r] - cnt[i][l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; r - l + <span class="number">1</span> - ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Array-Elimination"><a href="#Array-Elimination" class="headerlink" title="Array Elimination"></a><a href="https://codeforces.com/problemset/problem/1601/A">Array Elimination</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m == <span class="number">0</span> ? n : <span class="built_in">gcd</span>(m, n % m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">cnt</span><span class="params">(<span class="number">31</span>)</span></span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            ll x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">29</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                    cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll g = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">29</span>) &#123;</span><br><span class="line">            g = <span class="built_in">gcd</span>(cnt[i], g);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g % i == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Co-growing-Sequence"><a href="#Co-growing-Sequence" class="headerlink" title="Co-growing Sequence"></a><a href="https://codeforces.com/problemset/problem/1547/D">Co-growing Sequence</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            ll t = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">29</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((a[i - <span class="number">1</span>] &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    t ^= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    a[i] ^= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Bitmask</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>CF DP</title>
    <url>/2022/02/03/CF-DP/</url>
    <content><![CDATA[<p>虽然CF的tag是1600~2000的dp，但是大部分还是一些思维构造</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">ll m[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            g[i].<span class="built_in">clear</span>();</span><br><span class="line">            m[i] = <span class="number">0</span>, d[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            ll k;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, k) &#123;</span><br><span class="line">                ll t;</span><br><span class="line">                cin &gt;&gt; t;</span><br><span class="line">                g[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">                d[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;ll&gt; q;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (d[i] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(i), m[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ll f = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[f]) &#123;</span><br><span class="line">                d[to]--;</span><br><span class="line">                <span class="keyword">if</span> (d[to] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                <span class="keyword">if</span> (to &lt; f) &#123;</span><br><span class="line">                    m[to] = <span class="built_in">max</span>(m[to], m[f] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    m[to] = <span class="built_in">max</span>(m[to], m[f]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll fg = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span> (d[i]) fg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fg) &#123;</span><br><span class="line">            ll ans = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, m[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Book"><a href="#Book" class="headerlink" title="Book"></a><a href="https://codeforces.com/problemset/problem/1572/A">Book</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">ll m[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            g[i].<span class="built_in">clear</span>();</span><br><span class="line">            m[i] = <span class="number">0</span>, d[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            ll k;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, k) &#123;</span><br><span class="line">                ll t;</span><br><span class="line">                cin &gt;&gt; t;</span><br><span class="line">                g[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">                d[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;ll&gt; q;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (d[i] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(i), m[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ll f = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[f]) &#123;</span><br><span class="line">                d[to]--;</span><br><span class="line">                <span class="keyword">if</span> (d[to] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                <span class="keyword">if</span> (to &lt; f) &#123;</span><br><span class="line">                    m[to] = <span class="built_in">max</span>(m[to], m[f] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    m[to] = <span class="built_in">max</span>(m[to], m[f]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll fg = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span> (d[i]) fg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fg) &#123;</span><br><span class="line">            ll ans = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, m[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Up-the-Strip"><a href="#Up-the-Strip" class="headerlink" title="Up the Strip"></a><a href="https://codeforces.com/contest/1561/problem/D2">Up the Strip</a></h3><p>$$<br>dp[i]=\sum_{j=i+1}^{n} (dp[j]+\sum_{k=2}^{j} [j/k==i]dp[j])<br>$$</p>
<p>满足 $j/k==i$ 的 $k$ 是连续的，并且，可以观察出$k \in [i<em>j, i</em>j+j-1]$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e6</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll dp[N], sum[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i] += dp[j]     j/k == i i+1 &lt;= j &lt;= n</span></span><br><span class="line"><span class="comment">dp[i] += dp[k]     i+1&lt;=k&lt;=n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    dp[n] = <span class="number">1</span>, sum[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dec</span>(i, n<span class="number">-1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i] = (dp[i] + sum[i + <span class="number">1</span>]) % m;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">            ll r = <span class="built_in">min</span>(n, i * j + j - <span class="number">1</span>);</span><br><span class="line">            dp[i] = (dp[i] + sum[i * j] - sum[r + <span class="number">1</span>]) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[i] = (sum[i+<span class="number">1</span>] + dp[i]) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Moamen-and-XOR"><a href="#Moamen-and-XOR" class="headerlink" title="Moamen and XOR"></a><a href="https://codeforces.com/problemset/problem/1557/C">Moamen and XOR</a></h3><p>从高位往低位考虑不好想，从低位往高位考虑。</p>
<p>对于每一位，从该位上取大于 还是 取等于分开考虑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll dp[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x, ll k)</span> </span>&#123;</span><br><span class="line">    ll t = x, res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * t % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        t = t * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]*(<span class="number">1</span> + <span class="built_in">qpow</span>(<span class="number">2</span>,n<span class="number">-1</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">                dp[i] = (dp[i - <span class="number">1</span>] * (<span class="built_in">qpow</span>(<span class="number">2</span>, n - <span class="number">1</span>) - <span class="number">1</span>) % mod + <span class="built_in">qpow</span>(<span class="built_in">qpow</span>(<span class="number">2</span>, n), i<span class="number">-1</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[k] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Say-No-to-Palindromes"><a href="#Say-No-to-Palindromes" class="headerlink" title="Say No to Palindromes"></a><a href="https://codeforces.com/problemset/problem/1555/D">Say No to Palindromes</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll b[<span class="number">6</span>][N], a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        a[i] = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; t = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; p;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        p.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            b[i][j] = b[i][j<span class="number">-1</span>] + (p[i][(j<span class="number">-1</span>) % <span class="number">3</span>]!=a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        ll l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        ll ans = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">5</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, b[i][r] - b[i][l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Array-Differentiation"><a href="#Array-Differentiation" class="headerlink" title="Array Differentiation"></a><a href="https://codeforces.com/problemset/problem/1552/D">Array Differentiation</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">ll n;</span><br><span class="line">map&lt;ll, ll&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x,ll tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) &#123;</span><br><span class="line">        mp[tot]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>, tot + a[x]);</span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>, tot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ll fg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: mp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.second &gt; <span class="number">1</span>)</span><br><span class="line">                fg = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (fg ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fixed-Points"><a href="#Fixed-Points" class="headerlink" title="Fixed Points"></a><a href="https://codeforces.com/problemset/problem/1551/E">Fixed Points</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n)</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, i)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, i) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(&#123; dp[i][j],dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (j == a[i]) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dec</span>(i, n, k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n][i]&gt;=k)&#123;</span><br><span class="line">                ans = n - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Erase-and-Extend-Hard-Version"><a href="#Erase-and-Extend-Hard-Version" class="headerlink" title="Erase and Extend (Hard Version)"></a><a href="https://codeforces.com/contest/1537/problem/E2">Erase and Extend (Hard Version)</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    ll len = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; s[i % len])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &lt; s[i % len])</span><br><span class="line">            len = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, k<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; s[i % len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Playoff-Tournament"><a href="#Playoff-Tournament" class="headerlink" title="Playoff Tournament"></a><a href="https://codeforces.com/problemset/problem/1535/D">Playoff Tournament</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, k, tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[x] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        tr[x] = tr[x * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        tr[x] = tr[x * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        tr[x] = tr[x * <span class="number">2</span>] + tr[x * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll l,ll r,ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tr[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l, mid, p * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid + <span class="number">1</span>, r, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll k, n;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    n = (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + <span class="number">1</span> , s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    ll q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll p;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; c;</span><br><span class="line">        p = n - p;</span><br><span class="line">        s[p] = c;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="built_in">pushup</span>(p);</span><br><span class="line">            p /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; tr[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Make-Them-Equal"><a href="#Make-Them-Equal" class="headerlink" title="Make Them Equal"></a><a href="https://codeforces.com/problemset/problem/1633/D">Make Them Equal</a></h3><p><del>脑抽了，表演乱日</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll b[<span class="number">1005</span>], c[<span class="number">1005</span>], d[<span class="number">1005</span>], dp[<span class="number">1005</span>][<span class="number">10005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll b, c;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.c / a.b &gt; b.c / b.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, i) &#123;</span><br><span class="line">            ll t = i + i / j;</span><br><span class="line">            <span class="keyword">if</span> (t &lt;= <span class="number">1000</span>)</span><br><span class="line">                d[t] = <span class="built_in">min</span>(d[t], d[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        vector&lt;node&gt; v;</span><br><span class="line">        ll x, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cin &gt;&gt; x, b[i] = d[x];</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cin &gt;&gt; c[i];   </span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[i] == <span class="number">0</span>)</span><br><span class="line">                ans += c[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v.<span class="built_in">push_back</span>(&#123; b[i],c[i] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        ll pos = <span class="number">0</span>,sz = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(;pos&lt;sz;pos++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= <span class="number">10000</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            k -= v[pos].b;</span><br><span class="line">            ans += v[pos].c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == sz) &#123;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[<span class="number">0</span>].b &lt;= k)</span><br><span class="line">                dp[<span class="number">0</span>][v[<span class="number">0</span>].b] = v[<span class="number">0</span>].c;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, pos, sz<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">dec</span>(j, k, <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= v[i].b)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - v[i].b] + v[i].c);</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll maxn = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, dp[sz<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; maxn + ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Infinite-Set"><a href="#Infinite-Set" class="headerlink" title=" Infinite Set"></a><a href="https://codeforces.com/contest/1635/problem/D"> Infinite Set</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], cnt[N], dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll n, p;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cin &gt;&gt; a[i]; &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  set&lt;ll&gt; st;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    ll x = a[i];</span><br><span class="line">    <span class="keyword">bool</span> fg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (st.<span class="built_in">count</span>(x)) &#123;</span><br><span class="line">        fg = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &amp; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fg) st.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : st) &#123;</span><br><span class="line">    cnt[__lg(x)]++;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">0</span>, p - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">30</span>) dp[i] = cnt[i];</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">      dp[i] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">      dp[i] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans + dp[i]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 速度练习</title>
    <url>/2022/02/13/CF-%E9%80%9F%E5%BA%A6%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>一些构造题目</p>
<span id="more"></span>

<h3 id="Not-Assigning"><a href="#Not-Assigning" class="headerlink" title="Not Assigning"></a><a href="https://codeforces.com/problemset/problem/1627/C">Not Assigning</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll d[N];</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">map&lt;pll,ll&gt; mp;</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x, ll fa)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> to:g[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa == to) <span class="keyword">continue</span>;</span><br><span class="line">        mp[&#123;to,x&#125;] = ((cnt&amp;<span class="number">1</span>)?<span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line">        mp[&#123;x,to&#125;] = ((cnt&amp;<span class="number">1</span>)?<span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pll&gt; arr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        mp.<span class="built_in">clear</span>(),arr.<span class="built_in">clear</span>(),cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) d[i] = <span class="number">0</span>,g[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            ll u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            d[u]++,d[v]++;</span><br><span class="line">            g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">            g[v].<span class="built_in">pb</span>(u);</span><br><span class="line">            arr.<span class="built_in">pb</span>(&#123;u,v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> fg = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]&gt;<span class="number">2</span>)</span><br><span class="line">                fg = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fg)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;mp[arr[i]]&lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Palindromes-Coloring"><a href="#Palindromes-Coloring" class="headerlink" title="Palindromes Coloring"></a><a href="https://codeforces.com/problemset/problem/1624/D">Palindromes Coloring</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="keyword">char</span>, ll&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">      mp[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll c0 = <span class="number">0</span>, c1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : mp) &#123;</span><br><span class="line">      c0 += x.se / <span class="number">2</span>;</span><br><span class="line">      c1 += x.se % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="number">2</span> * (c0 / k);</span><br><span class="line">    c1 += <span class="number">2</span> * (c0 % k);</span><br><span class="line">    <span class="keyword">if</span> (c1 &gt;= k) ans++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hidden-Permutations"><a href="#Hidden-Permutations" class="headerlink" title="Hidden Permutations"></a><a href="https://codeforces.com/problemset/problem/1621/C">Hidden Permutations</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll i)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  ll x;</span><br><span class="line">  cin &gt;&gt; x;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        ll tot = <span class="built_in">ask</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!vis[tot]) &#123;</span><br><span class="line">          vis[tot] = <span class="number">1</span>;</span><br><span class="line">          ans[tot] = <span class="built_in">ask</span>(i);</span><br><span class="line">          tot = ans[tot];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;! &quot;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout.<span class="built_in">flush</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Integers-Shop"><a href="#Integers-Shop" class="headerlink" title="Integers Shop"></a><a href="https://codeforces.com/problemset/problem/1621/B">Integers Shop</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> A = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> minL = A, costL = A;</span><br><span class="line">  <span class="keyword">int</span> maxR = <span class="number">0</span>, costR = A;</span><br><span class="line">  <span class="keyword">int</span> maxLen = <span class="number">0</span>, costLen = A;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, c;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; minL) minL = l, costL = A;</span><br><span class="line">    <span class="keyword">if</span> (l == minL) costL = <span class="built_in">min</span>(costL, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxR &lt; r) maxR = r, costR = A;</span><br><span class="line">    <span class="keyword">if</span> (maxR == r) costR = <span class="built_in">min</span>(costR, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxLen &lt; r - l + <span class="number">1</span>) maxLen = r - l + <span class="number">1</span>, costLen = A;</span><br><span class="line">    <span class="keyword">if</span> (maxLen == r - l + <span class="number">1</span>) costLen = <span class="built_in">min</span>(costLen, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = costL + costR;</span><br><span class="line">    <span class="keyword">if</span> (maxLen == maxR - minL + <span class="number">1</span>) ans = <span class="built_in">min</span>(ans, costLen);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Singers’-Tour"><a href="#Singers’-Tour" class="headerlink" title=" Singers’ Tour"></a><a href="https://codeforces.com/problemset/problem/1618/E"> Singers’ Tour</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">      sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[n + <span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    ll d = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum % d != <span class="number">0</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum /= d;</span><br><span class="line">    <span class="keyword">bool</span> fg = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line">      ans[i] = (sum - (a[i] - a[i - <span class="number">1</span>]));</span><br><span class="line">      <span class="keyword">if</span> (ans[i] % n != <span class="number">0</span> || ans[i] &lt;= <span class="number">0</span>) fg = <span class="number">0</span>;</span><br><span class="line">      ans[i] /= n;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = ans[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (fg) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">      <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line">      cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Too-Many-Impostors-easy-version"><a href="#Too-Many-Impostors-easy-version" class="headerlink" title="Too Many Impostors (easy version)"></a><a href="https://codeforces.com/problemset/problem/1617/D1">Too Many Impostors (easy version)</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll a, ll b, ll c)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  ll x;</span><br><span class="line">  cin &gt;&gt; x;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; a[i] = <span class="built_in">ask</span>(i, i % n + <span class="number">1</span>, (i + <span class="number">1</span>) % n + <span class="number">1</span>); &#125;</span><br><span class="line">    ll u, v;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] != a[i % n + <span class="number">1</span>]) &#123;</span><br><span class="line">        res[i] = a[i];</span><br><span class="line">        res[(i + <span class="number">2</span>) % n + <span class="number">1</span>] = !res[i];</span><br><span class="line">        u = i, v = (i + <span class="number">2</span>) % n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll k = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i != v &amp;&amp; i != u) &#123;</span><br><span class="line">        res[i] = <span class="built_in">ask</span>(u, v, i);</span><br><span class="line">        <span class="keyword">if</span> (!res[i]) k++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!res[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Moderate-Modular-Mode"><a href="#Moderate-Modular-Mode" class="headerlink" title="Moderate Modular Mode"></a><a href="https://codeforces.com/problemset/problem/1603/B">Moderate Modular Mode</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">      cout &lt;&lt; x + y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; y - y % x / <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Omkar-and-the-Meaning-of-Life"><a href="#Omkar-and-the-Meaning-of-Life" class="headerlink" title="Omkar and the Meaning of Life"></a><a href="https://codeforces.com/problemset/problem/1583/D">Omkar and the Meaning of Life</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;? &quot;</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cout &lt;&lt; <span class="number">1</span> + (i == x) &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  ll t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask2</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;? &quot;</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cout &lt;&lt; <span class="number">2</span> - (i == x) &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  ll t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  ll pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    ll k = <span class="built_in">ask1</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) ans[i] = n, pos = i;</span><br><span class="line">    <span class="keyword">if</span> (k &amp;&amp; i != k) a[k] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    ll k = <span class="built_in">ask2</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (k &amp;&amp; i != k) a[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  ll t = n;</span><br><span class="line">  <span class="keyword">while</span> (t) &#123;</span><br><span class="line">    ans[pos] = t;</span><br><span class="line">    pos = a[pos];</span><br><span class="line">    t--;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;! &quot;</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sweepstake"><a href="#Sweepstake" class="headerlink" title="Sweepstake"></a><a href="https://codeforces.com/problemset/problem/1571/D">Sweepstake</a></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (n,m) = readLine()!!.split(<span class="string">&#x27; &#x27;</span>).map&#123; it.toInt()&#125;</span><br><span class="line">    <span class="keyword">val</span> cp = Array(n+<span class="number">1</span>) &#123;IntArray(n+<span class="number">1</span>)&#123;<span class="number">0</span>&#125; &#125;</span><br><span class="line">    <span class="keyword">val</span> cl = IntArray(n+<span class="number">1</span>)&#123;<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">val</span> cr = IntArray(n+<span class="number">1</span>)&#123;<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">val</span> fi = readLine()!!.split(<span class="string">&#x27; &#x27;</span>).map&#123;it.toInt()&#125;</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">2.</span>.m)&#123;</span><br><span class="line">        <span class="keyword">val</span> (l,r) = readLine()!!.split(<span class="string">&#x27; &#x27;</span>).map &#123; it.toInt() &#125;</span><br><span class="line">        cp[l][r]++</span><br><span class="line">        cl[l]++</span><br><span class="line">        cr[r]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">I</span><span class="params">(x: <span class="type">Boolean</span>)</span></span> = <span class="keyword">if</span>(x) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(l <span class="keyword">in</span> <span class="number">1.</span>.n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(r <span class="keyword">in</span> <span class="number">1.</span>.n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == r) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">val</span> s = I(l == fi[<span class="number">0</span>]) + I(r==fi[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">var</span> tmp = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(s&lt;<span class="number">2</span>)</span><br><span class="line">                tmp += cp[l][r]</span><br><span class="line">            <span class="keyword">if</span>(s&lt;<span class="number">1</span>)</span><br><span class="line">                tmp += cl[l] + cr[r] - <span class="number">2</span>*cp[l][r]</span><br><span class="line">            ans = maxOf(ans,tmp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vupsen-Pupsen-and-0"><a href="#Vupsen-Pupsen-and-0" class="headerlink" title=" Vupsen, Pupsen and 0"></a><a href="https://codeforces.com/problemset/problem/1582/D"> Vupsen, Pupsen and 0</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N];</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; sum += b[i] * a[i]; &#125;</span><br><span class="line">  <span class="keyword">if</span> (sum == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cin &gt;&gt; a[i]; &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ll tmp = a[<span class="number">1</span>] + a[<span class="number">2</span>];</span><br><span class="line">      b[<span class="number">1</span>] = a[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">if</span> (tmp == <span class="number">0</span>) tmp = a[<span class="number">1</span>] * <span class="number">2</span> + a[<span class="number">2</span>],b[<span class="number">1</span>] = <span class="number">2</span>*a[<span class="number">3</span>];</span><br><span class="line">      b[<span class="number">2</span>] = a[<span class="number">3</span>];</span><br><span class="line">      b[<span class="number">3</span>] = -tmp;</span><br><span class="line">      <span class="keyword">for</span> (ll i = <span class="number">4</span>; i &lt;= n - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        b[i] = a[i + <span class="number">1</span>];</span><br><span class="line">        b[i + <span class="number">1</span>] = -a[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        b[i] = a[i + <span class="number">1</span>];</span><br><span class="line">        b[i + <span class="number">1</span>] = -a[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cout &lt;&lt; b[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Take-a-Guess"><a href="#Take-a-Guess" class="headerlink" title="Take a Guess"></a><a href="https://codeforces.com/problemset/problem/1556/D">Take a Guess</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;and &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  ll t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask2</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;or &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  ll t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll n, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  ll t1 = <span class="built_in">ask1</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">ask2</span>(<span class="number">1</span>, <span class="number">2</span>), t2 = <span class="built_in">ask1</span>(<span class="number">2</span>, <span class="number">3</span>) + <span class="built_in">ask2</span>(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">     t3 = <span class="built_in">ask1</span>(<span class="number">1</span>, <span class="number">3</span>) + <span class="built_in">ask2</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  a[<span class="number">1</span>] = t1 - t2 + t3;</span><br><span class="line">  a[<span class="number">1</span>] /= <span class="number">2</span>;</span><br><span class="line">  a[<span class="number">3</span>] = t3 - a[<span class="number">1</span>];</span><br><span class="line">  a[<span class="number">2</span>] = t2 - a[<span class="number">3</span>];</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">4</span>, n) &#123;</span><br><span class="line">    ll tmp = <span class="built_in">ask1</span>(<span class="number">1</span>, i) + <span class="built_in">ask2</span>(<span class="number">1</span>, i);</span><br><span class="line">    a[i] = tmp - a[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;finish &quot;</span>;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; a[k];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Diane"><a href="#Diane" class="headerlink" title="Diane"></a><a href="https://codeforces.com/problemset/problem/1554/D">Diane</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;a\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;ab\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;abc\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">rep</span>(i, <span class="number">1</span>, n / <span class="number">2</span> - <span class="number">1</span>) &#123; cout &lt;&lt; <span class="string">&#x27;b&#x27;</span>; &#125;</span><br><span class="line">      cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="built_in">rep</span>(i, <span class="number">1</span>, n / <span class="number">2</span>) &#123; cout &lt;&lt; <span class="string">&#x27;b&#x27;</span>; &#125;</span><br><span class="line">      <span class="keyword">if</span> (n &amp; <span class="number">1</span>) cout &lt;&lt; <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">      cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maximize-the-Intersections"><a href="#Maximize-the-Intersections" class="headerlink" title="Maximize the Intersections"></a><a href="https://codeforces.com/problemset/problem/1552/C">Maximize the Intersections</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(pll a, pll b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.fi &gt; b.fi) <span class="built_in">swap</span>(a, b);</span><br><span class="line">  <span class="keyword">return</span> b.fi &lt; a.se &amp;&amp; b.se &gt; a.se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;pll&gt; a;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(<span class="number">2</span>*n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">      ll u, v;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">      <span class="keyword">if</span> (u &gt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">      a.<span class="built_in">pb</span>(&#123;u, v&#125;);</span><br><span class="line">      vis[u] = vis[v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; b;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">2</span> * n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[i]) b.<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n - k - <span class="number">1</span>) &#123; a.<span class="built_in">pb</span>(&#123;b[i], b[i + n - k]&#125;); &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">rep</span>(j, i + <span class="number">1</span>, n - <span class="number">1</span>) &#123; ans += <span class="built_in">check</span>(a[i], a[j]); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Domino-easy-version"><a href="#Domino-easy-version" class="headerlink" title="Domino (easy version)"></a><a href="https://codeforces.com/problemset/problem/1551/D1">Domino (easy version)</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n, m, h, v;</span><br><span class="line">    <span class="keyword">bool</span> fg = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;</span><br><span class="line">    v = n * m / <span class="number">2</span> - h;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      h -= m / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (h &lt; <span class="number">0</span>) fg = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      v -= n / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (v &lt; <span class="number">0</span>) fg = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((v &amp; <span class="number">1</span>) || (h &amp; <span class="number">1</span>)) fg = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; (fg ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Another-Problem-About-Dividing-Numbers"><a href="#Another-Problem-About-Dividing-Numbers" class="headerlink" title=" Another Problem About Dividing Numbers"></a><a href="https://codeforces.com/problemset/problem/1538/D"> Another Problem About Dividing Numbers</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; pri;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">2</span>, N - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      pri.<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : pri) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * x &gt; N) <span class="keyword">break</span>;</span><br><span class="line">      vis[i * x] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % x == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getsize</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">0</span>; pri[i] * pri[i] &lt;= x; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (x % pri[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      x /= pri[i];</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="number">1</span>) cnt++;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">sieve</span>();</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll a, b, k;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span> ((a == b || __gcd(a, b) != <span class="built_in">min</span>(a, b)) &amp;&amp; k == <span class="number">1</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="built_in">getsize</span>(a) + <span class="built_in">getsize</span>(b))</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RPD-and-Rap-Sheet-Hard-Version"><a href="#RPD-and-Rap-Sheet-Hard-Version" class="headerlink" title="RPD and Rap Sheet (Hard Version)"></a><a href="https://codeforces.com/contest/1543/problem/D2">RPD and Rap Sheet (Hard Version)</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout.<span class="built_in">flush</span>();</span><br><span class="line">  ll t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">ll n, k;</span><br><span class="line"><span class="function">ll <span class="title">knxor</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  ll z = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (a &gt; <span class="number">0</span> || b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ll x = a % k;</span><br><span class="line">    a = a / k;</span><br><span class="line">    ll y = b % k;</span><br><span class="line">    b = b / k;</span><br><span class="line">    ll c = (x - y + k) % k;</span><br><span class="line">    z = z + p * c;</span><br><span class="line">    p *= k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">      ll t = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        t = <span class="built_in">ask</span>(<span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        t = <span class="built_in">ask</span>(<span class="built_in">knxor</span>(i, i - <span class="number">1</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t = <span class="built_in">ask</span>(<span class="built_in">knxor</span>(i - <span class="number">1</span>, i));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Secret-Santa"><a href="#Secret-Santa" class="headerlink" title="Secret Santa"></a><a href="https://codeforces.com/problemset/problem/1530/D">Secret Santa</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    set&lt;ll&gt; st;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">      <span class="keyword">if</span> (a[i] != i &amp;&amp; !st.<span class="built_in">count</span>(a[i])) ans++, st.<span class="built_in">insert</span>(a[i]), v[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; h, <span class="built_in">b</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!st.<span class="built_in">count</span>(i)) h.<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!v[i]) v[i] = h[tot++];</span><br><span class="line">      <span class="keyword">if</span> (v[i] == i) <span class="built_in">swap</span>(v[i], v[b[a[i]]]);</span><br><span class="line">      b[v[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Baby-Ehab-Partitions-Again"><a href="#Baby-Ehab-Partitions-Again" class="headerlink" title="Baby Ehab Partitions Again"></a><a href="https://codeforces.com/problemset/problem/1516/C">Baby Ehab Partitions Again</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">bool</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll n, sum = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    sum += a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="built_in">dec</span>(j, <span class="number">200000</span> - a[i], <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dp[j]) dp[j + a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(sum &amp; <span class="number">1</span>) &amp;&amp; dp[sum / <span class="number">2</span>]) &#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((a[i]&amp;<span class="number">1</span>) || !dp[(sum - a[i]) / <span class="number">2</span>]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1\n&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Balance-the-Bits"><a href="#Balance-the-Bits" class="headerlink" title="Balance the Bits"></a><a href="https://codeforces.com/problemset/problem/1503/A">Balance the Bits</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n - <span class="number">1</span>) &#123; cnt += s[i] == <span class="string">&#x27;1&#x27;</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s[n] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; cnt % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">      <span class="function">string <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">      a[<span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span>, a[n] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">      b[<span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span>, b[n] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">      <span class="keyword">char</span> cur = <span class="string">&#x27;(&#x27;</span>, tmp = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">      <span class="built_in">rep</span>(i, <span class="number">2</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">          a[i] = cur;</span><br><span class="line">          b[i] = cur;</span><br><span class="line">          <span class="keyword">if</span> (cur == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            cur = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            cur = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          a[i] = tmp;</span><br><span class="line">          <span class="keyword">if</span> (tmp == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            tmp = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            tmp = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">          b[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; a.<span class="built_in">c_str</span>() + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      cout &lt;&lt; b.<span class="built_in">c_str</span>() + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Diplomacy"><a href="#Basic-Diplomacy" class="headerlink" title="Basic Diplomacy"></a><a href="https://codeforces.com/problemset/problem/1482/C">Basic Diplomacy</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(m + <span class="number">1</span>)</span>, <span class="title">a</span><span class="params">(m + <span class="number">1</span>, <span class="number">-1</span>)</span>, <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    ll pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">      ll k, x;</span><br><span class="line">      cin &gt;&gt; k &gt;&gt; ans[i];</span><br><span class="line">      cnt[ans[i]]++;</span><br><span class="line">      <span class="keyword">if</span> (cnt[ans[i]] &gt; (m + <span class="number">1</span>) / <span class="number">2</span>) pos = ans[i];</span><br><span class="line">      <span class="built_in">rep</span>(j, <span class="number">2</span>, k) &#123; cin &gt;&gt; a[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == pos &amp;&amp; a[i] != <span class="number">-1</span> &amp;&amp; cnt[pos] &gt; (m + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">          ans[i] = a[i], cnt[pos]--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cnt[pos] &gt; (m + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == m];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fence-Painting"><a href="#Fence-Painting" class="headerlink" title=" Fence Painting"></a><a href="https://codeforces.com/problemset/problem/1481/C"> Fence Painting</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N], c[N], las[N];</span><br><span class="line">vector&lt;ll&gt; pos[N], t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) pos[i].<span class="built_in">clear</span>(), t[i].<span class="built_in">clear</span>(), las[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      cin &gt;&gt; b[i];</span><br><span class="line">      <span class="keyword">if</span> (b[i] != a[i]) &#123;</span><br><span class="line">        pos[b[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t[b[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      las[b[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">      cin &gt;&gt; c[i];</span><br><span class="line">      <span class="keyword">if</span> (!pos[c[i]].<span class="built_in">empty</span>())</span><br><span class="line">        ans[i] = pos[c[i]].<span class="built_in">back</span>(), pos[c[i]].<span class="built_in">pop_back</span>();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!t[c[i]].<span class="built_in">empty</span>())</span><br><span class="line">        ans[i] = t[c[i]].<span class="built_in">back</span>();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ans[i] = las[c[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dec</span>(i, m - <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">if</span> (ans[i] == <span class="number">0</span>) ans[i] = ans[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) a[ans[i]] = c[i];</span><br><span class="line">    <span class="keyword">bool</span> fg = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="keyword">if</span> (a[i] != b[i]) fg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fg || ans[m] == <span class="number">0</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == m];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Extreme-Subtraction"><a href="#Extreme-Subtraction" class="headerlink" title=" Extreme Subtraction"></a><a href="https://codeforces.com/problemset/problem/1442/A"> Extreme Subtraction</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cin &gt;&gt; v[i]; &#125;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    a[<span class="number">1</span>] = v[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">      a[i] = <span class="built_in">min</span>(a[i - <span class="number">1</span>], v[i] - b[i - <span class="number">1</span>]);</span><br><span class="line">      b[i] = v[i] - a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> fg = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) <span class="keyword">if</span> (a[i] &gt; a[i - <span class="number">1</span>] || a[i] &lt; <span class="number">0</span>) fg = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) <span class="keyword">if</span> (b[i] &lt; b[i - <span class="number">1</span>] || b[i] &lt; <span class="number">0</span>) fg = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; (fg ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stoned-Game"><a href="#Stoned-Game" class="headerlink" title=" Stoned Game"></a><a href="https://codeforces.com/problemset/problem/1396/B"> Stoned Game</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll n, sum = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i], sum += a[i];</span><br><span class="line">  <span class="keyword">bool</span> fg = sum % <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; sum / <span class="number">2</span>) &#123;</span><br><span class="line">      fg = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; (fg ? <span class="string">&quot;T&quot;</span> : <span class="string">&quot;HL&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>速度练习</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>DP-Sequences</title>
    <url>/2021/05/11/DP-Sequences/</url>
    <content><![CDATA[<h1 id="DP中的序列问题"><a href="#DP中的序列问题" class="headerlink" title="DP中的序列问题"></a>DP中的序列问题</h1><p>最长不降子序列，最长公共子序列</p>
<span id="more"></span>

<h2 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100005</span>],a,t,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; f[t])</span><br><span class="line">            f[++t] = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *<span class="built_in">lower_bound</span>(f + <span class="number">1</span>,f + t + <span class="number">1</span>,a) = a;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin practice</title>
    <url>/2022/02/20/kotlin-practice/</url>
    <content><![CDATA[<p>kotlin的一些练习</p>
<span id="more"></span>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (n,m) = readLine()!!.split(<span class="string">&#x27; &#x27;</span>).map&#123; it.toInt()&#125;</span><br><span class="line">    <span class="keyword">val</span> cp = Array(n+<span class="number">1</span>) &#123;IntArray(n+<span class="number">1</span>)&#123;<span class="number">0</span>&#125; &#125;</span><br><span class="line">    <span class="keyword">val</span> cl = IntArray(n+<span class="number">1</span>)&#123;<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">val</span> cr = IntArray(n+<span class="number">1</span>)&#123;<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">val</span> fi = readLine()!!.split(<span class="string">&#x27; &#x27;</span>).map&#123;it.toInt()&#125;</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">2.</span>.m)&#123;</span><br><span class="line">        <span class="keyword">val</span> (l,r) = readLine()!!.split(<span class="string">&#x27; &#x27;</span>).map &#123; it.toInt() &#125;</span><br><span class="line">        cp[l][r]++</span><br><span class="line">        cl[l]++</span><br><span class="line">        cr[r]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">I</span><span class="params">(x: <span class="type">Boolean</span>)</span></span> = <span class="keyword">if</span>(x) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(l <span class="keyword">in</span> <span class="number">1.</span>.n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(r <span class="keyword">in</span> <span class="number">1.</span>.n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == r) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">val</span> s = I(l == fi[<span class="number">0</span>]) + I(r==fi[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">var</span> tmp = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(s&lt;<span class="number">2</span>)</span><br><span class="line">                tmp += cp[l][r]</span><br><span class="line">            <span class="keyword">if</span>(s&lt;<span class="number">1</span>)</span><br><span class="line">                tmp += cl[l] + cr[r] - <span class="number">2</span>*cp[l][r]</span><br><span class="line">            ans = maxOf(ans,tmp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>图论-网络流</title>
    <url>/2021/07/25/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="Hungary"><a href="#Hungary" class="headerlink" title="Hungary"></a>Hungary</h1><span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> M, N;            <span class="comment">//M, N分别表示左、右侧集合的元素数量</span></span><br><span class="line"><span class="keyword">int</span> Map[MAXM][MAXN]; <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="keyword">int</span> p[MAXN];         <span class="comment">//记录当前右侧元素所对应的左侧元素</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];      <span class="comment">//记录右侧元素是否已被访问过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Map[i][j] &amp;&amp; !vis[j]) <span class="comment">//有边且未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;                <span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="number">0</span> || <span class="built_in">match</span>(p[j])) <span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[j] = i;    <span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis)); <span class="comment">//重置vis数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络流-P3376"><a href="#网络流-P3376" class="headerlink" title="网络流 P3376"></a>网络流 <a href="https://www.luogu.com.cn/problem/P3376">P3376</a></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlowEdge</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v, u;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cap, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FlowEdge</span>(<span class="keyword">int</span> v, <span class="keyword">int</span> u, <span class="keyword">long</span> <span class="keyword">long</span> cap) : <span class="built_in">v</span>(v), <span class="built_in">u</span>(u), <span class="built_in">cap</span>(cap) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> flow_inf = <span class="number">1e18</span>;</span><br><span class="line">    vector&lt;FlowEdge&gt; edges;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="keyword">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; level, ptr;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Dinic</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> s, <span class="keyword">int</span> t) : <span class="built_in">n</span>(n), <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;</span><br><span class="line">        adj.<span class="built_in">resize</span>(n);</span><br><span class="line">        level.<span class="built_in">resize</span>(n);</span><br><span class="line">        ptr.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> u, <span class="keyword">long</span> <span class="keyword">long</span> cap)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(v, u, cap);</span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(u, v, <span class="number">0</span>);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(m);</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(m + <span class="number">1</span>);</span><br><span class="line">        m += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> id : adj[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[id].cap - edges[id].flow &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (level[edges[id].u] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                level[edges[id].u] = level[v] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(edges[id].u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level[t] != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">long</span> <span class="keyword">long</span> pushed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (v == t) <span class="keyword">return</span> pushed;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; cid = ptr[v]; cid &lt; (<span class="keyword">int</span>)adj[v].<span class="built_in">size</span>(); cid++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = adj[v][cid];</span><br><span class="line">            <span class="keyword">int</span> u = edges[id].u;</span><br><span class="line">            <span class="keyword">if</span> (level[v] + <span class="number">1</span> != level[u] || edges[id].cap - edges[id].flow &lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tr = <span class="built_in">dfs</span>(u, <span class="built_in">min</span>(pushed, edges[id].cap - edges[id].flow));</span><br><span class="line">            <span class="keyword">if</span> (tr == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            edges[id].flow += tr;</span><br><span class="line">            edges[id ^ <span class="number">1</span>].flow -= tr;</span><br><span class="line">            <span class="keyword">return</span> tr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">fill</span>(level.<span class="built_in">begin</span>(), level.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">            level[s] = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(s);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">bfs</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">fill</span>(ptr.<span class="built_in">begin</span>(), ptr.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">long</span> <span class="keyword">long</span> pushed = <span class="built_in">dfs</span>(s, flow_inf)) &#123;</span><br><span class="line">                f += pushed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="KM-P6577"><a href="#KM-P6577" class="headerlink" title="KM P6577"></a>KM <a href="https://www.luogu.com.cn/problem/P6577">P6577</a></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line">ll inf = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, n, m, a[N][N], pre[N], match[N], slack[N], ex[N], ey[N], vx[N], vy[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> x, y = <span class="number">0</span>, yy = <span class="number">0</span>, del;</span><br><span class="line">	<span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) slack[i] = inf;</span><br><span class="line">	match[y] = u;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		x = match[y]; del = inf; vy[y] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vy[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (ex[x] + ey[i] - a[x][i] &lt; slack[i]) &#123;</span><br><span class="line">				slack[i] = ex[x] + ey[i] - a[x][i];</span><br><span class="line">				pre[i] = y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (slack[i] &lt; del) &#123;</span><br><span class="line">				del = slack[i];</span><br><span class="line">				yy = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vy[i]) &#123;</span><br><span class="line">				ex[match[i]] -= del;</span><br><span class="line">				ey[i] += del;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> slack[i] -= del;</span><br><span class="line">		&#125;</span><br><span class="line">		y = yy;</span><br><span class="line">		<span class="keyword">if</span> (match[y] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		match[y] = match[pre[y]];</span><br><span class="line">		y = pre[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">km</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(match));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(vy, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vy));</span><br><span class="line">		<span class="built_in">bfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (match[i] != <span class="number">-1</span>)ans += a[match[i]][i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) a[i][j] = -inf;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		a[u][v] = w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">km</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, match[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MCMF-P1251"><a href="#MCMF-P1251" class="headerlink" title="MCMF P1251"></a>MCMF <a href="https://www.luogu.com.cn/problem/P1251">P1251</a></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MCMF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e3</span>+<span class="number">5</span>, MAXM = <span class="number">1e5</span>+<span class="number">5</span>, INF = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, next;</span><br><span class="line">        ll w, c;</span><br><span class="line">    &#125; edges[MAXM * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, ll w, ll c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges[++cnt] = &#123; to, head[from],w, c &#125;;</span><br><span class="line">        head[from] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, ll w, ll c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(from, to, w, c);</span><br><span class="line">        <span class="built_in">add</span>(to, from, <span class="number">0</span>, -c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    ll dis[MAXN], cur[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> inq[MAXN], vis[MAXN];</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">copy</span>(head, head + MAXN, cur);</span><br><span class="line">        <span class="built_in">fill</span>(dis, dis + MAXN, INF);</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = Q.<span class="built_in">front</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            inq[p] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head[p]; e != <span class="number">0</span>; e = edges[e].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> to = edges[e].to, vol = edges[e].w;</span><br><span class="line">                <span class="keyword">if</span> (vol &gt; <span class="number">0</span> &amp;&amp; dis[to] &gt; dis[p] + edges[e].c)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[to] = dis[p] + edges[e].c;</span><br><span class="line">                    <span class="keyword">if</span> (!inq[to])</span><br><span class="line">                    &#123;</span><br><span class="line">                        Q.<span class="built_in">push</span>(to);</span><br><span class="line">                        inq[to] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[t] != INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p = s, <span class="keyword">int</span> flow = INF)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == t)</span><br><span class="line">            <span class="keyword">return</span> flow;</span><br><span class="line">        vis[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rmn = flow;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> eg = cur[p]; eg &amp;&amp; rmn; eg = edges[eg].next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur[p] = eg;</span><br><span class="line">            <span class="keyword">int</span> to = edges[eg].to, vol = edges[eg].w;</span><br><span class="line">            <span class="keyword">if</span> (vol &gt; <span class="number">0</span> &amp;&amp; !vis[to] &amp;&amp; dis[to] == dis[p] + edges[eg].c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> c = <span class="built_in">dfs</span>(to, <span class="built_in">min</span>(vol, rmn));</span><br><span class="line">                rmn -= c;</span><br><span class="line">                edges[eg].w -= c;</span><br><span class="line">                edges[eg ^ <span class="number">1</span>].w += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[p] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flow - rmn;</span><br><span class="line">    &#125;</span><br><span class="line">    ll maxflow, mincost;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MCMF::s = s, MCMF::t = t;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">SPFA</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flow = <span class="built_in">dfs</span>();</span><br><span class="line">            maxflow += flow;</span><br><span class="line">            mincost += dis[t] * flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MCMF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">    ll s = <span class="number">0</span>, t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">addedge</span>(s, i , x, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">addedge</span>(i + n, t, x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll p, c1, t1, c2, t2;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; t1 &gt;&gt; c1 &gt;&gt; t2 &gt;&gt; c2;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i+t1&lt;=n)</span><br><span class="line">            <span class="built_in">addedge</span>(i, i + t1+n, INF, c1);</span><br><span class="line">        <span class="keyword">if</span>(i+t2&lt;=n)</span><br><span class="line">            <span class="built_in">addedge</span>(i, i + t2+n, INF, c2);</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= n)</span><br><span class="line">            <span class="built_in">addedge</span>(i, i + <span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">addedge</span>(s, i + n, INF, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">run</span>(s, t);</span><br><span class="line">    cout &lt;&lt; mincost &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分层网络流-P2754"><a href="#分层网络流-P2754" class="headerlink" title="分层网络流 P2754"></a>分层网络流 <a href="https://www.luogu.com.cn/problem/P2754">P2754</a></h1><p><a href="https://blog.csdn.net/ZscDst/article/details/82433217">题解</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;       <span class="comment">//起点,终点,容量,流量</span></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;                <span class="comment">//结点数,边数(包括反向弧),源点s,汇点t</span></span><br><span class="line">    vector&lt;Edge&gt; edges;            <span class="comment">//边表。edges[e]和edges[e^1]互为反向弧</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; G[MAXN];           <span class="comment">//邻接表，G[i][j]表示结点i的第j条边在edges数组中的序号</span></span><br><span class="line">    <span class="keyword">int</span> d[MAXN];                   <span class="comment">//从起点到i的距离（层数差）</span></span><br><span class="line">    <span class="keyword">int</span> cur[MAXN];                 <span class="comment">//当前弧下标</span></span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];                <span class="comment">//BFS分层使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m = edges.<span class="built_in">size</span>();</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(m - <span class="number">2</span>);</span><br><span class="line">        G[to].<span class="built_in">push_back</span>(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span><span class="comment">//构造分层网络</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        vis[s] = <span class="literal">true</span>;</span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>;</span><br><span class="line">                    d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span><span class="comment">//沿阻塞流增广</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); i++)<span class="comment">//从上次考虑的弧</span></span><br><span class="line">        &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>)<span class="comment">//多路增广</span></span><br><span class="line">            &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s; <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">BFS</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">            flow += <span class="built_in">DFS</span>(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;solve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, p[maxn], r[maxn], s[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i], &amp;r[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r[i]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="number">-1</span>) s[i][j] = n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> AC = <span class="number">1002</span>, S = <span class="number">1001</span>, T = <span class="number">1002</span>;<span class="comment">//估计总点数，超级源，超级汇</span></span><br><span class="line">    solve.<span class="built_in">init</span>(AC);</span><br><span class="line">    solve.<span class="built_in">add_edge</span>(S, <span class="number">0</span>, INF);</span><br><span class="line">    solve.<span class="built_in">add_edge</span>(n - <span class="number">1</span>, T, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ans = <span class="number">1</span>; ; ans++)</span><br><span class="line">    &#123;</span><br><span class="line">        solve.<span class="built_in">add_edge</span>(S, <span class="number">0</span> + ans * n, INF);<span class="comment">//超级源点向这一时刻的地球连边</span></span><br><span class="line">        solve.<span class="built_in">add_edge</span>(n - <span class="number">1</span> + ans * n, T, INF);<span class="comment">//这一时刻的月球向超级汇点连边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            solve.<span class="built_in">add_edge</span>(i + (ans - <span class="number">1</span>) * n, i + ans * n, INF);<span class="comment">//在空间站不动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = s[i][(ans - <span class="number">1</span>) % r[i]] + (ans - <span class="number">1</span>) * n;</span><br><span class="line">            <span class="keyword">int</span> v = s[i][ans % r[i]] + ans * n;</span><br><span class="line">            solve.<span class="built_in">add_edge</span>(u, v, p[i]);<span class="comment">//通过飞船移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        k -= solve.<span class="built_in">max_flow</span>(S, T);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">500</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>); <span class="keyword">break</span>; &#125;<span class="comment">//无解情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="倍增求LCA"><a href="#倍增求LCA" class="headerlink" title="倍增求LCA"></a>倍增求LCA</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll lg[N],d[N];</span><br><span class="line">ll n, m, s;</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">ll f[N][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x, ll fa)</span> </span>&#123;</span><br><span class="line">    d[x] = d[fa] + <span class="number">1</span>;</span><br><span class="line">    f[x][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, lg[d[x]]) &#123;</span><br><span class="line">        f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lca</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &lt; d[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">while</span> (d[x] &gt; d[y])</span><br><span class="line">        x = f[x][lg[d[x] - d[y]]];</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="built_in">dec</span>(k, lg[d[x]], <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][k] != f[y][k])</span><br><span class="line">            x = f[x][k], y = f[y][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, N - <span class="number">1</span>) &#123;</span><br><span class="line">        lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        ll u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        ll x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lca</span>(x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll dfn[<span class="number">100005</span>], low[<span class="number">100005</span>], tot, res;</span><br><span class="line"><span class="keyword">bool</span> fg[<span class="number">100005</span>];</span><br><span class="line">vector&lt;ll&gt; g[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(ll x, ll fa)</span> </span>&#123;</span><br><span class="line">    low[x] = dfn[x] = ++tot;</span><br><span class="line">    ll child = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[to]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">            <span class="built_in">Tarjan</span>(to, x);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[to]);</span><br><span class="line">            <span class="keyword">if</span> (fa != x &amp;&amp; low[to] &gt;= dfn[x]) &#123;</span><br><span class="line">                fg[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (to != fa) &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[to]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child &gt;= <span class="number">2</span> &amp;&amp; fa == x) &#123;</span><br><span class="line">        fg[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        ll u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">Tarjan</span>(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (fg[i])</span><br><span class="line">            res++;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fg[i])</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="割边"><a href="#割边" class="headerlink" title="割边"></a>割边</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中，当 isbridge[x] 为真时，(father[x],x) 为一条割边。</span></span><br><span class="line"><span class="keyword">int</span> low[MAXN], dfn[MAXN], iscut[MAXN], dfs_clock;</span><br><span class="line"><span class="keyword">bool</span> isbridge[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt_bridge;</span><br><span class="line"><span class="keyword">int</span> father[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  father[u] = fa;</span><br><span class="line">  low[u] = dfn[u] = ++dfs_clock;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">      <span class="keyword">if</span> (low[v] &gt; dfn[u]) &#123;</span><br><span class="line">        isbridge[v] = <span class="literal">true</span>;</span><br><span class="line">        ++cnt_bridge;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) &#123;</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SCC"><a href="#SCC" class="headerlink" title="SCC"></a>SCC</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], dfncnt, s[N], in_stack[N], tp;</span><br><span class="line"><span class="keyword">int</span> scc[N], sc;  <span class="comment">// 结点 i 所在 SCC 的编号</span></span><br><span class="line"><span class="keyword">int</span> sz[N];       <span class="comment">// 强连通 i 的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  low[u] = dfn[u] = ++dfncnt, s[++tp] = u, in_stack[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i; i = e[i].nex) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;v = e[i].t;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (in_stack[v]) &#123;</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">    ++sc;</span><br><span class="line">    <span class="keyword">while</span> (s[tp] != u) &#123;</span><br><span class="line">      scc[s[tp]] = sc;</span><br><span class="line">      sz[sc]++;</span><br><span class="line">      in_stack[s[tp]] = <span class="number">0</span>;</span><br><span class="line">      --tp;</span><br><span class="line">    &#125;</span><br><span class="line">    scc[s[tp]] = sc;</span><br><span class="line">    sz[sc]++;</span><br><span class="line">    in_stack[s[tp]] = <span class="number">0</span>;</span><br><span class="line">    --tp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h3 id="311E-Biologist"><a href="#311E-Biologist" class="headerlink" title="311E - Biologist"></a><a href="https://codeforces.com/problemset/problem/311/E">311E - Biologist</a></h3><p>先假设所有的点都被改为1，当前答案：<br>$$<br>(\sum w) - \sum [a_i=0]*v_i + \sum [\exist a_i=0]g_i<br>$$<br>对于原先为0的点，由于之前已经被修改过，所以修改该点相当于反悔，产生$v$的贡献。</p>
<p>对于原先为1的点，如果修改该点，产生$-v$的贡献。</p>
<p>对于每个0要求，如果该要求改为满足，那么对答案会产生$w$的贡献，如果还要倒贴，一共会产生$w + g$的贡献，将贡献作为点的权值，而且所有与它相关的点都必须选，于是连要求到所有有关的点。</p>
<p>对于1则反之。</p>
<p>summarize:</p>
<p>for the original graph:</p>
<p>For the point that was originally 0 ,build an edge from the source point to this point. The weight is v. For the point that was originally 1, build an edge from this point to the meeting point. The weight is v.</p>
<p>For the 0 demands: add an edge from the source point to this point which’s weight is $w$. If it needs subsidy, the weight is $w+g$. Then add edges from the need to the relative points (<strong>if you choose this need, you have to choose it’s children</strong>) that weights’ are $inf$.</p>
<p>learn more about <a href="https://blog.csdn.net/can919/article/details/77603353"><strong>maximum weight closed subgraph</strong></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i]) d.<span class="built_in">add_edge</span>(<span class="number">0</span>, i, v[i]);</span><br><span class="line">    <span class="keyword">else</span> d.<span class="built_in">add_edge</span>(i, d.t, v[i]);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    ll b, w, k;</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; w &gt;&gt; k;</span><br><span class="line">    ans += w;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">1</span>, k) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (!b) d.<span class="built_in">add_edge</span>(n + i, x, inf);</span><br><span class="line">        <span class="keyword">else</span> d.<span class="built_in">add_edge</span>(x, n + i, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    ll p;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    <span class="keyword">if</span> (p) w += g;</span><br><span class="line">    <span class="keyword">if</span> (!b) d.<span class="built_in">add_edge</span>(<span class="number">0</span>, n + i, w);</span><br><span class="line">    <span class="keyword">else</span> d.<span class="built_in">add_edge</span>(n + i, d.t, w);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans - d.<span class="built_in">flow</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="RC-02-开门大吉"><a href="#RC-02-开门大吉" class="headerlink" title="[RC-02] 开门大吉"></a><a href="https://www.luogu.com.cn/problem/P6054">[RC-02] 开门大吉</a></h3><p>Consider change the problem into the minimum cut.</p>
<p>Calculate the expectation first. Then connect the single person’s problem sets,  then add the edges for the limitations which the cap is $inf$.</p>
<h3 id="NOI2008-志愿者招募"><a href="#NOI2008-志愿者招募" class="headerlink" title="[NOI2008] 志愿者招募"></a><a href="https://www.luogu.com.cn/problem/P3980">[NOI2008] 志愿者招募</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">MCMF::<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    MCMF::<span class="built_in">addEdge</span>(i, i + <span class="number">1</span>, inf - x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    ll u, v, c;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">    MCMF::<span class="built_in">addEdge</span>(u, v + <span class="number">1</span>, inf, c);</span><br><span class="line">&#125;</span><br><span class="line">MCMF::<span class="built_in">addEdge</span>(n + <span class="number">1</span>, n + <span class="number">2</span>, inf, <span class="number">0</span>);</span><br><span class="line">MCMF::<span class="built_in">run</span>(<span class="number">0</span>, n + <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; MCMF::mincost &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="AHOI2014-JSOI2014-支线剧情"><a href="#AHOI2014-JSOI2014-支线剧情" class="headerlink" title="[AHOI2014/JSOI2014]支线剧情"></a><a href="https://www.luogu.com.cn/problem/P4043">[AHOI2014/JSOI2014]支线剧情</a></h3><p><a href="https://blog.csdn.net/clove_unique/article/details/54884437">有上下界的网络流</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll n, ans = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    ll k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">1</span>, k) &#123;</span><br><span class="line">        ll v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        d[i]--; d[v]++;</span><br><span class="line">        ans += w;</span><br><span class="line">        MCMF::<span class="built_in">addEdge</span>(i, v, inf, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">2</span>,n) MCMF::<span class="built_in">addEdge</span>(i, n+<span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        MCMF::<span class="built_in">addEdge</span>(<span class="number">0</span>, i, d[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        MCMF::<span class="built_in">addEdge</span>(i, n+<span class="number">2</span>, -d[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MCMF::<span class="built_in">addEdge</span>(n+<span class="number">1</span>, <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">MCMF::<span class="built_in">run</span>(<span class="number">0</span>,n+<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; MCMF::mincost + ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Binary-Tree-on-Plane"><a href="#Binary-Tree-on-Plane" class="headerlink" title="Binary Tree on Plane"></a><a href="https://www.luogu.com.cn/problem/CF277E">Binary Tree on Plane</a></h3><p>约束设置：最多有两个儿子：源点到该点最大流量为2，必须一个父亲，该点到汇点最大流量为1</p>
<h3 id="国家集训队happiness"><a href="#国家集训队happiness" class="headerlink" title="国家集训队happiness"></a><a href="https://www.luogu.com.cn/problem/P1646">国家集训队happiness</a></h3><p>凡是这种二选一带约束的统统转化为这种模型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	s((s)) --&gt; a((a))</span><br><span class="line">	s((s)) --&gt; x((x))</span><br><span class="line">	s((s)) --&gt; b((b))</span><br><span class="line">	x((x)) --&gt; a((a))</span><br><span class="line">	x((x)) --&gt; b((b))</span><br><span class="line">	a((a)) --&gt; y((y))</span><br><span class="line">	b((b)) --&gt; y((y))</span><br><span class="line">	y((y)) --&gt; t((t))</span><br><span class="line">	a((a)) --&gt; t((t))</span><br><span class="line">	b((b)) --&gt; t((t))</span><br></pre></td></tr></table></figure>



<h3 id="80人环游世界"><a href="#80人环游世界" class="headerlink" title="80人环游世界"></a><a href="https://www.luogu.com.cn/problem/P4553">80人环游世界</a></h3><p>由源点向每一个入点连一条权值为 $v_i$ ，费用为 0 的边，表示这个国家进入了 个$v_i$人。</p>
<p>由每一个出点向汇点连一条权值为$v_i$，费用为 0 的边，表示这个国家到达了 $v_i$个人。</p>
<p>由新点向每一个入点连一条权值为$\infty$ 或$m$均可，费用为 0 的边，表示所有人可以从任意国家出发。</p>
<p>对于每个有航线的两点，由编号小的入点连向编号大的出点$\infty$，权值为 或 m 均可，费用为航线价钱。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>小游戏</title>
    <url>/2021/05/06/%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="一些简单的游戏"><a href="#一些简单的游戏" class="headerlink" title="一些简单的游戏"></a>一些简单的游戏</h1><span id="more"></span>

<p><a href="https://dl-6gvksbj1c046e39d-1304991039.tcloudbaseapp.com/">合成辜靖然！</a></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>合成GJR</tag>
      </tags>
  </entry>
  <entry>
    <title>刷穿LeetCodeDP</title>
    <url>/2021/05/06/%E5%88%B7%E7%A9%BFleetcodeDP/</url>
    <content><![CDATA[<h1 id="LeetCode的DP（困难）"><a href="#LeetCode的DP（困难）" class="headerlink" title="LeetCode的DP（困难）"></a>LeetCode的DP（困难）</h1><span id="more"></span>

<h2 id="1510-石子游戏-IV"><a href="#1510-石子游戏-IV" class="headerlink" title="1510. 石子游戏 IV"></a><a href="https://leetcode-cn.com/problems/stone-game-iv/">1510. 石子游戏 IV</a></h2><blockquote>
<p>Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。</p>
<p>一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。</p>
<p>如果石子堆里没有石子了，则无法操作的玩家输掉游戏。</p>
<p>给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。</p>
</blockquote>
<p>0个石子是必败态，必胜态由必败态转移而来，所以：<br>$$<br>if(f_{i-j^2}=0):f_i=1<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">winnerSquareGame</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f[i - j * j])</span><br><span class="line">            &#123;</span><br><span class="line">                f[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1531-压缩字符串-II"><a href="#1531-压缩字符串-II" class="headerlink" title="1531. 压缩字符串 II"></a><a href="https://leetcode-cn.com/problems/string-compression-ii/">1531. 压缩字符串 II</a></h2><blockquote>
<p>行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 “aabccc” ，将 “aa” 替换为 “a2” ，”ccc” 替换为` “c3” 。因此压缩后的字符串变为 “a2bc3” 。</p>
<p>注意，本问题中，压缩时没有在单个字符后附加计数 ‘1’ 。</p>
<p>给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。</p>
<p>请你返回删除最多 k 个字符后，s 行程长度编码的最小长度 。</p>
</blockquote>
<p>区间dp，写好cost函数方便转移。</p>
<p>$f_{i,j}$代表前i个字符，删除j个，的最小编码长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> cost = [](<span class="keyword">int</span> d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(sz+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>,<span class="number">1e9</span>));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=i &amp;&amp; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>, same = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> st = i; st &gt;= <span class="number">1</span> &amp;&amp; diff&lt;=j; st--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[st<span class="number">-1</span>] == s[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    same++;                    </span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[st - <span class="number">1</span>][j-diff] + <span class="built_in">cost</span>(same), f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    diff++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[sz][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1745-回文串分割-IV"><a href="#1745-回文串分割-IV" class="headerlink" title="1745. 回文串分割 IV"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-iv/">1745. 回文串分割 IV</a></h2><blockquote>
<p>给你一个字符串 s ，如果可以将它分割成三个 非空 回文子字符串，那么返回 true ，否则返回 false 。</p>
<p>当一个字符串正着读和反着读是一模一样的，就称其为 回文字符串 。</p>
</blockquote>
<p>dp枚举所有的回文串$O(n^2)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkPartitioning</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(sz, vector&lt;<span class="keyword">int</span>&gt;(sz, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; sz - <span class="number">1</span> &amp;&amp; s[i] == s[i + <span class="number">1</span>])</span><br><span class="line">            f[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; sz - <span class="number">1</span>; len++)<span class="comment">//key!!</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                f[i][j] |= f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; sz<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; f[i][j] &amp;&amp; f[j + <span class="number">1</span>][sz - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1751-最多可以参加的会议数目-II"><a href="#1751-最多可以参加的会议数目-II" class="headerlink" title="1751. 最多可以参加的会议数目 II"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended-ii/">1751. 最多可以参加的会议数目 II</a></h2><blockquote>
<p>给你一个 events 数组，其中 events[i] = [startDayi, endDayi, valuei] ，表示第 i 个会议在 startDayi 天开始，第 endDayi 天结束，如果你参加这个会议，你能得到价值 valuei 。同时给你一个整数 k 表示你能参加的最多会议数目。</p>
<p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p>
<p>请你返回能得到的会议价值 最大和 。</p>
</blockquote>
<p>按照会议结束时间排序，DP+二分<br>$$<br>f_{i,j}=<br>\begin{cases}<br>f_{i-1,j}, &amp; \text{不选$i$会议} \[2ex]<br>f_{l,j-1}+value_i, &amp;\text{选择$i$会议，从离它最近的可以参加的$l$会议对应的状态转移而来}<br>\end{cases}<br>$$<br>如果在$i$之前不存在合适的会议$l$，那选择$i$会议的话就只有$f_{i,1}=value_i$了</p>
<p>还有要注意的就是二分的写法：</p>
<p>可以选择同一个东西和不可以选择同一个东西是不一样的写法。</p>
<p>这个题目应该写这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r - l &gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (events[mid][<span class="number">1</span>] &lt; events[i][<span class="number">0</span>])</span><br><span class="line">    	l = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   		r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>如果写成这个会死循环</del>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (events[mid][<span class="number">1</span>] &lt; events[i][<span class="number">0</span>])</span><br><span class="line">    	l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; events, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(events.<span class="built_in">begin</span>(), events.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">int</span> sz = events.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(sz, vector&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = events[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r - l &gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (events[mid][<span class="number">1</span>] &lt; events[i][<span class="number">0</span>])</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//参加</span></span><br><span class="line">        <span class="keyword">if</span> (events[l][<span class="number">1</span>] &lt; events[i][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[l][j - <span class="number">1</span>] + events[i][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[i][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][<span class="number">1</span>], events[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不参加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[sz - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1771-由子序列构造的最长回文串的长度"><a href="#1771-由子序列构造的最长回文串的长度" class="headerlink" title="1771. 由子序列构造的最长回文串的长度"></a><a href="https://leetcode-cn.com/problems/maximize-palindrome-length-from-subsequences/">1771. 由子序列构造的最长回文串的长度</a></h2><blockquote>
<p>给你两个字符串 word1 和 word2 ，请你按下述方法构造一个字符串：</p>
<p>从 word1 中选出某个 非空 子序列 subsequence1 。<br>从 word2 中选出某个 非空 子序列 subsequence2 。<br>连接两个子序列 subsequence1 + subsequence2 ，得到字符串。<br>返回可按上述方法构造的最长 回文串 的 长度 。如果无法构造回文串，返回 0 。</p>
<p>字符串 s 的一个 子序列 是通过从 s 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。</p>
<p>回文串 是正着读和反着读结果一致的字符串。</p>
</blockquote>
<p>把两个串拼接在一起，dp求最长回文子序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz1 = word1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> sz2 = word2.<span class="built_in">size</span>();</span><br><span class="line">    string s = word1 + word2;</span><br><span class="line">    <span class="keyword">int</span> len = sz2 + sz1;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(len, vector&lt;<span class="keyword">int</span>&gt;(len));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][i + <span class="number">1</span>] = s[i] == s[i + <span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = word1.<span class="built_in">back</span>() == word2[<span class="number">0</span>] ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>;l&lt;len;l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i + <span class="number">1</span>][j - <span class="number">1</span>]+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; sz1 &amp;&amp; j &gt;= sz1)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = <span class="built_in">max</span>(res, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1787-使所有区间的异或结果为零"><a href="#1787-使所有区间的异或结果为零" class="headerlink" title="1787. 使所有区间的异或结果为零"></a><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/">1787. 使所有区间的异或结果为零</a></h2><blockquote>
<p>给你一个整数数组 nums 和一个整数 k 。区间 [left, right]（left &lt;= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR … XOR nums[right] 。</p>
<p>返回数组中 要更改的最小元素数 ，以使所有长度为 k 的区间异或结果等于零。</p>
</blockquote>
<p>这题真不简单，我也是看了<a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/solution/an-yu-shu-fen-zu-jin-xing-dong-tai-gui-h-7z0g/">别人的题解</a>才会的。</p>
<p>$f[val]$代表所有组，异或和为$val$时，需要改变的最少次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minChanges</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">1050</span>,inf)</span></span>;</span><br><span class="line">    vector&lt;unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">group</span>(k);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; sz; j+=k)</span><br><span class="line">        &#123;</span><br><span class="line">            group[i][nums[j]]++;</span><br><span class="line">            cnt[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minn = *<span class="built_in">min_element</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">f0</span><span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">10</span>, minn + cnt[i])</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[j] == inf)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [p, freq] : group[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = p ^ j;</span><br><span class="line">                f0[nxt] = <span class="built_in">min</span>(f0[nxt], f[j] + cnt[i] - freq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f = <span class="built_in">move</span>(f0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1799-N-次操作后的最大分数和"><a href="#1799-N-次操作后的最大分数和" class="headerlink" title="1799. N 次操作后的最大分数和"></a><a href="https://leetcode-cn.com/problems/maximize-score-after-n-operations/">1799. N 次操作后的最大分数和</a></h2><blockquote>
<p>给你 nums ，它是一个大小为 2 * n 的正整数数组。你必须对这个数组执行 n 次操作。</p>
<p>在第 i 次操作时（操作编号从 1 开始），你需要：</p>
<p>选择两个元素 x 和 y 。<br>获得分数 i * gcd(x, y) 。<br>将 x 和 y 从 nums 中删除。<br>请你返回 n 次操作后你能获得的分数和最大为多少。</p>
<p>函数 gcd(x, y) 是 x 和 y 的最大公约数。</p>
</blockquote>
<p>状压+记忆化搜索</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> gcd[<span class="number">15</span>][<span class="number">15</span>]; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//预处理gcd</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                gcd[i][j] = __gcd(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记忆化搜索</span></span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> state,<span class="keyword">int</span> cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[state] != <span class="number">0</span>) <span class="keyword">return</span> dp[state];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(( (state &gt;&gt; i) &amp; <span class="number">1</span> ) == <span class="number">0</span> <span class="built_in"><span class="keyword">or</span></span> ((state &gt;&gt; j) &amp; <span class="number">1</span> ) == <span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> cur_state = state ^ (<span class="number">1</span> &lt;&lt; i) ^ (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    dp[state] = <span class="built_in">max</span>(dp[state],<span class="built_in">dfs</span>(cur_state,cnt + <span class="number">1</span>) + cnt * gcd[i][j]);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[state];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1857-有向图中最大颜色值"><a href="#1857-有向图中最大颜色值" class="headerlink" title="1857. 有向图中最大颜色值"></a><a href="https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/">1857. 有向图中最大颜色值</a></h2><blockquote>
<p>给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。</p>
<p>给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。</p>
<p>图中一条有效 路径 是一个点序列 x1 -&gt; x2 -&gt; x3 -&gt; … -&gt; xk ，对于所有 1 &lt;= i &lt; k ，从 xi 到 xi+1 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。</p>
<p>请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。</p>
</blockquote>
<p>可以得到一个很简单递推关系，拓扑判环，然后再从入度为0的节点DP。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100005</span>][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> ind[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ind, <span class="number">0</span>, <span class="keyword">sizeof</span> ind);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ind[g[i][j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">int</span> f = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[f].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ind[g[f][i]]--;</span><br><span class="line">            <span class="keyword">if</span> (ind[g[f][i]] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(g[f][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,string &amp;colors)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (g[x].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[x][colors[x] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[to])</span><br><span class="line">            <span class="built_in">dfs</span>(to, colors);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[x][i] = <span class="built_in">max</span>(dp[x][i], dp[to][i] + (<span class="string">&#x27;a&#x27;</span> + i == colors[x]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestPathValue</span><span class="params">(string colors, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    n = colors.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[edges[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(edges[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">check</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> f = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(f,colors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>数字电路（时序逻辑）</title>
    <url>/2021/05/10/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="时序逻辑元件"><a href="#时序逻辑元件" class="headerlink" title="时序逻辑元件"></a>时序逻辑元件</h1><h2 id="RS触发器"><a href="#RS触发器" class="headerlink" title="RS触发器"></a>RS触发器</h2><p>$$<br>\begin{cases}<br>Q^{n+1}=S+\overline R Q^n \<br>SR=0<br>\end{cases}<br>$$</p>
<h2 id="JK触发器"><a href="#JK触发器" class="headerlink" title="JK触发器"></a>JK触发器</h2><p>$$<br>Q^{n+1}=J \overline {Q^n} + \overline K Q^n<br>$$</p>
<h2 id="D触发器"><a href="#D触发器" class="headerlink" title="D触发器"></a>D触发器</h2><p>$$<br>Q^{n+1}=D<br>$$</p>
<h2 id="T触发器"><a href="#T触发器" class="headerlink" title="T触发器"></a>T触发器</h2><p>$$<br>Q^{n+1}=T \bigoplus Q^{n}<br>$$</p>
<h1 id="时序逻辑分析与设计"><a href="#时序逻辑分析与设计" class="headerlink" title="时序逻辑分析与设计"></a>时序逻辑分析与设计</h1><span id="more"></span>

<h2 id="同步时序逻辑分析"><a href="#同步时序逻辑分析" class="headerlink" title="同步时序逻辑分析"></a>同步时序逻辑分析</h2><h3 id="小型同步时序逻辑分析"><a href="#小型同步时序逻辑分析" class="headerlink" title="小型同步时序逻辑分析"></a>小型同步时序逻辑分析</h3><ol>
<li>根据给定的逻辑图，写出时序逻辑输出方程，触发器驱动方程</li>
<li>将驱动方程带入特性方程</li>
<li>列出状态分配表</li>
<li>由状态分配表推出状态表/画出状态图/波形图</li>
<li>由状态表或状态图说明功能</li>
</ol>
<h3 id="中型同步时序逻辑分析"><a href="#中型同步时序逻辑分析" class="headerlink" title="中型同步时序逻辑分析"></a>中型同步时序逻辑分析</h3><p>通过给出的功能表或者功能转换图，穷举所有状态，画状态图，判断功能</p>
<h2 id="时序逻辑功能转换"><a href="#时序逻辑功能转换" class="headerlink" title="时序逻辑功能转换"></a>时序逻辑功能转换</h2><h3 id="方法一：套状态方程"><a href="#方法一：套状态方程" class="headerlink" title="方法一：套状态方程"></a>方法一：套状态方程</h3><p>例：JK触发器到D触发器</p>
<p>JK:<br>$$<br>Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n<br>$$<br>D:<br>$$<br>Q^{n+1}=D<br>$$<br>把JK带入D：<br>$$<br>Q^{n+1}=D(\overline{Q^n}+Q^n)=D\overline{Q^n}+\overline{D}Q^n<br>$$<br>所以：<br>$$<br>\begin{cases}<br>j=D\<br>k=\overline{D}<br>\end{cases}<br>$$</p>
<h3 id="方法二：图表法"><a href="#方法二：图表法" class="headerlink" title="方法二：图表法"></a>方法二：图表法</h3><ol>
<li>列出待求触发器的特性真值表（先画已经有的，再在这个上面添加要求的）</li>
<li>根据真值表，针对要求的触发器画卡诺图</li>
<li>根据卡诺图画驱动方程，然后画逻辑图</li>
</ol>
<h2 id="同步时序逻辑的设计"><a href="#同步时序逻辑的设计" class="headerlink" title="同步时序逻辑的设计"></a>同步时序逻辑的设计</h2><h3 id="小型同步时序逻辑设计"><a href="#小型同步时序逻辑设计" class="headerlink" title="小型同步时序逻辑设计"></a>小型同步时序逻辑设计</h3><ol>
<li>根据需求建立原始的状态图或状态表</li>
<li>化解</li>
<li>确定状态变量数量，完成状态分配（将化简的状态用二进制表示）</li>
<li>选择触发器类型</li>
<li>确保逻辑可以自启动（所有无效状态有限步数可以到达有效状态）</li>
<li>画逻辑图</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h3><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><h2 id="序列信号发生器设计"><a href="#序列信号发生器设计" class="headerlink" title="序列信号发生器设计"></a>序列信号发生器设计</h2><h3 id="使用多路选择器"><a href="#使用多路选择器" class="headerlink" title="使用多路选择器"></a>使用多路选择器</h3><h3 id="使用译码器"><a href="#使用译码器" class="headerlink" title="使用译码器"></a>使用译码器</h3><h3 id="使用其他门的组合逻辑"><a href="#使用其他门的组合逻辑" class="headerlink" title="使用其他门的组合逻辑"></a>使用其他门的组合逻辑</h3>]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>数电</tag>
      </tags>
  </entry>
  <entry>
    <title>数论练习</title>
    <url>/2021/04/28/%E6%95%B0%E8%AE%BA%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>求：$Ans = \sum_{i=1}^{a}\sum_{j=1}^{b}[gcd(i,j)=d]$</strong></p>
<span id="more"></span>

<p>设：<br>$$<br>f(d)=\sum_{i=1}^{a}\sum_{j=1}^{b}[gcd(i,j)=d]<br>$$</p>
<p>$$<br>F(n)=\sum_{n|k}f(k)=⌊\frac{a}{n}⌋⌊\frac{b}{n}⌋<br>$$</p>
<p>反演公式：<br>$$<br>f(n)=\sum_{n|d}\mu(\lfloor\frac d n \rfloor)F(d)<br>$$<br>推导公式：<br>$$<br>Ans = f(d)\<br>=\sum_{d|n}\mu(\lfloor\frac n d \rfloor)F(n)\<br>=\sum_{d|n}\mu(\lfloor\frac n d \rfloor)\sum_{n|k}f(k)\<br>=\sum_{d|n}\mu(\lfloor\frac n d \rfloor)⌊\frac{a}{n}⌋⌊\frac{b}{n}⌋\<br>=\sum_{t=1}^{min(a,b)}\mu(t)⌊\frac{a}{td}⌋⌊\frac{b}{td}⌋<br>$$</p>
<p>代码实现：</p>
<p>$\mu$数组及其前缀和：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; pri;</span><br><span class="line">ll mu[N], sum[N], cnt, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            pri.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j]&lt;N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mu[i * pri[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; d;</span><br><span class="line">ll maxn = max(a, b), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= maxn; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    r = min(a / (a / l), b / (b / l));</span><br><span class="line">    ans+= (a / (l * d)) * (b / (l * d)) * (sum[r] - sum[l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>求：$Ans = \sum_{i=a}^{b}\sum_{j=c}^{d}[gcd(i,j)=k]$</p>
<p>由容斥：<br>$$<br>Ans =\sum_{i=1}^{b}\sum_{j=1}^{d}[gcd(i,j)=k]-\sum_{i=1}^{a-1}\sum_{j=1}^{d}[gcd(i,j)=k]-\sum_{i=1}^{b}\sum_{j=1}^{c-1}[gcd(i,j)=k]+\sum_{i=1}^{a-1}\sum_{j=1}^{c-1}[gcd(i,j)=k]<br>$$</p>
<hr>
<p><strong>求：</strong>$Ans = \sum_{i=1}^{n}\sum_{j=1}^{m}(gcd(i,j)<em>2-1)$<br>$$<br>Ans =2</em>\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)-mn<br>$$</p>
<p>设<br>$$<br>f(d)=\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]<br>$$</p>
<p>$$<br>f(d)=\sum_{i=1}^{\lfloor \frac n d \rfloor}\sum_{j=1}^{\lfloor \frac m d \rfloor}[gcd(i,j)=1]<br>$$</p>
<p>$\mu$数组性质：<br>$$<br>\because [x=1]⇔\sum_{q|x}\mu(q)<br>$$</p>
<p>$$<br>\therefore f(d)=\sum_{i=1}^{\lfloor \frac n d \rfloor}\sum_{j=1}^{\lfloor \frac m d \rfloor}\sum_{q|i,q|j}\mu(q)<br>$$</p>
<p>$$<br>\therefore f(d)=\sum_{i=1}^{\lfloor \frac n d \rfloor}\sum_{j=1}^{\lfloor \frac m d \rfloor}\sum_{q=1}^{\lfloor \frac {min(n,m)} d \rfloor}\mu(q)[q|i,q|j]<br>$$</p>
<p>$i=iq,j=jq$替换<br>$$<br>f(d)=\sum_{q=1}^{\lfloor \frac {min(n,m)} d \rfloor}\mu(q)\sum_{i=1}^{\lfloor \frac n {dq} \rfloor}\sum_{j=1}^{\lfloor \frac m {dq} \rfloor}1<br>$$</p>
<p>$$<br>f(d)=\sum_{q=1}^{\lfloor \frac {min(n,m)} {d} \rfloor}\mu(q)\lfloor \frac n {dq} \rfloor\lfloor \frac m {dq} \rfloor<br>$$</p>
<p>$$<br>\because\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)=\sum_{d=1}^{min(n,m)}f(d)\times d<br>$$</p>
<p>$$<br>\therefore\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)=\sum_{d=1}^{min(n,m)} d \sum_{dq=1}^{ {min(n,m)} }\mu(q)\lfloor \frac n {dq} \rfloor\lfloor \frac m {dq} \rfloor<br>$$</p>
<p>$$<br>=\sum_{d=1}^{min(n,m)} d \sum_{T=1}^{ {min(n,m)} }\mu(\frac T d)\lfloor \frac n {T} \rfloor\lfloor \frac m {T} \rfloor[d|T]<br>$$</p>
<p>$$<br>=\sum_{d=1}^{min(n,m)}  \sum_{d|T}^{ {min(n,m)} } d \mu(\frac T d)\lfloor \frac n {T} \rfloor\lfloor \frac m {T} \rfloor<br>$$</p>
<p>替换d,T枚举方式<br>$$<br>=\sum_{T=1}^{min(n,m)}  \sum_{d|T}^{ {min(n,m)} } d \mu(\frac T d)\lfloor \frac n {T} \rfloor\lfloor \frac m {T} \rfloor<br>$$</p>
<p>$$<br>=\sum_{T=1}^{min(n,m)} \lfloor \frac n {T} \rfloor\lfloor \frac m {T} \rfloor \sum_{d|T}^{ {min(n,m)} } d \mu(\frac T d)<br>$$</p>
<p>由迪利克雷卷积：<br>$$<br>\sum_{d|T}^{ {min(n,m)} } d \mu(\frac T d)=\varphi(T)<br>$$</p>
<p>$$<br>=\sum_{T=1}^{min(n,m)} \lfloor \frac n {T} \rfloor\lfloor \frac m {T} \rfloor \varphi(T)<br>$$</p>
<p>$\varphi$数组筛法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri.push_back(i), phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            phi[i * pri[j]] = phi[i] * phi[pri[j]];</span><br><span class="line">            <span class="keyword">if</span> ((i % pri[j]) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>杜教筛板子：</p>
<p>求$\mu(n)$和$\varphi(n)$前缀</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll ph[N], mu[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; pri;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; ansmu,ansph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = ph[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri.push_back(i), mu[i] = <span class="number">-1</span>, ph[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; pri[j] * i &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[pri[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ph[i * pri[j]] = ph[i] * pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ph[i * pri[j]] = ph[pri[j]] * ph[i];</span><br><span class="line">            mu[i * pri[j]] -= mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        mu[i] += mu[i - <span class="number">1</span>], ph[i] += ph[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getmu</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; N)</span><br><span class="line">        <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (ansmu[x])</span><br><span class="line">        <span class="keyword">return</span> ansmu[x];</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        ans -= (r - l + <span class="number">1</span>) * getmu(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansmu[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getph</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; N)</span><br><span class="line">        <span class="keyword">return</span> ph[x];</span><br><span class="line">    <span class="keyword">if</span> (ansph[x])</span><br><span class="line">        <span class="keyword">return</span> ansph[x];</span><br><span class="line">    ll ans = (<span class="number">1</span>+x)*x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        ans -= (r - l + <span class="number">1</span>) * getph(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansph[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>求：<br>$$<br>\sum_{i=1}^{N}\sum_{j=1}^{N}\sum_{p=1}^{\lfloor \frac N j \rfloor}\sum_{q=1}^{\lfloor \frac N j \rfloor}[gcd(i,j)=1][gcd(p,q)]<br>$$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/837s7veq.png" alt="img"  /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; pri;</span><br><span class="line">ll mu[N], sum[N], cnt, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            pri.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mu[i * pri[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; N)</span><br><span class="line">        <span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">if</span> (mp.count(x))</span><br><span class="line">        <span class="keyword">return</span> mp[x];</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        ans -= (r - l + <span class="number">1</span>) * S(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[x] = ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x % mod * x % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getmu();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ans = (ans + ((S(r) - S(l - <span class="number">1</span>)) * f(n / l))) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans + mod) % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>求：$\sum_{i=1}^n \sum_{j=1}^{m}  d(ij)$</p>
<p>有定理：<br>$$<br>d(ij)=\sum_{x|i}\sum_{x|j}[gcd(i,j)=1]<br>$$<br>更换枚举顺序有：<br>$$<br>\sum_{i=1}^n\sum_{x|i}f(x)<br>$$</p>
<p>$$<br>=\sum_{x=1}^{n}\lfloor \frac n x \rfloor f(x)<br>$$</p>
<p>所求为：<br>$$<br>\sum_{i=1}^n \sum_{j=1}^{m}\sum_{x|i}\sum_{x|j}[gcd(i,j)=1]<br>$$<br>更换枚举顺序：<br>$$<br>\sum_{x=1}^n\sum_{y=1}^{m} \lfloor \frac n x \rfloor\lfloor \frac m y \rfloor  [gcd(x,y)=1]<br>$$<br>设：<br>$$<br>f(x) = \sum_{i=1}^n\sum_{j=1}^{m} \lfloor \frac n i \rfloor\lfloor \frac m j \rfloor  [gcd(i,j)=x]<br>$$</p>
<p>$$<br>g(x)=\sum_{x|d}f(d)<br>$$</p>
<p>代入：<br>$$<br>g(x)=\sum_{x|d}\sum_{i=1}^n\sum_{j=1}^{m} \lfloor \frac n i \rfloor\lfloor \frac m j \rfloor  [gcd(i,j)=x]<br>$$</p>
<p>$$<br>g(x)=\sum_{i=1}^n\sum_{j=1}^{m} \lfloor \frac n i \rfloor\lfloor \frac m j \rfloor  [x|gcd(i,j)]<br>$$</p>
<p>$$<br>g(x)=\sum_{i=1}^{\frac n x}\sum_{j=1}^{\frac m x} \lfloor \frac n {ix} \rfloor\lfloor \frac m {jx} \rfloor<br>$$</p>
<p>反演：<br>$$<br>f(x)=\sum_{x|n}\mu(\lfloor \frac n x \rfloor)g(n)<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ll x = <span class="number">1</span>; x &lt; N; x++)</span><br><span class="line">&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        res += (r - l + <span class="number">1</span>) * (x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    pre[x] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">0</span>,m, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= min(m, n); l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    r = min(n / (n / l), m / (m / l));</span><br><span class="line">    ans += (sum[r] - sum[l - <span class="number">1</span>]) * pre[n / l] * pre[m / l];</span><br><span class="line">&#125;   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>



<p>设奇数$x=2k+1,x^2=4k^2+4k+1$</p>
<p>则$x^2\equiv1(mod\ 2^3)$</p>
<p>以此类推：</p>
<p>$x^4\equiv1(mod\ 2^4)$</p>
<p>$x^{2y}\equiv1(mod\ 2^{y+2})$</p>
<p>MIN25筛素数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="keyword">int</span> lenp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">7000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> g[<span class="number">7000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=lim)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> len-n/x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	lim=<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i=a[len]+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a[++len]=n/(n/i);</span><br><span class="line">		g[len]=a[len]<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=lim;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(g[i]!=g[i<span class="number">-1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			++lenp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=len;a[j]&gt;=<span class="number">1ll</span>*i*i;--j)</span><br><span class="line">				g[j]=g[j]-g[get_index(a[j]/i)]+lenp<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;g[len];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>模电复习</title>
    <url>/2021/05/29/%E6%A8%A1%E7%94%B5%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="半导体器件"><a href="#半导体器件" class="headerlink" title="半导体器件"></a>半导体器件</h1><span id="more"></span>

<h2 id="半导体特性"><a href="#半导体特性" class="headerlink" title="半导体特性"></a>半导体特性</h2><ol>
<li>热敏性</li>
<li>光敏性</li>
<li>掺杂性</li>
</ol>
<h2 id="半导体分类"><a href="#半导体分类" class="headerlink" title="半导体分类"></a>半导体分类</h2><h3 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h3><p>纯净的、单晶体形式存在的半导体</p>
<p>环境温度或者光照强度加强使其<strong>本征激发/热激发</strong>，价电子摆脱束缚。</p>
<h3 id="杂质半导体"><a href="#杂质半导体" class="headerlink" title="杂质半导体"></a>杂质半导体</h3><h4 id="N型半导体"><a href="#N型半导体" class="headerlink" title="N型半导体"></a>N型半导体</h4><p>参入5价元素，自由电子为多子。</p>
<h4 id="P型半导体"><a href="#P型半导体" class="headerlink" title="P型半导体"></a>P型半导体</h4><p>参入3价元素，空穴是多子。</p>
<h3 id="PN结单向导电性"><a href="#PN结单向导电性" class="headerlink" title="PN结单向导电性"></a>PN结单向导电性</h3><p>PN结加正向电压，外电场方向削弱内电场作用，使得漂移和扩散运动平衡破坏，扩散加强</p>
<p>PN结加反向电压，外电场方向增强内电场作用，使得漂移和扩散运动平衡破坏，飘移加强</p>
<h3 id="二极管应用"><a href="#二极管应用" class="headerlink" title="*二极管应用"></a>*二极管应用</h3><ol>
<li>断开二极管，比较两端电位</li>
<li>如果电压大于0.6（有导通电压的话），将其等效为直流电压源</li>
</ol>
<p>例子见P188</p>
<h3 id="稳压二极管"><a href="#稳压二极管" class="headerlink" title="稳压二极管"></a>稳压二极管</h3><p>动态电阻越小，曲线越陡，稳压性能越好。<br>$$<br>r_z=\frac {\Delta U_z}{\Delta I_z}<br>$$<br><del>就是电流怎么遍电压还是那个值</del></p>
<p>带稳压二极管的电路分析：</p>
<ol>
<li>假设处于稳压态</li>
<li>计算反向电流$I$<ul>
<li>$I_{ZM} \lt I$ 击穿</li>
<li>$I_Z \lt I \lt I_{ZM}$ 正常</li>
<li>$I \lt I_{Z}$ 截止</li>
</ul>
</li>
</ol>
<p>P191</p>
<h1 id="分立元件放大电路"><a href="#分立元件放大电路" class="headerlink" title="分立元件放大电路"></a>分立元件放大电路</h1><h2 id="基本放大电路"><a href="#基本放大电路" class="headerlink" title="基本放大电路"></a>基本放大电路</h2><p>$$<br>r_{be}=r_{bb’}+(1+\beta )\frac {26} {I_E}<br>$$</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">频率</th>
<th align="center">放大</th>
<th align="center">$r_i$</th>
<th align="center">$r_o$</th>
<th align="center">频带</th>
</tr>
</thead>
<tbody><tr>
<td align="center">共射</td>
<td align="center">低</td>
<td align="center">电流，电压</td>
<td align="center">中</td>
<td align="center">大</td>
<td align="center">窄</td>
</tr>
<tr>
<td align="center">共集</td>
<td align="center">高</td>
<td align="center">电流</td>
<td align="center">大</td>
<td align="center">小</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">共基</td>
<td align="center">高</td>
<td align="center">电压</td>
<td align="center">小</td>
<td align="center">大</td>
<td align="center">宽</td>
</tr>
</tbody></table>
<h2 id="差动放大"><a href="#差动放大" class="headerlink" title="差动放大"></a>差动放大</h2><h3 id="零点漂移"><a href="#零点漂移" class="headerlink" title="零点漂移"></a>零点漂移</h3><p>首温度的影响，输出电压不是恒定的直流。第一级三极管的影响最严重（因为会被之后的放大）</p>
<h3 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h3><p>抑制零漂和共模信号，输出信号是每管集电极电位变化的两倍。放大倍数等于单管放大倍数。</p>
<h3 id="比较输入"><a href="#比较输入" class="headerlink" title="比较输入"></a>比较输入</h3><p>输入信号不是差模信号也不是共模信号（就是大小，相位不一样）</p>
<p>把信号拆分成共模和差模（妙啊！）<br>$$<br>u_{i1}=\frac {u_{i1}+u_{i2}} 2 +\frac {u_{i1}-u_{i2}} 2<br>$$</p>
<p>$$<br>u_{i1}=\frac {u_{i1}+u_{i2}} 2 +(-\frac {u_{i1}-u_{i2}} 2)<br>$$</p>
<p>$$<br>\therefore u_{ic}=\frac {u_{i1}+u_{i2}} 2<br>$$</p>
<p>$$<br>\therefore u_{id}=u_{i1}-u_{i2}<br>$$</p>
<p>$$<br>u_{o}=A_cu_{ic}+A_du_{id}=A_c\frac {u_{i1}+u_{i2}} 2 +A_d({u_{i1}-u_{i2}})<br>$$</p>
<h3 id="共模抑制比-K-CMRR"><a href="#共模抑制比-K-CMRR" class="headerlink" title="共模抑制比$K_{CMRR}$"></a>共模抑制比$K_{CMRR}$</h3><p>衡量一个差动放大电路是否可以有效的放大<br>$$<br>K_{CMRR}=\vert \frac {A_d} {A_c} \vert<br>$$<br>Ac是一个接近0的值，上面这个东西太大了，用分贝来表示：<br>$$<br>K_{CMR}=20lg\vert \frac {A_d} {A_c} \vert<br>$$</p>
<h3 id="长尾电路"><a href="#长尾电路" class="headerlink" title="长尾电路"></a>长尾电路</h3><p>由于两半边电路完全一样很恼火，所以加一个$R_E$和$R_W$进行静态调零（一般的放大电路也用这个办法来稳定信号虽然没加$R_W$），$R_E$对差模信号来说是一根导线，因为电流相反；对共模信号来说，会大大减小其放大倍数。</p>
<p><a href="https://imgtu.com/i/2ZZBZT"><img src="https://z3.ax1x.com/2021/05/30/2ZZBZT.png" alt="2ZZBZT.png"></a></p>
<h2 id="功率放大"><a href="#功率放大" class="headerlink" title="功率放大"></a>功率放大</h2><p>多级放大电路的末级或者末级前一级一般是功率放大电路。小信号放大电路的主要任务是放大电压，功放是为了更大的输出功率。</p>
<h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><p>甲类：效率不高，低于50%，无论有无信号输入，电源都要提供$P_E=U_{CC}I_C$信号越大，有用功率越大。提高效率，可以增加放大电路的动态范围；减小电源提供的功率（将静态工作点下移）。</p>
<p>甲乙类，乙类：就是下移静态工作点。虽然效率更高了，但是有严重的非线性失真。可以用<strong>无 输出变压器 乙类互补功率放大电路</strong>（OTL）和**无 输出电容 乙类互补功率放大电路 **（OCL）</p>
<h3 id="OTL"><a href="#OTL" class="headerlink" title="OTL"></a>OTL</h3><p>就是带电容的的对称互补功放电路，有交越失真</p>
<p><a href="https://imgtu.com/i/2ZZgzR"><img src="https://z3.ax1x.com/2021/05/30/2ZZgzR.png" alt="2ZZgzR.png"></a></p>
<h3 id="OCL"><a href="#OCL" class="headerlink" title="OCL"></a>OCL</h3><p><a href="https://imgtu.com/i/2ZZOyt"><img src="https://z3.ax1x.com/2021/05/30/2ZZOyt.png" alt="2ZZOyt.png"></a></p>
<p><a href="https://imgtu.com/i/2ZZzTS"><img src="https://z3.ax1x.com/2021/05/30/2ZZzTS.png" alt="2ZZzTS.png"></a></p>
<h1 id="负反馈放大电路"><a href="#负反馈放大电路" class="headerlink" title="负反馈放大电路"></a>负反馈放大电路</h1><h2 id="反馈框图"><a href="#反馈框图" class="headerlink" title="反馈框图"></a>反馈框图</h2><p><a href="https://imgtu.com/i/2KQwLD"><img src="https://z3.ax1x.com/2021/06/01/2KQwLD.png" alt="2KQwLD.png"></a></p>
<p>正反馈：<br>$$<br>x’_i=x_i+x_f<br>$$<br>负反馈：<br>$$<br>x’_i=x_i-x_f<br>$$</p>
<h2 id="反馈的基本方程"><a href="#反馈的基本方程" class="headerlink" title="反馈的基本方程"></a>反馈的基本方程</h2><p>开环放大倍数<br>$$<br>A=\frac {x_o} {x_i’}<br>$$<br>反馈系数<br>$$<br>F=\frac {x_f} {x_o}<br>$$<br>闭环放大倍数<br>$$<br>A_f=\frac {x_o} {x_i}<br>$$<br>对于负反馈<br>$$<br>x_i’ = x_i - x_f<br>$$</p>
<p>$$<br>A_f=\frac {x_o} {x_i}=\frac {A} {1+AF}<br>$$</p>
<p>反馈深度是指：$AF+1$</p>
<p>交流负反馈对增益的影响：$变化百分比 \times \frac {1} {1+AF} $</p>
<p>对输入电阻的影响：</p>
<p>串联：$r_{if}=(1+AF)r_i $</p>
<p>并联：$r_{if}=\frac {r_i} {1+AF}$</p>
<p>对输出电阻的影响：</p>
<p>电流：$r_{of}=(1+AF)r_o $</p>
<p>电压：$r_{of}=\frac {r_o} {1+AF}$</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树合集</title>
    <url>/2021/07/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>记录一些线段树的题目。</p>
<span id="more"></span>

<h1 id="P3373-【模板】线段树-2"><a href="#P3373-【模板】线段树-2" class="headerlink" title="P3373 【模板】线段树 2"></a><a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2</a></h1><p>题目描述</p>
<p>如题，已知一个数列，你需要进行下面三种操作：</p>
<ul>
<li>将某区间每一个数乘上 <em>x</em></li>
<li>将某区间每一个数加上 <em>x</em></li>
<li>求出某区间每一个数的和</li>
</ul>
<p>输入格式</p>
<p>第一行包含三个整数 n,m,p分别表示该数列数字的个数、操作的总个数和模数。</p>
<p>第二行包含 n个用空格分隔的整数，其中第 i<em>i</em> 个数字表示数列第 i<em>i</em> 项的初始值。</p>
<p>接下来 m 行每行包含若干个整数，表示一个操作，具体如下：</p>
<p>操作 11： 格式：<code>1 x y k</code> 含义：将区间 [<em>x</em>,<em>y</em>] 内每个数乘上 <em>k</em></p>
<p>操作 22： 格式：<code>2 x y k</code> 含义：将区间 [<em>x</em>,<em>y</em>] 内每个数加上 <em>k</em></p>
<p>操作 33： 格式：<code>3 x y</code> 含义：输出区间 [<em>x</em>,<em>y</em>] 内每个数的和对 <em>p</em> 取模所得的结果</p>
<p>输出格式</p>
<p>输出包含若干行整数，即为所有操作 3的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, p;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll v, mul, add;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].v = (tr[<span class="built_in">ls</span>(x)].v + tr[<span class="built_in">rs</span>(x)].v) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].mul = <span class="number">1</span>;</span><br><span class="line">    tr[p].add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].v = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll p, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[<span class="built_in">ls</span>(p)].v = (tr[<span class="built_in">ls</span>(p)].v * tr[p].mul + tr[p].add * (mid - l + <span class="number">1</span>)) % mod;</span><br><span class="line">    tr[<span class="built_in">rs</span>(p)].v = (tr[<span class="built_in">rs</span>(p)].v * tr[p].mul + tr[p].add * (r - mid)) % mod;</span><br><span class="line">    tr[<span class="built_in">ls</span>(p)].mul = (tr[<span class="built_in">ls</span>(p)].mul * tr[p].mul) % mod;</span><br><span class="line">    tr[<span class="built_in">rs</span>(p)].mul = (tr[<span class="built_in">rs</span>(p)].mul * tr[p].mul) % mod;</span><br><span class="line">    tr[<span class="built_in">ls</span>(p)].add = (tr[<span class="built_in">ls</span>(p)].add * tr[p].mul + tr[p].add) % mod;</span><br><span class="line">    tr[<span class="built_in">rs</span>(p)].add = (tr[<span class="built_in">rs</span>(p)].add * tr[p].mul + tr[p].add) % mod;</span><br><span class="line">    tr[p].mul = <span class="number">1</span>;</span><br><span class="line">    tr[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span><span class="params">(ll nl, ll nr, ll l, ll r,ll p, ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; nl || nr &lt; l)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].v = tr[p].v * d % mod;</span><br><span class="line">        tr[p].mul = tr[p].mul * d % mod;</span><br><span class="line">        tr[p].add = tr[p].add * d % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update1</span>(nl, nr, l, mid, <span class="built_in">ls</span>(p), d);</span><br><span class="line">    <span class="built_in">update1</span>(nl, nr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p), d);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(ll nl, ll nr, ll l, ll r, ll p, ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; nl || nr &lt; l)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].v = (tr[p].v + d * (r - l + <span class="number">1</span>)) % mod;</span><br><span class="line">        tr[p].add = (tr[p].add + d) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update2</span>(nl, nr, l, mid, <span class="built_in">ls</span>(p), d);</span><br><span class="line">    <span class="built_in">update2</span>(nl, nr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p), d);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll ql, ll qr, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; ql || qr &lt; l)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> tr[p].v;</span><br><span class="line">    <span class="built_in">pushdown</span>(p, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">query</span>(ql, qr, l, mid, <span class="built_in">ls</span>(p)) + <span class="built_in">query</span>(ql, qr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p))) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll l, r, k;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">update1</span>(l, r, <span class="number">1</span>, n, <span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll l, r, k;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">update2</span>(l, r, <span class="number">1</span>, n, <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(l, r, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="P6186-NOI-Online-提高组-冒泡排序"><a href="#P6186-NOI-Online-提高组-冒泡排序" class="headerlink" title="P6186 NOI Online 提高组]冒泡排序"></a>P6186 <a href="https://www.luogu.com.cn/problem/P6186">NOI Online 提高组]冒泡排序</a></h1><p>给定一个 1 ∼ n的排列 pi，接下来有 m 次操作，操作共两种：</p>
<ol>
<li>交换操作：给定 x，将当前排列中的第 x 个数与第 x+1 个数交换位置。</li>
<li>询问操作：给定 k，请你求出当前排列经过 k<em>k</em> 轮冒泡排序后的逆序对个数。 对一个长度为 n 的排列 pi 进行一轮冒泡排序的伪代码如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1 to n-1:</span><br><span class="line">  if p[i] &gt; p[i + 1]:</span><br><span class="line">    swap(p[i], p[i + 1])</span><br></pre></td></tr></table></figure>



<p>每排一轮所有逆序对减少1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    ll c[N], n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll sz)</span> </span>&#123;</span><br><span class="line">        n = sz;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n)</span><br><span class="line">            c[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">presum</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= x &amp; -x)</span><br><span class="line">            ans += c[x];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll l,ll r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">presum</span>(r) - <span class="built_in">presum</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll x, ll v=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x)</span><br><span class="line">            <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x)</span><br><span class="line">                c[x] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;bt[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll x, ll v = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bt[<span class="number">0</span>].<span class="built_in">update</span>(x, v), bt[<span class="number">1</span>].<span class="built_in">update</span>(x, v * x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N], cc[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    bt[<span class="number">0</span>].<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        cc[i] = i - bt[<span class="number">0</span>].<span class="built_in">presum</span>(a[i]) - <span class="number">1</span>;</span><br><span class="line">        bt[<span class="number">0</span>].<span class="built_in">update</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    bt[<span class="number">0</span>].<span class="built_in">init</span>(n), bt[<span class="number">1</span>].<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">update</span>(cc[i]);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll op, x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll t1, t2;</span><br><span class="line">            t1 = bt[<span class="number">0</span>].<span class="built_in">query</span>(x + <span class="number">1</span>, n);</span><br><span class="line">            t2 = bt[<span class="number">1</span>].<span class="built_in">query</span>(x + <span class="number">1</span>, n);</span><br><span class="line">            cout &lt;&lt; t2 - x * t1 &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">update</span>(cc[x], <span class="number">-1</span>), <span class="built_in">update</span>(cc[x + <span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt; a[x + <span class="number">1</span>])</span><br><span class="line">                cc[x + <span class="number">1</span>]--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cc[x]++;</span><br><span class="line">            <span class="built_in">swap</span>(cc[x], cc[x + <span class="number">1</span>]), <span class="built_in">swap</span>(a[x], a[x + <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">update</span>(cc[x], <span class="number">1</span>), <span class="built_in">update</span>(cc[x + <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CF240F-TorCoder"><a href="#CF240F-TorCoder" class="headerlink" title="CF240F TorCoder"></a>CF240F <a href="https://www.luogu.com.cn/problem/CF240F">TorCoder</a></h1><p>给定一个长为n的由a到z组成的字符串,有m次操作，每次操作将l,r这些位置的字符进行重排，得到字典序最小的回文字符串，如果无法操作就不进行。</p>
<p>求m次操作后的字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll v, x;</span><br><span class="line">&#125;tr[<span class="number">30</span>][N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll i, ll x)</span> </span>&#123; tr[i][x].v = tr[i][<span class="built_in">ls</span>(x)].v + tr[i][<span class="built_in">rs</span>(x)].v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll i,ll l,ll r,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[i][p].x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[i][p].v = (c[l] - <span class="string">&#x27;a&#x27;</span>) == i;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i, l, mid, <span class="built_in">ls</span>(p));</span><br><span class="line">    <span class="built_in">build</span>(i, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line">    <span class="built_in">pushup</span>(i, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll i,ll l,ll r,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[i][p].x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[i][<span class="built_in">ls</span>(p)].v = (mid - l + <span class="number">1</span>) * tr[i][p].x;</span><br><span class="line">        tr[i][<span class="built_in">rs</span>(p)].v = (r - mid) * tr[i][p].x;</span><br><span class="line">        tr[i][<span class="built_in">ls</span>(p)].x = tr[i][p].x;</span><br><span class="line">        tr[i][<span class="built_in">rs</span>(p)].x = tr[i][p].x;</span><br><span class="line">        tr[i][p].x = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll i, ll nl, ll nr, ll l, ll r, ll p, ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; nl || nr &lt; l)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[i][p].v = (r - l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[i][p].x = d;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(i, l, r, p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update</span>(i, nl, nr, l, mid, <span class="built_in">ls</span>(p), d);</span><br><span class="line">    <span class="built_in">update</span>(i, nl, nr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p), d);</span><br><span class="line">    <span class="built_in">pushup</span>(i, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll i, ll ql, ll qr, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; ql || qr &lt; l)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> tr[i][p].v;</span><br><span class="line">    <span class="built_in">pushdown</span>(i, l, r, p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(i, ql, qr, l, mid, <span class="built_in">ls</span>(p)) + <span class="built_in">query</span>(i, ql, qr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//#ifdef _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; c + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line">        <span class="built_in">build</span>(i, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        ll tmp[<span class="number">30</span>];</span><br><span class="line">        ll pos = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = <span class="built_in">query</span>(i, l, r, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] &amp; <span class="number">1</span>)</span><br><span class="line">                pos = i,cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">1</span> || ((r-l+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; cnt))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line">            <span class="built_in">update</span>(i, l, r, <span class="number">1</span>, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(cnt)</span><br><span class="line">            tmp[pos]--,<span class="built_in">update</span>(pos, (l + r) &gt;&gt; <span class="number">1</span>, (l + r) &gt;&gt; <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        ll nl = l, nr = r;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">update</span>(i, nl, nl + tmp[i] / <span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>), nl += tmp[i] / <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">update</span>(i, nr - tmp[i] / <span class="number">2</span> + <span class="number">1</span>, nr, <span class="number">1</span>, n, <span class="number">1</span>, <span class="number">1</span>), nr -= tmp[i] / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">query</span>(j,i,i,<span class="number">1</span>,n,<span class="number">1</span>))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="CF242E-XOR-on-Segment"><a href="#CF242E-XOR-on-Segment" class="headerlink" title="CF242E XOR on Segment"></a>CF242E <a href="https://www.luogu.com.cn/problem/CF242E">XOR on Segment</a></h1><p>线段树上的异或</p>
<p>拆位处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> &#123;</span></span><br><span class="line">    ll v, x;</span><br><span class="line">    <span class="built_in">treenode</span>() &#123;</span><br><span class="line">        v = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[<span class="number">30</span>][N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll i,ll x)</span> </span>&#123; tr[i][x].v = tr[i][<span class="built_in">ls</span>(x)].v + tr[i][<span class="built_in">rs</span>(x)].v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll i, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[i][p].v = (a[l]&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i,l, mid, <span class="built_in">ls</span>(p));</span><br><span class="line">    <span class="built_in">build</span>(i,mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line">    <span class="built_in">pushup</span>(i,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll i, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[i][p].x)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[i][<span class="built_in">ls</span>(p)].v = (mid - l + <span class="number">1</span>) - tr[i][<span class="built_in">ls</span>(p)].v;</span><br><span class="line">        tr[i][<span class="built_in">rs</span>(p)].v = (r - mid) - tr[i][<span class="built_in">rs</span>(p)].v;</span><br><span class="line">        tr[i][<span class="built_in">ls</span>(p)].x ^= <span class="number">1</span>;</span><br><span class="line">        tr[i][<span class="built_in">rs</span>(p)].x ^= <span class="number">1</span>;</span><br><span class="line">        tr[i][p].x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll i, ll nl, ll nr, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; nl || nr &lt; l)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[i][p].v = (r - l + <span class="number">1</span>) - tr[i][p].v;</span><br><span class="line">        tr[i][p].x ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(i,l,r,p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update</span>(i, nl, nr, l, mid, <span class="built_in">ls</span>(p));</span><br><span class="line">    <span class="built_in">update</span>(i, nl, nr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line">    <span class="built_in">pushup</span>(i, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll i, ll ql, ll qr, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; ql || qr &lt; l)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> tr[i][p].v;</span><br><span class="line">    <span class="built_in">pushdown</span>(i, l, r, p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(i, ql, qr, l, mid, <span class="built_in">ls</span>(p))+<span class="built_in">query</span>(i, ql, qr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        <span class="built_in">build</span>(i, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll l, r, ans = <span class="number">0</span>;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += (<span class="number">1ll</span>&lt;&lt;i)* <span class="built_in">query</span>(i, l, r, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll l, r, x, cnt = <span class="number">0</span>;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">            <span class="keyword">while</span> (x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &amp; <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">update</span>(cnt, l, r, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">                cnt++;</span><br><span class="line">                x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编复习</title>
    <url>/2021/05/06/%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="MIPS架构"><a href="#MIPS架构" class="headerlink" title="MIPS架构"></a>MIPS架构</h1><span id="more"></span>

<p><a href="https://imgtu.com/i/glYFpV"><img src="https://z3.ax1x.com/2021/05/06/glYFpV.png" alt="glYFpV.png"></a></p>
<h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p><a href="https://imgtu.com/i/gdCrDA"><img src="https://z3.ax1x.com/2021/05/11/gdCrDA.png" alt="gdCrDA.png"></a></p>
<p>例子：</p>
<ol>
<li>add $t0,$t1,$t2</li>
<li>addi $t1,$t1,1</li>
<li>lw $t1,4(​$t0)</li>
<li>beqz $t0,Label</li>
<li>只有jal和j </li>
</ol>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>外部事件：包括中断和读总线出错。<br>访存异常：对于给定的访存地址不存在可用的映射项，或试图写入写保护的页。<br>程序或硬件检测到的错误：包括不存在的指令、用户态的非法指令、整数溢出、地址对齐错误、用户态访问非用户空间等。<br>系统调用和陷阱：用专用指令产生的特殊异常，例如syscall产生的异常，用于提供系统调用。</p>
<p>四个异常处理寄存器：</p>
<ul>
<li><p>status（14）： 用来配置中断，并获得更多关于所发生的异常的信息。</p>
</li>
<li><p>cause（13）：存异常代码。</p>
</li>
<li><p>EPC（12）：它包含了异常发生时正在运行的指令的地址。它对异常处理程序的作用与CPU寄存器$ra对普通子程序的作用相同。当异常处理程序完成后，EPC寄存器允许被中断的程序重新开始运行（ref指令）。它加载中断响应的第一条指令。异常处理入口点是内核段0（KSGE0）。</p>
</li>
<li><p>badvaddress（8）：包含了导致坏地址（没有物理内存的地址，或者尝试写入只读文本段）异常的地址。</p>
</li>
</ul>
<p>mtc0指令，像存储指令一样，最后才是目标。这一点特别需要注意，因为cp0寄存器的语法与CPU寄存器的语法相同。例如，下面是将CPU寄存器13的内容复制到cp0寄存器12。</p>
<h1 id="历年试卷"><a href="#历年试卷" class="headerlink" title="历年试卷"></a>历年试卷</h1><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><h3 id="判断是否是素数"><a href="#判断是否是素数" class="headerlink" title="判断是否是素数"></a>判断是否是素数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check:</span><br><span class="line">      div $s0, $t0</span><br><span class="line">      mfhi $t2</span><br><span class="line">      bne $t2, $0, else</span><br><span class="line">      li $s1, 1</span><br><span class="line">      j back</span><br><span class="line">else:</span><br><span class="line">      addi $t0, $t0, 1</span><br><span class="line">      beq $t0, $s0, back</span><br><span class="line">      j check</span><br></pre></td></tr></table></figure>

<h3 id="找出大于-s0的第一个素数"><a href="#找出大于-s0的第一个素数" class="headerlink" title="找出大于$s0的第一个素数"></a>找出大于$s0的第一个素数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">      li $s1, 0</span><br><span class="line">      li $t0, 2</span><br><span class="line">      j check</span><br><span class="line">back:</span><br><span class="line">      beqz $s1, out</span><br><span class="line">      addi $s0, $s0, 1</span><br><span class="line">      j loop</span><br><span class="line">check:</span><br><span class="line">      div $s0, $t0</span><br><span class="line">      mfhi $t2</span><br><span class="line">      bne $t2, $0, else</span><br><span class="line">      li $s1, 1</span><br><span class="line">      j back</span><br><span class="line">else:</span><br><span class="line">      addi $t0, $t0, 1</span><br><span class="line">      beq $t0, $s0, back</span><br><span class="line">      j check</span><br><span class="line">out:</span><br><span class="line">      li $v0, 1</span><br><span class="line">      move $a0, $s0</span><br><span class="line">      syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>英语</title>
    <url>/2021/09/26/%E8%8B%B1%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h1><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><p><strong>peril</strong></p>
<p>a setback to the state could present a peril to the regime.</p>
<p>Jonathon periled his life for love of David.</p>
<span id="more"></span>

<p><strong>contend</strong></p>
<p>she had to contend with his uncertain temper</p>
<p>he contends that the judge was wrong</p>
<p><strong>possess</strong> </p>
<p>I do not possess a television set</p>
<p><strong>generate</strong></p>
<p>changes that are likely to generate controversy</p>
<p><strong>heed</strong></p>
<p>he should have heeded the warning</p>
<p><strong>compel</strong></p>
<p>a sense of duty compelled Harry to answer her question</p>
<p><strong>attempt</strong></p>
<p>she attempted a comeback in 1989</p>
<p><strong>fail to</strong></p>
<p><strong>establish</strong></p>
<p>the British established a rich trade with Portugal</p>
<p><strong>hinder</strong></p>
<p>various family stalemates were hindering communication</p>
<p><strong>alleviate/relieve</strong></p>
<p>he couldn’t prevent her pain, only alleviate it</p>
<p><strong>initiate</strong></p>
<p><strong>dispel</strong></p>
<p>the brightness of the day did nothing to dispel Elaine’s dejection</p>
<p><strong>expose/disclose</strong></p>
<p><strong>conceive</strong></p>
<p>she was conceived when her father was 49</p>
<p>the dam project was originally conceived in 1977</p>
<p><strong>embellish</strong></p>
<p>she had real difficulty to telling the truth because she liked to embellish things</p>
<p><strong>accelerate</strong></p>
<p>the car accelerated toward her</p>
<p><strong>demonstrate</strong></p>
<p>their shameful silence demonstrate their ineptitude</p>
<p><strong>adhere to/persist in</strong></p>
<p>the people adhere to the Muslim religion</p>
<p><strong>disseminate</strong></p>
<p>health authorities should foster good practice by disseminate information</p>
<p><strong>alter/convert/vary</strong></p>
<p>Eliot was persuaded to alter the passage</p>
<p><strong>confess</strong></p>
<p>he confessed that he attacked the old man</p>
<p><strong>condemn/denounce</strong></p>
<p>fair-minded people declined to condemn her on mere suspicion</p>
<p><strong>devastate/smash</strong></p>
<p>the city was devastate by a huge earthquake</p>
<p>their plane smashed into a mountainside</p>
<p><strong>enhance</strong></p>
<p>his refusal does nothing to enhance his reputation</p>
<p><strong>startle/astonish/stun</strong></p>
<p>a sudden sound in the door way startled her</p>
<p><strong>urge</strong></p>
<p><strong>give rise to = cause</strong></p>
<p><strong>mushroom</strong></p>
<p>environmental concern mushroomed in the 1960s</p>
<p><strong>hail</strong></p>
<p>he has been hailed as the new James Dean</p>
<p><strong>embrace</strong></p>
<p><strong>purchase</strong></p>
<p><strong>allocate/equip with</strong></p>
<p>the authorities allocated 50,000 places to refugees</p>
<p><strong>fulfill/satisfy</strong></p>
<p><strong>cultivate/nurture</strong></p>
<p>he cultivated an air of indifference</p>
<p><strong>terminate</strong></p>
<p><strong>utilize</strong></p>
<p>vitamin C helps you body utilize the iron present in you diet</p>
<p><strong>obtain</strong></p>
<p>an opportunity to obtain advanced degrees</p>
<p><strong>keep … in mind</strong></p>
<p><strong>dismiss</strong></p>
<p>she desmissed the taxi at the corner of the road</p>
<p>it would be easy to dismiss him as all brawn and no brain</p>
<p><strong>despair</strong></p>
<p>in despair, I hit the bottle</p>
<p>we should not despair</p>
<p><strong>assault</strong></p>
<p>he pleaded guilty to assaulting a police officer</p>
<p><strong>squander</strong></p>
<p>entrepreneurs squander their profits on expensive cars</p>
<p><strong>cease</strong></p>
<p>the hostilities had ceased and normal life was resumed</p>
<p><strong>interpret/expound</strong></p>
<p>he was expounding a powerul argument</p>
<p><strong>surpass/exceed</strong></p>
<p>prewar levels of production were surpassed in 1929</p>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p><strong>residue</strong></p>
<p>the fine residue left after the sorting of tea</p>
<p><strong>inclination</strong></p>
<p>John was a scientist by training and inclination</p>
<p><strong>silver lining</strong></p>
<p><strong>component/element</strong></p>
<p><strong>peril</strong></p>
<p><strong>foundation</strong></p>
<p>build the arch resting on top of this solid foundation</p>
<p><strong>craftsmanship</strong></p>
<p>I admire his engineering skills and craftsmanship</p>
<p><strong>means/method</strong></p>
<p><strong>assiduity</strong></p>
<p>the assiduity with which he could wear down his opponents</p>
<p><strong>stance</strong></p>
<p>she altered her stance, resting all her weight on one leg</p>
<p><strong>possessions/estate</strong></p>
<p>he had taken possession of one of the sofas</p>
<p><strong>reservation</strong></p>
<p><strong>restriction</strong></p>
<p><strong>conduct</strong></p>
<p>all three brothers were known for their disorderly conduct</p>
<p><strong>expenditure/outlay</strong></p>
<p>a modest outlay on loacl advertising</p>
<p><strong>accomplishment</strong></p>
<p>the reduction of inflation was a remarkable accomplishment</p>
<p><strong>association</strong></p>
<p>he developed a close association with the university</p>
<p><strong>descendant</strong></p>
<p>house music is a decendant of disco</p>
<p><strong>prosperity/boom</strong></p>
<p>a long period of prosperity</p>
<p><strong>adventure/hazard</strong></p>
<p>the hazards of smoking</p>
<p><strong>option</strong></p>
<p><strong>loyalty/allegiance</strong></p>
<p>those wishing to receive citizenship must swear allegiance to the republic</p>
<p><strong>equilibrium</strong></p>
<p>the maintance of social equilibrium</p>
<p><strong>aspiration</strong></p>
<p>the yawning gulf between aspiration and reality</p>
<p><strong>incentive/impetus</strong></p>
<p>there is no incentive for customers to conserve water</p>
<p><strong>obligation/liability</strong></p>
<p>they are under no obligation to stick to the scheme</p>
<p><strong>domain</strong></p>
<p>the southwestern French domains of the Plantagenets</p>
<p><strong>chaos</strong></p>
<p><strong>perspective</strong></p>
<p><strong>indignation</strong></p>
<p>the letter filled Lucy with indgnation</p>
<p><strong>vertex/summit</strong></p>
<p><strong>opportunity/probability</strong></p>
<p><strong>impact/influence</strong></p>
<p><strong>perspiration</strong></p>
<p>perspiration ran down his forehead</p>
<p><strong>setback/frustration</strong></p>
<p><strong>celebrity/prestige</strong></p>
<p>he experienced a tremendous increasse in prestige following his victory</p>
<p><strong>mentality/mindset</strong></p>
<p><strong>aptitude/endowment</strong></p>
<p><strong>malfunction</strong></p>
<p>a computer malfunction</p>
<p><strong>distribution</strong></p>
<p><strong>circumstance/surroundings</strong></p>
<p>we wanted to marry but circumstances didn’t permit</p>
<p><strong>opponent/rival</strong></p>
<p>he beat his opponent by a landslide margin</p>
<p><strong>vocation/profession</strong></p>
<p><strong>slump</strong></p>
<p>she slumped against the cushions</p>
<p><strong>cause</strong></p>
<p><strong>adolescence</strong></p>
<p>Mary spent her childhood and adolescence in Europe</p>
<p><strong>governance</strong></p>
<p>a more responsive system of governance will be required</p>
<p><strong>scarcity</strong></p>
<p>the growing scarcity of resources</p>
<p><strong>obstacle</strong></p>
<p>thie major obstacle to achieving that goal is money</p>
<p><strong>wellbeing</strong></p>
<p>an improvement in the patients wellbeing</p>
<p><strong>peasant</strong></p>
<p>peasant = farmer</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2021/09/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><span id="more"></span>

<h2 id="First集合"><a href="#First集合" class="headerlink" title="First集合"></a>First集合</h2><p>为得到唯一的推导过程，条件为：</p>
<p><strong>左部相同的产生式，其“右部的首符号集合”不相交。</strong></p>
<p>定义：设$G=(V_T,V_N,S,P)$是上下文无关文法，$FIRST(\alpha)={a|\alpha \implies a\beta,a\in V_T,\alpha,\beta\in V^*}$，若$α \implies ε$，则规定$ε∈FIRST(α)$</p>
<p><a href="https://imgtu.com/i/48v5bd"><img src="https://z3.ax1x.com/2021/09/20/48v5bd.png" alt="48v5bd.png"></a></p>
<h2 id="Follow集合"><a href="#Follow集合" class="headerlink" title="Follow集合"></a>Follow集合</h2><p>1.文法中包含空产生式。</p>
<p>2.为得到唯一的推导过程，条件为：</p>
<p><strong>当某一个$V_N$的产生式含空产生式，则它的非空产生式的First集合两两互不相交，且与推导过程中紧跟该$V_N$可能出现的$V_T$的集合也不相交</strong></p>
<p>定义：设$G = (V_T,V_N,S,P)$是上下文无关文法，$A\in V_N,S$是开始符号。</p>
<p>$FOLLOW(A)={a|S\implies \mu A\beta 且 a∈FIRST(\beta), \mu∈{V_T}^*,\beta∈V^+}$</p>
<p>若$\beta \implies $ε，规定$\in FOLLOW(A)$</p>
<h2 id="Select集合"><a href="#Select集合" class="headerlink" title="Select集合"></a>Select集合</h2><p>若$ A→α ,  A→β$   其中$A∈V_N , α, β ∈{V_N}^*$，α不能推导出空，β能推导出空，</p>
<p>则 $FIRST(α)∩( (FIRST(β)-{ε}) ∪FOLLOW(A) )=Φ$</p>
<p>定义：</p>
<p>给定上下文无关文法的产生式$A \rightarrow \alpha,A \in V_N, \alpha \in V^*$</p>
<p>若$\alpha$ 不可推出 $ε$，则$SELECT(A→α)= First(α)$</p>
<p>若$\alpha$ 可推出 $ε$，则$SELECT(A→α)= (First(α)-{ε})∪Follow(A)$</p>
<h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><p><a href="https://imgtu.com/i/4GC28I"><img src="https://z3.ax1x.com/2021/09/20/4GC28I.png" alt="4GC28I.png"></a></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><a href="https://imgtu.com/i/4GC4r8"><img src="https://z3.ax1x.com/2021/09/20/4GC4r8.png" alt="4GC4r8.png"></a></p>
<h2 id="LL-1-文法判别"><a href="#LL-1-文法判别" class="headerlink" title="LL(1)文法判别"></a>LL(1)文法判别</h2><p>判别步骤：</p>
<h3 id="1-求出能推出ε的非终结符"><a href="#1-求出能推出ε的非终结符" class="headerlink" title="1. 求出能推出ε的非终结符"></a>1. 求出能推出ε的非终结符</h3><h3 id="2-计算FIRST集"><a href="#2-计算FIRST集" class="headerlink" title="2.计算FIRST集"></a>2.计算FIRST集</h3><ol>
<li><p>若$x\in V_T$，则$first(x)={x}$</p>
</li>
<li><p>若$x\in V_N,x\rightarrow a…,a\in V_T$，则$a\in first(x)$</p>
</li>
<li><p>若$x\in V_N,x \rightarrow \epsilon$，则$\epsilon \in first(x)$</p>
</li>
<li><p>若$x\in V_N$，且有产生式$x \rightarrow Y_1Y_2…Y_n$，其中，$Y_1,Y_2,…Y_n\in V_N$</p>
<p>当$Y_1,Y_2,…Y_{i-1}$都能推导出$\epsilon$时，</p>
<p>则 $first(Y_1)-{\epsilon}\in first(x)$，一直到$i-1$，$first(Y_i)\in first(x)$</p>
<p>当$Y_1,Y_2,…Y_n$都可以推出$\epsilon$时，</p>
<p>则 $first(x) = first(Y_1)-{\epsilon} \cup…\cup first(Y_n)-{\epsilon}\cup {\epsilon}$</p>
</li>
</ol>
<h3 id="3-计算FOLLOW集"><a href="#3-计算FOLLOW集" class="headerlink" title="3.计算FOLLOW集"></a>3.计算FOLLOW集</h3><ol>
<li>设S为开始符号，把#加入Follow(S)中（#为句子括号）</li>
<li>若$A \rightarrow \alpha B \beta$，则把$First(\beta)-{\epsilon}$加入$Follow(B)$，如果$\beta \implies \epsilon$，则把$Follow(A)$加入$Follow(B)$</li>
<li>反复2，直到每个$V_N$的$Follow$不再增大</li>
</ol>
<h3 id="4-计算SELECT集"><a href="#4-计算SELECT集" class="headerlink" title="4.计算SELECT集"></a>4.计算SELECT集</h3><p>给定上下文无关文法的产生式$A \rightarrow \alpha,A \in V_N, \alpha \in V^*$</p>
<ol>
<li><p>若$\alpha$ 不可推出 $ε$，则$SELECT(A→α)= First(α)$</p>
</li>
<li><p>若$\alpha$ 可推出 $ε$，则$SELECT(A→α)= (First(α)-{ε})∪Follow(A)$</p>
</li>
</ol>
<h3 id="5-判别是否是LL-1-文法"><a href="#5-判别是否是LL-1-文法" class="headerlink" title="5.判别是否是LL(1)文法"></a>5.判别是否是LL(1)文法</h3><p>左部相同的产生式的SELECT集的交集均为空。 </p>
<h2 id="确定的自顶向下分析方法"><a href="#确定的自顶向下分析方法" class="headerlink" title="确定的自顶向下分析方法"></a>确定的自顶向下分析方法</h2><h3 id="非LL-1-到LL-1"><a href="#非LL-1-到LL-1" class="headerlink" title="非LL(1)到LL(1)"></a>非LL(1)到LL(1)</h3><p>提取左公因子</p>
<p>消除左递归</p>
<h3 id="递归子程序法"><a href="#递归子程序法" class="headerlink" title="递归子程序法"></a>递归子程序法</h3><p>对文法中每个非终结符编写一个递归过程，每个过程的功能是识别由该非终结符推出的串，当某非终结符的产生式有多个候选时能够按LL(1)形式可唯一地确定选择某个候选进行推导。</p>
<h3 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h3><p>（1）提取左公共因子，消除左递归</p>
<p>（2）判断文法是否为LL(1)文法</p>
<p>（3）若是，构造预测分析表；</p>
<p>​    否则，不能进行“确定的自顶向下”分析</p>
<p>（4）预测分析程序根据“预测分析表”并利用“分析栈”，对输入串进行分析</p>
<h1 id="自底向上优先分析法"><a href="#自底向上优先分析法" class="headerlink" title="自底向上优先分析法"></a>自底向上优先分析法</h1><p>自底向上分析方法，也称<strong>移进-归约</strong>分析法。</p>
<p>实现思想：<br>对输入符号串自左向右进行扫描，并将输入符逐个移入一个后进先出栈中，边移入边分析，一旦栈顶符号串形成某个句型的句柄或可归约串时，就用该产生式的左部非终结符代替相应右部的文法符号串，这称为归约。<br>重复这一过程，直到栈中只剩文法的开始符号时，则分析成功，也就确认输入串是文法的句子。</p>
<p>自底向上分析的策略：移进-归约分析。<br><strong>移进就是将一个终结符推进符号栈</strong><br><strong>归约就是将0个或多个符号从栈中弹出，根据产生式将一个非终结符压入符号栈</strong><br>移进-归约过程是规范推导（最右推导）的逆过程，所以它是规范归约。<br>何时移进？何时归约？<br>自底向上分析的关键：在分析过程中如何确定“句柄”。即：确定何时可以归约栈顶的符号串。</p>
<h2 id="简单优先分析法"><a href="#简单优先分析法" class="headerlink" title="简单优先分析法"></a>简单优先分析法</h2><p>先按照一定原则，求出文法所有符号（VT和VN）之间的优先关系；再按照优先关系确定归约过程中的句柄。</p>
<h3 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h3><p><a href="https://imgtu.com/i/4gut8x"><img src="https://z3.ax1x.com/2021/09/27/4gut8x.png" alt="4gut8x.png"></a></p>
<p>1.拓广文法 S’ $\rightarrow$ #S#</p>
<p>2.构造优先关系表</p>
<p>3.判断是否为简单优先文法</p>
<p>4.根据优先关系表分析句子</p>
<p><strong>满足以下条件的文法是简单优先文法</strong><br>（1）在文法符号集V中，任意两个符号之间最多只有一种优先关系。<br>（2）在文法中，任意两个产生式没有相同的右部。<br>（3）不含空产生式。</p>
<p>构造相应优先关系矩阵，并将文法的产生式保存，设置符号栈S，算法步骤如下：</p>
<p>1.将输入符号串a1a2a3…an# 依次逐个存入符号栈S中，直到遇到栈顶符号$a_i$下一个待输入符号$a_j$时为止。</p>
<p>2.栈顶当前符号$a_i$为句柄尾，由此向左在栈中找句柄的头符号$a_k$，即找到$a_{k-1}&lt;a_k$为止。</p>
<p>3.找到句柄$a_k…a_i$，在文法的产生式中查找右部为$a_k…a_i$的产生式，若找到则用相应左部代替句柄，若找不到则为出错，这时可断定输入串不是该文法的句子。</p>
<p>4.重复上述三步，直到归约完所有输入符号串为止。 （此时栈中只剩文法的开始符号）</p>
<p><a href="https://imgtu.com/i/4gMhNj"><img src="https://z3.ax1x.com/2021/09/27/4gMhNj.png" alt="4gMhNj.png"></a></p>
<h2 id="算符优先分析"><a href="#算符优先分析" class="headerlink" title="算符优先分析"></a>算符优先分析</h2><p>主要思想：<br>对文法按照一定规则，求出VT之间的优先关系；再按照这种优先关系来确定可归约串。<br>实现步骤：<br>拓广文法 S’ $\rightarrow$ #S#<br>构造算符优先关系表<br>判断是否为算符优先文法（OPG文法）<br>根据优先关系表分析句子</p>
<h3 id="优先关系-1"><a href="#优先关系-1" class="headerlink" title="优先关系"></a>优先关系</h3><p><a href="https://imgtu.com/i/4g8Rte"><img src="https://z3.ax1x.com/2021/09/27/4g8Rte.png" alt="4g8Rte.png"></a></p>
<h3 id="优先关系表的构造"><a href="#优先关系表的构造" class="headerlink" title="优先关系表的构造"></a>优先关系表的构造</h3><p><a href="https://imgtu.com/i/4gGUDP"><img src="https://z3.ax1x.com/2021/09/27/4gGUDP.png" alt="4gGUDP.png"></a></p>
<h3 id="算符优先文法的定义"><a href="#算符优先文法的定义" class="headerlink" title="算符优先文法的定义"></a>算符优先文法的定义</h3><p>–不含空产生式</p>
<p>–任何产生式右部不包含两个相邻的非终结符</p>
<p>–任何两个终结符之间优先关系唯一</p>
<p>归约过程中，只考虑终结符之间的优先关系来确定句柄，而与非终结符无关。这样去掉了单个非终结符的归约，所以用算符优先分析法的规约过程不是规范归约。<br>为解决在算符优先分析过程中如何寻找句柄，引进最左素短语的概念</p>
<p><strong>素短语</strong></p>
<p> 设有文法G[S]，其句型的素短语是一个短语，它至少包含一个终结符，且除自身外不再包含其他素短语。</p>
<p>最左素短语：句型最左边的素短语。</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/2021/08/03/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h1 id="扫描线求面积"><a href="#扫描线求面积" class="headerlink" title="扫描线求面积"></a>扫描线求面积</h1><span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(int i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, cnt;</span><br><span class="line">ll X[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScanLine</span> &#123;</span></span><br><span class="line">    ll l, r, h, mark;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ScanLine&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; rhs.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;line[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">    ll l, r, sum, len;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll x, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    tr[x].l = l, tr[x].r = r;</span><br><span class="line">    tr[x].len = <span class="number">0</span>;</span><br><span class="line">    tr[x].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(x), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(x), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll l = tr[x].l, r = tr[x].r;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].sum)</span><br><span class="line">        tr[x].len = X[r + <span class="number">1</span>] - X[l];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tr[x].len = tr[<span class="built_in">ls</span>(x)].len + tr[<span class="built_in">rs</span>(x)].len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll x, ll L, ll R, ll c)</span> </span>&#123;</span><br><span class="line">    ll l = tr[x].l, r = tr[x].r;</span><br><span class="line">    <span class="keyword">if</span> (X[r + <span class="number">1</span>] &lt;= L || R &lt;= X[l])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= X[l] &amp;&amp; X[r + <span class="number">1</span>] &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].sum += c;</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">ls</span>(x), L, R, c);</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rs</span>(x), L, R, c);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x1, y1, x2, y2;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        X[<span class="number">2</span> * i - <span class="number">1</span>] = x1, X[<span class="number">2</span> * i] = x2;</span><br><span class="line">        line[<span class="number">2</span> * i - <span class="number">1</span>] = ScanLine&#123; x1, x2, y1, <span class="number">1</span> &#125;;</span><br><span class="line">        line[<span class="number">2</span> * i] = ScanLine&#123; x1, x2, y2, <span class="number">-1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(line + <span class="number">1</span>, line + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>);</span><br><span class="line">    ll tot = <span class="built_in">unique</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>) - X - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, tot - <span class="number">1</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, line[i].l, line[i].r, line[i].mark);</span><br><span class="line">        ans += tr[<span class="number">1</span>].len * (line[i + <span class="number">1</span>].h - line[i].h);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>计网复习</title>
    <url>/2021/06/18/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h2><span id="more"></span>

<p>网络：节点和链路（Node and Link）</p>
<p>互联网：多个网络互联起来</p>
<p>Internet：全球最大的，开放的采用TCP/IP协议的网络</p>
<p>ISP: Internet Service Provider（电信、移动、联通……）ISP继续分层。</p>
<p>RFC(request for comments)：一小部分为因特网标准。</p>
<h2 id="三种交换"><a href="#三种交换" class="headerlink" title="三种交换"></a>三种交换</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>建立链接</p>
<p>通话</p>
<p>释放链接</p>
<p>效率太低，不适用计算机交换</p>
<h3 id="分组交换（报文交换升级）"><a href="#分组交换（报文交换升级）" class="headerlink" title="分组交换（报文交换升级）"></a>分组交换（报文交换升级）</h3><p>分组之后添加首部</p>
<p>可以随时发送，不需要先建立链接</p>
<h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p>自治系统及其链接（见作业）</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>技术，使用者，传输介质，拓扑结构，覆盖范围</p>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>速率</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>从某一点到另一点，所能通过的最高数据率（出口带宽）单位也是b/s</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>单位时间通过某个网络的数据量</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><h4 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h4><p>分组长度/发送速率</p>
<h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p>信道长度/电磁波传播速率</p>
<h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h4><h3 id="时延带宽积（以比特为单位的链路长度）"><a href="#时延带宽积（以比特为单位的链路长度）" class="headerlink" title="时延带宽积（以比特为单位的链路长度）"></a>时延带宽积（以比特为单位的链路长度）</h3><p>传播时延$\times$带宽</p>
<h3 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h3><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率：有百分之几的时间是被利用的（一般不超过50%）</p>
<p>网络利用率：全网络利用率的加权平均</p>
<h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p>分组误码，网络拥塞</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="*计算机网络体系结构"></a>*计算机网络体系结构</h2><p>OSI：物理，链路，网络，运输，会话，表示，应用；我们学习把会话，表示省掉</p>
<p>TCP/IP：接口层，网际层，运输层，应用层</p>
<p>说穿了，只有网际层（IP)，运输层(TCP,UDP)，应用层(HTTP,STMP;DNS,RTP)</p>
<h3 id="分层的原因"><a href="#分层的原因" class="headerlink" title="分层的原因"></a>分层的原因</h3><p>把大问题划分为小问题</p>
<h3 id="各层次作用"><a href="#各层次作用" class="headerlink" title="各层次作用"></a>各层次作用</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>传输媒介，物理接口，信号表示</p>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><p>标识主机（MAC地址），区分出地址和数据，协调主机争用主机</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>IP，前三个数字标识网络</p>
<p>路由选择</p>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>进程之间的通信问题</p>
<p>处理传错的问题</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>特定的网络应用</p>
<p>我的理解：首先确定怎么交流，手语？口语？01？（物理层）；然后是一个村里面交流（链路层）；因为跨村交流（网络层）；万一信息再传的过程中搞错了怎么办？（运输层）；最后对应某一件具体的事采用啥规矩去办（应用层）</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>实体：硬件或软件进程</p>
<p>对等实体：层次相同的实体</p>
<p>协议：控制两个对等实体的通信规则集合</p>
<p>协议三要素：</p>
<p>语法：信息格式</p>
<p>语义：双方要完成的操作</p>
<p>同步：时序关系</p>
<p>服务：本层可以对上一层提供服务</p>
<p>服务访问点：相邻两层实体交换信息的逻辑接口，用于区分服务类型。</p>
<p>数据链路层：类型</p>
<p>网络层：协议字段</p>
<p>运输层：端口号</p>
<p>协议数据单元PDU：对等层次之间传送的数据包</p>
<p>物理层：比特流</p>
<p>链路层：帧</p>
<p>网络层：分组</p>
<p>运输层：TCP报文段（segment）/UDP用户数据报（datagram）</p>
<p>应用层：报文（message）</p>
<p>服务数据单元SDU：同一系统中，层与层之间的数据包</p>
<h1 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h1><p>奈氏：$2W \ baut = 2W \ 码元/s= 2Wlog_2(X)$</p>
<p>香农公式：$c=Wlog_2(1+\frac SN)$</p>
<h1 id="链路层-1"><a href="#链路层-1" class="headerlink" title="链路层"></a>链路层</h1><p>链路：节点到节点的物理线路</p>
<p>数据链路：把实现的通信协议的硬件和软件加到链路上</p>
<p>链路层以帧传输</p>
<p>主要是三个问题：封装成帧，差错检测，可靠传输</p>
<p>以太网媒体接入控制采用：CSMA/CD</p>
<p>802.11局域网媒体接入控制协议：CSMA/CA</p>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>在上层交付的PDU添加帧头和帧尾，帧头和帧尾包含控制信息，帧定界就是它们的作用之一。</p>
<p>透明数据传输：对上层的数据没有限制。</p>
<p>高级数据链路控制协议：HDLC用帧头和帧尾的标志字段作为帧定界符，其值为01111110；HDLC为了实现透明传输，在连续5个1后面插入0。</p>
<p>MTU：帧的数据部分长度上限。</p>
<h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>在数据后面添加以为奇偶校验位，1为奇</p>
<h3 id="循环冗余检测CRC"><a href="#循环冗余检测CRC" class="headerlink" title="循环冗余检测CRC"></a>循环冗余检测CRC</h3><p>约定好一个生成多项式</p>
<p>发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加到待传输数据的后面一起传输。</p>
<p>接收方通过生成多项式来计算数据是否产生误码。</p>
<h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>比特差错（链路），分组丢失、失序、重复</p>
<h3 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h3><p>DATA丢失，<strong>设置超时重传</strong></p>
<p>ACK丢失导致重复，<strong>DATA添加序号</strong></p>
<p>ACK迟到，重发DATA，再发一次ACK导致发送方不知道是哪个ACK，<strong>ACK添加序号</strong></p>
<p>信道利用率：$U=\frac {T_D}{T_D+RTT+T_A} \approx \frac {T_D}{T_D+RTT}$</p>
<h3 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h3><p>发送方：</p>
<p>发送窗口尺寸:$1 \lt W_T \le 2^n-1 $，n是构成分组序号的比特数。</p>
<p>等于1退化为SW，大于$2^n-1$接收方无法分辨新旧数据</p>
<p>接收方：</p>
<p>接收窗口为1</p>
<h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p>接收方窗口大于1，小于等于发送窗口，如果大于，接收方无法分辨新旧数据。</p>
<p>接收方每次都会发一个确认帧</p>
<h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h2><p>为点对点传输提供一个标准方法。</p>
<p>对各协议数据报封装成帧</p>
<p>链路控制协议LCP</p>
<p>一套网络控制协议NCPs</p>
<p>透明传输：异步传输采用字节填充法，同步传输采用比特填充法</p>
<p><a href="https://imgtu.com/i/R12Mgx"><img src="https://z3.ax1x.com/2021/06/25/R12Mgx.png" alt="R12Mgx.png"></a></p>
<h2 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h2><h3 id="静态划分"><a href="#静态划分" class="headerlink" title="静态划分"></a>静态划分</h3><p>信道复用：</p>
<p>复用：通过一条物理线路，同时传输多路用户信号</p>
<p>当网络传输容量大于多条单一信道传输的总通信量时，可利用复用技术再一条物理线路上建立多条通信信道来充分利用传输媒体带宽。</p>
<h4 id="频分FDM"><a href="#频分FDM" class="headerlink" title="频分FDM"></a>频分FDM</h4><p>所用用户占用不同的频带资源</p>
<h4 id="时分TDM"><a href="#时分TDM" class="headerlink" title="时分TDM"></a>时分TDM</h4><p>所用用户在不同的时间占用同样的频带宽度</p>
<h4 id="波分WDM"><a href="#波分WDM" class="headerlink" title="波分WDM"></a>波分WDM</h4><p>就是光的FDM</p>
<h4 id="码分CDM-CDMA"><a href="#码分CDM-CDMA" class="headerlink" title="码分CDM(CDMA)"></a>码分CDM(CDMA)</h4><p>Code Division Multiple Access</p>
<p>每一个比特时间再划分为m个短的间隔，成为码片，通常m取64或128</p>
<p>用CDMA的每一个站指派一个唯一的m bit码片序列</p>
<p>发比特1，就发自己的那个码片序列，发比特0，就发自己码片序列的反码</p>
<p>码片序列挑选原则：</p>
<p>不同，相互正交</p>
<p><a href="https://imgtu.com/i/R1Wshj"><img src="https://z3.ax1x.com/2021/06/25/R1Wshj.png" alt="R1Wshj.png"></a></p>
<h3 id="动态接入"><a href="#动态接入" class="headerlink" title="动态接入"></a>动态接入</h3><h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p>Carrier Sense Multiple Access/Collision Detection</p>
<p>载波监听多址接入/碰撞检测</p>
<p>多址接入MA：多个站链接在一条总线上</p>
<p>载波监听CS：每个站发送帧之前要先检测一下总线上是否有其他站点在发送帧（先听后说）</p>
<p>如果检测到总线空闲96比特时间就发送这个帧</p>
<p>碰撞检测CD：边说边听</p>
<p>最小帧长为64字节</p>
<p><a href="https://imgtu.com/i/R3ZxeA"><img src="https://z3.ax1x.com/2021/06/25/R3ZxeA.png" alt="R3ZxeA.png"></a></p>
<p><a href="https://imgtu.com/i/R3ePW8"><img src="https://z3.ax1x.com/2021/06/25/R3ePW8.png" alt="R3ePW8.png"></a></p>
<h4 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h4><p>Carrier Sense Multiple Access/Collision Avoidance</p>
<p>802.11无线局域网使用CSMA/CA协议,再CSMA上增加一个碰撞避免CA</p>
<p>由于不可能避免避免所有碰撞，使用数据链路层确认机制（SW）保证数据被正确接收</p>
<p>媒体接入控制方式：</p>
<p>DCF：分布式协调功能Distributed Coordinateion Function。 在DCF下，没有中心控制站点，每个站点使用CSMA/CA争用信道来获取发送权。</p>
<p>PCF：点协调功能</p>
<p>IFS：帧间间隔InterFrame Space，所有的的站点必须在持续检测到信道空闲一段指定时间后才能发送帧</p>
<p>高优先级帧等待时间更短</p>
<p>SIFS：最短帧间间隔28$\mu s$</p>
<p>DIFS：DCF帧间间隔128$\mu s$，在DCF方式中发送数据帧和管理帧</p>
<p>允许信道预约：RTS请求发送，CTS允许发送</p>
<h2 id="MAC-IP-ARP"><a href="#MAC-IP-ARP" class="headerlink" title="MAC,IP,ARP"></a>MAC,IP,ARP</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p>Mediea Access Control</p>
<p>IP地址时TCP/IP体系结构的网际层所使用的地址，ARP协议属于TCP/IP体系结构的网际层，作用是将已知设备所分配的IP，获取设备的MAC</p>
<p>MAC地址是对各个接口的唯一标识</p>
<p>多播MAC地址，第二个16进制数是奇数。</p>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>网络编号，主机编号</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>ARP高速缓存表，ARP请求报文（广播），响应报文为单播帧</p>
<p>ARP只能在一段链路上使用</p>
<h2 id="集线器与交换机"><a href="#集线器与交换机" class="headerlink" title="集线器与交换机"></a>集线器与交换机</h2><p>集线器只工作在物理层，只是简单的转发，不进行碰撞检测，使用集线器的星型网络实际上可以看作是总线网。</p>
<p>交换机工作在全双工方式；有并行性，可以同时多对接口连通，没有碰撞；只工作在链路层，收到帧以后，在帧交换表查找，帧的目的MAC地址和对应的接口号。</p>
<h3 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h3><p>生成树协议STP，为了避免震荡、网络风暴等问题</p>
<h3 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h3><p>交换机接口分为Trunk和Access</p>
<h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><p>实现网络互联。</p>
<p>主要问题：可靠传输、寻址、路由选择</p>
<h2 id="提供两种服务"><a href="#提供两种服务" class="headerlink" title="提供两种服务"></a>提供两种服务</h2><h3 id="面向链接的虚电路服务"><a href="#面向链接的虚电路服务" class="headerlink" title="面向链接的虚电路服务"></a>面向链接的虚电路服务</h3><p>建立网络层链接：VC虚电路Virtual Circuit</p>
<h3 id="无连接数据报服务"><a href="#无连接数据报服务" class="headerlink" title="无连接数据报服务"></a>无连接数据报服务</h3><p>可靠通信由用户主机保证</p>
<p>不需要建立网络层链接</p>
<p>每个分组可以走不同的路径</p>
<p>每个分组首部必须携带主机的完整地址</p>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h3><p>A：0开头，8位</p>
<p>B：10开头，16位</p>
<p>C：110开头，24位</p>
<p>D：1110开头，多播地址；E：1111开头</p>
<p>ABC才可以分配给主机、路由器接口</p>
<p>最小的本地环回测试地址：127.0.0.1</p>
<h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p>引入掩码</p>
<h3 id="无分类编址"><a href="#无分类编址" class="headerlink" title="无分类编址"></a>无分类编址</h3><p>无分类路由选择CIDR，Classless Inter-Domain Routing</p>
<p>/20：前20个比特拿来当网络号</p>
<p>路由聚合（超网）：</p>
<p>找共同前缀</p>
<p>超时重传时间：</p>
<p>$RTO=RTT_S+4 \times RTT_D$</p>
<p>加权平均往返时间：</p>
<p>$RTT_{S1}=RTT_1$</p>
<p>$RTT_S=(1-\alpha)RTT_S+\alpha \times RTT,(\alpha=0.125)$</p>
<p>RTT偏差的加权平均RTTD：</p>
<p>$RTT_{D1}=RTT_1 \div 2$</p>
<p>$RTT_D=(1-\beta)RTT_D+\beta \times |RTT_S-RTT|,(\beta = 0.25)$</p>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>距离直连为1，好路由是通过路由器最少的路。</p>
<p>只和相邻路由器交换信息</p>
<p>刚开始工作，只知道自己到直连网络的距离为1</p>
<p>每个路由器和相邻路由器交换信息</p>
<p>每个路由器都知道到本AS内各个网络的最短距离和下一跳地址，称为收敛</p>
<h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>每个路由器都会产生链路状态通告LSA，Link State Advertisement，LSA中包含以下内容：</p>
<p>直连网络链路状态信息</p>
<p>邻居路由器链路状态信息</p>
<p>LSA被封装在链路状态更新分组LSU中，采用洪泛法发送</p>
<p>使用OSPF的路由器都有一个链路状态数据库LSDB，用于存储LSA</p>
<p>比如有R1,R2两个路由器：</p>
<p>周期性发送问候分组</p>
<p>数据库描述分组</p>
<p>如果R1发现缺少某些链路状态，R1发送链路状态请求分组</p>
<p>R2收到请求，发链路状态更新分组给R1</p>
<p>R1再发链路状态确认分组</p>
<p>每30分钟，或者发生变化的时候，发送链路状态更新分组</p>
<p>OSPF在多点接入网络中的路由器邻居关系：</p>
<p>选举指定路由器DR，Designated router和BDR，Backup Designated router</p>
<p>所有的非DR/BDR之和DR/BDR建立邻居关系</p>
<p>OSPF将AS分为更小的范围</p>
<h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为“BGP发言人”</p>
<p>BGP发言人要交换路由信息，必须建立TCP连接，端口号为179</p>
<p>在TCP交换BGP报文建立BGP会话</p>
<p>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议，比如RIP,OSPF</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>为了更有效的转发IP数据报，使用网际控制报文协议</p>
<h4 id="差错报告"><a href="#差错报告" class="headerlink" title="差错报告"></a>差错报告</h4><p>终点不可达：路由器或主机不能交付数据报的时候，就向源点交付终点不可达报文。</p>
<p>源点抑制：路由器或者主机由于拥塞而丢弃数据，向源点发送抑制报文，使源点放慢发送速率</p>
<p>时间超过：TTL=0，当终点在预先规定的时间内不能收到一个数据报的全部数据片时，把已知收到的数据报片都丢弃，并发送时间超过报文</p>
<p>参数问题：检验和有问题，出现误码，丢弃，并发送参数问题</p>
<p>改变路由：发现还有更好的路</p>
<p>ICMP差错报告报文不再发送ICMP差错报告报文</p>
<p>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</p>
<p>多播地址、特殊地址不发送</p>
<h4 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h4><p>回送请求和回答：</p>
<p>ICMP回送请求报文时由主机或路由器向一个特定的目的主机发出的询问</p>
<p>用来测试目的站是否可达</p>
<p>时间戳请求和：</p>
<p>进行始终同步和测量时间</p>
<h4 id="分组网间探测PING"><a href="#分组网间探测PING" class="headerlink" title="分组网间探测PING"></a>分组网间探测PING</h4><p>用来测试主机或路由器间的连通性</p>
<p>直接使用网际层的ICMP</p>
<p>使用ICMP回送请求和回答报文</p>
<h4 id="跟踪路由"><a href="#跟踪路由" class="headerlink" title="跟踪路由"></a>跟踪路由</h4><p>测试源主机到目的主机要经过哪些路由</p>
<h2 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h2><p>软件定义网络</p>
<h3 id="流表"><a href="#流表" class="headerlink" title="流表"></a>流表</h3><p>特定流的策略表项集合，负责数据包的查找转发</p>
<p>分为</p>
<p>包头域：链路层、网络层、传输层大部分标识</p>
<p>计数器：用于统计数据流量的相关信息</p>
<p>动作表：对应0到多个动作，如果没有定义转发动作，数据包丢失</p>
<h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p>虚拟专用网，Virtual Private Network</p>
<p>利用公用的因特网作为本机构各专用网之间的通信载体，就是虚拟的专用网</p>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>就是路由器拿一个全球IP来和私有IP转换</p>
<h1 id="运输层-1"><a href="#运输层-1" class="headerlink" title="运输层"></a>运输层</h1><p>底下实现了主机到主机的通信</p>
<p>实际上是需要进程到进程，运输层实现这个</p>
<h2 id="端口号、复用于分用"><a href="#端口号、复用于分用" class="headerlink" title="端口号、复用于分用"></a>端口号、复用于分用</h2><p>TCP/IP体系使用端口号使用16比特，0~65535</p>
<p>熟知的端口号：0~1023，</p>
<p>FTP:21/20,</p>
<p>HTTP:80,</p>
<p>DNS:53</p>
<p>1024~49151：为没有熟知端口号的应用程序使用</p>
<p>49152~65535：留给客户进程选择暂时使用</p>
<p>进程</p>
<p>TCP/IP体系应用层常用协议所使用的运输层熟知端口号</p>
<p>UDP</p>
<p>RIP:520</p>
<p>DNS:53</p>
<p>TFTP:69</p>
<p>DHCP:67/68</p>
<p>TCP</p>
<p>SMTP:25</p>
<p>FTP:21/20</p>
<p>BGP:179</p>
<p>HTTP:80</p>
<p>HTTPS:443</p>
<h2 id="UDP-TCP"><a href="#UDP-TCP" class="headerlink" title="UDP TCP"></a>UDP TCP</h2><p>UDP无连接，TCP有链接</p>
<p>TCP只可以单播</p>
<p>UDP面向应用报文</p>
<p>TCP面向字节流</p>
<p>UDP的误码，丢失等问题，直接丢掉</p>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>就是让别人别发太快了，TCP接收方利用自己的接收窗口大小，来限制发送方发送窗口的大小，TCP发送方收到接收方的0窗口通知之后，启动持续计时器。持续计时器超时后，向接收方发送0窗口探测报文</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>拥塞窗口cwnd维护原则：只要网络没有出现拥塞，就一直增大，出现了拥塞就减小</p>
<p>判断拥塞的依据：没有按时收到确认报文</p>
<p>发送方将拥塞窗口作为发送窗口swnd=cwnd</p>
<p>慢开始门限ssthresh</p>
<p>cwnd&lt;ssthresh，使用慢开始算法；</p>
<p>cwnd&gt;ssthresh，使用拥塞避免算法；</p>
<p>cwnd=ssthresh，两种算法都可以</p>
<p>慢开始，拥塞避免，快重传，快恢复</p>
<p><a href="https://imgtu.com/i/RmWi8S"><img src="https://z3.ax1x.com/2021/06/23/RmWi8S.png" alt="RmWi8S.png"></a></p>
<h2 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h2><p>不可直接使用某次测量得到的RTT样本来计算超时重传时间RTO</p>
<p>利用每次测量得到的RTT样本，计算加权平均往返时间RTTs</p>
<p>新的$new\ RTTs=(1-\alpha)\times old\ RTTs+\alpha \times new\  RTT\ sample \ (\alpha=0.125)$</p>
<p>RTT偏差的加权平均RTTD：$RTT_{D1}=RTT_1 \div 2 $</p>
<p>新的RTTD：$RTT_{D} = (1-\beta) \times oldRTT_D+\beta\times|RTT_S-newRTT\ sample|\ (\beta=0.25)$</p>
<p>超时重传时间：$RTO=RTT_S+4 \times RTT_D$</p>
<p>每重传一次，RTO翻倍</p>
<p><a href="https://imgtu.com/i/RnWYTI"><img src="https://z3.ax1x.com/2021/06/23/RnWYTI.png" alt="RnWYTI.png"></a></p>
<h2 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h2><p>以字节为单位的滑动窗口实现可靠传输</p>
<p><a href="https://imgtu.com/i/RnTGgx"><img src="https://z3.ax1x.com/2021/06/23/RnTGgx.png" alt="RnTGgx.png"></a></p>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><h3 id="三次挥手"><a href="#三次挥手" class="headerlink" title="三次挥手"></a>三次挥手</h3><p><a href="https://imgtu.com/i/Rn7KQP"><img src="https://z3.ax1x.com/2021/06/23/Rn7KQP.png" alt="Rn7KQP.png"></a></p>
<p>三次是必须的</p>
<p><a href="https://imgtu.com/i/Rn7dyV"><img src="https://z3.ax1x.com/2021/06/23/Rn7dyV.png" alt="Rn7dyV.png"></a></p>
<h2 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h2><p><a href="https://imgtu.com/i/RnxPy9"><img src="https://z3.ax1x.com/2021/06/23/RnxPy9.png" alt="RnxPy9.png"></a></p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>高数</title>
    <url>/2021/10/12/%E9%AB%98%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数图像"><a href="#函数图像" class="headerlink" title="函数图像"></a>函数图像</h1><span id="more"></span>

<h2 id="sec-x"><a href="#sec-x" class="headerlink" title="$sec(x)$"></a>$sec(x)$</h2><iframe src="https://www.desmos.com/calculator/gcq15h2kfw?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<h2 id="csc-x"><a href="#csc-x" class="headerlink" title="$csc(x)$"></a>$csc(x)$</h2><iframe src="https://www.desmos.com/calculator/mdbdctrhqe?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<h2 id="arcsin-x"><a href="#arcsin-x" class="headerlink" title="$arcsin(x)$"></a>$arcsin(x)$</h2><iframe src="https://www.desmos.com/calculator/xxnu5xm9ex?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<h2 id="arccos-x"><a href="#arccos-x" class="headerlink" title="$arccos(x)$"></a>$arccos(x)$</h2><iframe src="https://www.desmos.com/calculator/v7mxcw3fbe?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<h1 id="常见不定积分"><a href="#常见不定积分" class="headerlink" title="常见不定积分"></a>常见不定积分</h1><p>$$<br>\int x^kdx=\frac{1}{k+1}x^{k+1}+C,k\neq-1<br>$$</p>
<p>$$<br>\int \frac 1 xdx=ln|x|+C<br>$$</p>
<p>$$<br>\int e^xdx=e^x+C;\int a^xdx=\frac {a^x} {lna}+C,a&gt;0 \ and\  a \neq 1<br>$$</p>
<p>$$<br>\int tanxdx=-ln|cosx|+C;\int cot xdx = ln |sinx|+C<br>$$</p>
<p>$$<br>\int \frac {dx} {cosx}=\int secxdx=ln|secx+tanx|+C<br>$$</p>
<p>$$<br>\int \frac {dx} {sinx}=\int cscxdx=ln|cscx-cotx|+C<br>$$</p>
<p>$$<br>\int sec^2xdx=tanx+C;\int csc^2x=-cot+C<br>$$</p>
<p>$$<br>\int secx\ tanxdx=secx+C;\int csc x\ cotxdx=-cscx+C<br>$$</p>
<p>$$<br>\int \frac {1} {a^2+x^2}dx = \frac 1 a arctan\frac x a+C<br>$$</p>
<p>$$<br>\int \frac 1 {\sqrt {a^2-x^2}}=arcsin\frac x a+C<br>$$</p>
<p>$$<br>\begin{cases}<br>\int \frac 1 {\sqrt {x^2+a^2}}=ln(x+\sqrt {x^2+a^2})+C \<br>\int \frac 1 {\sqrt {x^2-a^2}}=ln|x+\sqrt {x^2-a^2}|+C \<br>\end{cases}<br>$$</p>
<p>$$<br>\int \frac 1 {x^2-a^2}dx=\frac 1 {2a}ln|\frac {x-a}{x+a}|+C<br>$$</p>
<p>$$<br>\int \sqrt {a^2-x^2}dx=\frac {a^2} 2 arcsin\frac x a+\frac x 2 \sqrt {a^2-x^2}+C<br>$$</p>
<p>$$<br>\int sin^2dx=\frac x 2 - \frac {sin2x} 4+C<br>$$</p>
<p>$$<br>\int cos^2dx=\frac x 2 + \frac {sin2x} 4+C<br>$$</p>
<p>$$<br>\int tan^2 xdx = tanx-x+C<br>$$</p>
<p>$$<br>\int cot^2 xdx = -cotx-x+C<br>$$</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF TowPointer</title>
    <url>/2022/02/07/CF-TowPointer/</url>
    <content><![CDATA[<p>CF上一些双指针</p>
<span id="more"></span>

<h3 id="Meximum-Array"><a href="#Meximum-Array" class="headerlink" title="Meximum Array"></a><a href="https://codeforces.com/problemset/problem/1628/A">Meximum Array</a></h3><p><del>这个题让我怀疑智商</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            cnt[a[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ll&gt; ans;</span><br><span class="line">        ll i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            ll mex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt[mex] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(mex+<span class="number">1</span>)</span></span>;</span><br><span class="line">            ll cc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &lt; mex &amp;&amp; !vis[a[i]]) &#123;</span><br><span class="line">                    cc++;</span><br><span class="line">                    vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[a[i]]--;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (cc == mex)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(mex);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans)</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="New-Year-Concert"><a href="#New-Year-Concert" class="headerlink" title="New Year Concert"></a><a href="https://codeforces.com/problemset/problem/1632/D">New Year Concert</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll st[N][<span class="number">20</span>], lg[N], a[N], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll k = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; k) &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            st[i][k] = <span class="built_in">gcd</span>(st[i][k - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(ll l, ll r)</span> </span>&#123;</span><br><span class="line">    ll k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i], st[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    <span class="built_in">ST</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>, j = <span class="number">1</span>, cur = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; i &amp;&amp; <span class="built_in">qry</span>(j, i) &lt; i - j + <span class="number">1</span>; j++);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qry</span>(j, i) == i - j + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; cur) &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range-and-Partition"><a href="#Range-and-Partition" class="headerlink" title=" Range and Partition"></a><a href="https://codeforces.com/problemset/problem/1630/B"> Range and Partition</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], cnt[N];</span><br><span class="line">ll n, k;</span><br><span class="line"><span class="function">pll <span class="title">get</span><span class="params">(ll d)</span> </span>&#123;</span><br><span class="line">    ll mx = <span class="number">-1</span>;</span><br><span class="line">    pll res = &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="built_in">rep</span>(i, d + <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] - cnt[i - d - <span class="number">1</span>] &gt; mx) &#123;</span><br><span class="line">            mx = cnt[i] - cnt[i - d - <span class="number">1</span>];</span><br><span class="line">            res = &#123; i - d,i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll mid,<span class="keyword">bool</span> tag)</span> </span>&#123;</span><br><span class="line">    pll tmp = <span class="built_in">get</span>(mid);</span><br><span class="line">    ll x = tmp.first, y = tmp.second;</span><br><span class="line">    ll K = <span class="number">0</span>, sum = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= a[i] &amp;&amp; a[i] &lt;= y) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span> &amp;&amp; K &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            K++;</span><br><span class="line">            <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">                cout &lt;&lt; pre &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">            cout &lt;&lt; pre &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cnt[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            cnt[a[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        ll l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, <span class="number">0</span>))</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pll res = <span class="built_in">get</span>(l);</span><br><span class="line">        cout &lt;&lt; res.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">check</span>(l, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ATM-and-Students"><a href="#ATM-and-Students" class="headerlink" title="ATM and Students"></a><a href="https://codeforces.com/problemset/problem/1611/F">ATM and Students</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, s;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        ll res = <span class="number">0</span>, lx = <span class="number">0</span>, rx = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=n &amp;&amp; r&lt;= n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s+sum+a[r]&gt;=<span class="number">0</span> &amp;&amp; r&lt;=n)&#123;</span><br><span class="line">                sum += a[r++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r-l&gt;res)&#123;</span><br><span class="line">                res = r - l;</span><br><span class="line">                lx = l;</span><br><span class="line">                rx = r - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= a[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rx == <span class="number">0</span> &amp;&amp; lx == <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;lx&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;rx&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Seating-Arrangements-hard-version"><a href="#Seating-Arrangements-hard-version" class="headerlink" title="Seating Arrangements (hard version)"></a><a href="https://codeforces.com/problemset/problem/1566/D2">Seating Arrangements (hard version)</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: D2. Seating Arrangements (hard version)</span></span><br><span class="line"><span class="comment">// Contest: Codeforces - Codeforces Global Round 16</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/problemset/problem/1566/D2</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll s,id;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a,node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.s == b.s)</span><br><span class="line">			<span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">		<span class="keyword">return</span> a.s &lt; b.s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.s == b.s)</span><br><span class="line">		<span class="keyword">return</span> a.id &gt; b.id;</span><br><span class="line">	<span class="keyword">return</span> a.s &lt; b.s;</span><br><span class="line">&#125;</span><br><span class="line">node a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n*m)&#123;</span><br><span class="line">			cin&gt;&gt;a[i].s;</span><br><span class="line">			a[i].id = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n*m+<span class="number">1</span>);</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">			<span class="built_in">sort</span>(a+(i<span class="number">-1</span>)*m+<span class="number">1</span>,a+i*m+<span class="number">1</span>,cmp);</span><br><span class="line">			<span class="built_in">rep</span>(j,(i<span class="number">-1</span>)*m+<span class="number">1</span>,i*m)&#123;</span><br><span class="line">				<span class="built_in">rep</span>(k,j,i*m)&#123;</span><br><span class="line">					<span class="keyword">if</span>(a[k].id&gt;a[j].id)</span><br><span class="line">						ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Backspace"><a href="#Backspace" class="headerlink" title=" Backspace"></a><a href="https://codeforces.com/problemset/problem/1553/D"> Backspace</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: D. Backspace</span></span><br><span class="line"><span class="comment">// Contest: Codeforces - Harbour.Space Scholarship Contest 2021-2022 (open for everyone, rated, Div. 1 + Div. 2)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/problemset/problem/1553/D</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 2000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	ll T;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		string s,t;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">		ll n = s.<span class="built_in">size</span>(),m = t.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span>(m&gt;n)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">		t = <span class="string">&#x27; &#x27;</span> + t;</span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">		ll i = n;</span><br><span class="line">		<span class="built_in">dec</span>(j,m,<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(i&gt;=<span class="number">1</span> &amp;&amp; s[i] != t[j])&#123;</span><br><span class="line">				i-=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">				ok = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;(ok?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Integers-Have-Friends"><a href="#Integers-Have-Friends" class="headerlink" title="Integers Have Friends"></a><a href="https://codeforces.com/problemset/problem/1548/B">Integers Have Friends</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], d[N], st[N][<span class="number">25</span>], lg[N], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n) lg[i] = lg[i/<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll k = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;k)&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            st[i][k] = __gcd(st[i][k<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    ll k = lg[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> __gcd(st[l][k], st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            d[i] = <span class="built_in">abs</span>(a[i] - a[i<span class="number">-1</span>]);</span><br><span class="line">            st[i][<span class="number">0</span>] = d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ST</span>();</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll i = <span class="number">2</span>, j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; i &amp;&amp; <span class="built_in">qry</span>(j,i) == <span class="number">1</span>; j++);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">qry</span>(j,i) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans+<span class="number">1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Air-Conditioners"><a href="#Air-Conditioners" class="headerlink" title=" Air Conditioners"></a><a href="https://codeforces.com/problemset/problem/1547/E"> Air Conditioners</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N], L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll n, k;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">            a[i] = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, k)&#123;</span><br><span class="line">            cin &gt;&gt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, k)&#123;</span><br><span class="line">            cin &gt;&gt; a[b[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        ll p = INF;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">            p = <span class="built_in">min</span>(p + <span class="number">1</span>, a[i]);</span><br><span class="line">            L[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = INF;</span><br><span class="line">        <span class="built_in">dec</span>(i, n, <span class="number">1</span>)&#123;</span><br><span class="line">            p = <span class="built_in">min</span>(p + <span class="number">1</span>, a[i]);</span><br><span class="line">            R[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">min</span>(L[i], R[i]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PriceFixed"><a href="#PriceFixed" class="headerlink" title="PriceFixed"></a><a href="https://codeforces.com/problemset/problem/1539/D">PriceFixed</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.b &lt; b.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span> (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        cin &gt;&gt; v[i].a &gt;&gt; v[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v + <span class="number">1</span>, v + n + <span class="number">1</span>);</span><br><span class="line">    ll cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    ll l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=v[l].b)&#123;</span><br><span class="line">            cnt += v[l].a;</span><br><span class="line">            ans += v[l].a;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll mn = <span class="built_in">min</span>(v[r].a, v[l].b - cnt);<span class="comment">//后面还需要的，前面到达折扣还需要的</span></span><br><span class="line">            cnt += mn;</span><br><span class="line">            ans += <span class="number">2</span>*mn;</span><br><span class="line">            v[r].a -= mn;</span><br><span class="line">            <span class="keyword">if</span>(v[r].a == <span class="number">0</span>) </span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unstable-String"><a href="#Unstable-String" class="headerlink" title="Unstable String"></a><a href="https://codeforces.com/problemset/problem/1535/C">Unstable String</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        ll n = s.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">v</span>(<span class="number">2</span>,vector&lt;ll&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ll j = i - <span class="number">1</span>;</span><br><span class="line">            ll p = i &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                j = <span class="built_in">min</span>(j,<span class="built_in">max</span>(v[<span class="number">0</span>][p^<span class="number">1</span>],v[<span class="number">1</span>][p]));</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                j = <span class="built_in">min</span>(j,<span class="built_in">max</span>(v[<span class="number">0</span>][p],v[<span class="number">1</span>][p^<span class="number">1</span>]));</span><br><span class="line">            ans += i - j;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">                v[s[i]-<span class="string">&#x27;0&#x27;</span>][p] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maximum-Sum-of-Products"><a href="#Maximum-Sum-of-Products" class="headerlink" title="Maximum Sum of Products"></a><a href="https://codeforces.com/problemset/problem/1519/D">Maximum Sum of Products</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, a[N], b[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        pre[i] = a[i] * b[i] + pre[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = pre[n];</span><br><span class="line">    <span class="built_in">rep</span>(c,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ll cur = a[c] * b[c];</span><br><span class="line">        <span class="keyword">for</span>(ll l = c - <span class="number">1</span>, r = c + <span class="number">1</span>; l &gt;= <span class="number">1</span> &amp;&amp; r &lt;= n; l--,r++)&#123;</span><br><span class="line">            cur += a[l]*b[r] + a[r] * b[l];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,pre[l<span class="number">-1</span>]+pre[n]-pre[r]+cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(c,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ll cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll l = c, r = c + <span class="number">1</span>; l&gt;=<span class="number">1</span> &amp;&amp; r&lt;=n; l--,r++)&#123;</span><br><span class="line">            cur += a[l]*b[r] + a[r] * b[l];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,pre[l<span class="number">-1</span>]+pre[n]-pre[r]+cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Phoenix-and-Socks"><a href="#Phoenix-and-Socks" class="headerlink" title="Phoenix and Socks"></a><a href="https://codeforces.com/problemset/problem/1515/D">Phoenix and Socks</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll cntr[N],cntl[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll n, l, r;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cntl[i] = cntr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            ll x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=l)</span><br><span class="line">                cntl[x]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cntr[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(cntl,cntr);</span><br><span class="line">            <span class="built_in">swap</span>(l,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ll mn = <span class="built_in">min</span>(cntl[i],cntr[i]);</span><br><span class="line">            cntl[i] -= mn;</span><br><span class="line">            cntr[i] -= mn;</span><br><span class="line">            l -= mn;</span><br><span class="line">            r -= mn;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ll d = <span class="built_in">min</span>(l-r,cntl[i]/<span class="number">2</span>*<span class="number">2</span>);</span><br><span class="line">            ans+=d/<span class="number">2</span>;</span><br><span class="line">            l -= d;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (l-r)/<span class="number">2</span> + (l+r)/<span class="number">2</span>;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maximum-width"><a href="#Maximum-width" class="headerlink" title="Maximum width"></a><a href="https://codeforces.com/problemset/problem/1492/C">Maximum width</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">string s, t;</span><br><span class="line">ll l[N], r[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">    t = <span class="string">&#x27; &#x27;</span> + t;</span><br><span class="line">    ll j = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j]) &#123;</span><br><span class="line">            l[j] = i;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j--;</span><br><span class="line">    <span class="built_in">dec</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j])&#123;</span><br><span class="line">            r[j] = i;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,m)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,r[i] - l[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Building-a-Fence"><a href="#Building-a-Fence" class="headerlink" title="Building a Fence"></a><a href="https://codeforces.com/problemset/problem/1469/C">Building a Fence</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, k;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">bool</span> fg = <span class="number">1</span>;</span><br><span class="line">        ll up = k + a[<span class="number">1</span>], down = a[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt;= up || a[i] + k &lt; down - k + <span class="number">1</span>) &#123;</span><br><span class="line">                fg = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            up = <span class="built_in">min</span>(a[i] + <span class="number">2</span>*k - <span class="number">1</span>, up + k - <span class="number">1</span>);</span><br><span class="line">            down = <span class="built_in">max</span>(a[i] + <span class="number">1</span>, down - k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(down != a[n] + <span class="number">1</span>) fg = <span class="number">0</span>;</span><br><span class="line">        cout&lt;&lt;(fg?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Close-Tuples-hard-version"><a href="#Close-Tuples-hard-version" class="headerlink" title="Close Tuples (hard version)"></a><a href="https://codeforces.com/problemset/problem/1462/E2">Close Tuples (hard version)</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">namespace</span> Comb&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">2000000</span> + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> f[maxc], inv[maxc], finv[maxc];</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">               inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxc; i++)</span><br><span class="line">                       inv[i] = (mod - mod / i) * <span class="number">1ll</span> * inv[mod % i] % mod;</span><br><span class="line">               f[<span class="number">0</span>] = finv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxc; i++)</span><br><span class="line">               &#123;</span><br><span class="line">                       f[i] = f[i - <span class="number">1</span>] * <span class="number">1ll</span> * i % mod;</span><br><span class="line">                       finv[i] = finv[i - <span class="number">1</span>] * <span class="number">1ll</span> * inv[i] % mod;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (m &lt; <span class="number">0</span> || m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">return</span> f[n] * <span class="number">1ll</span> * finv[n - m] % mod * finv[m] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">               <span class="comment">// x_1 + x_2 + ... + x_n = m, x_i &gt;= 0</span></span><br><span class="line">               <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">C</span>(m + n - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Comb::C;</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    Comb::<span class="built_in">init</span>();</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        ll j = <span class="number">1</span>, i = <span class="number">1</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;i &amp;&amp; a[i] - a[j] &gt; k) j++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=n &amp;&amp; a[i] - a[j] &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i - j + <span class="number">1</span> &gt;= m)&#123;</span><br><span class="line">                    ans = (ans + <span class="built_in">C</span>(i-j,m<span class="number">-1</span>))%mod;</span><br><span class="line">                &#125;                </span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-Deletion"><a href="#String-Deletion" class="headerlink" title="String Deletion"></a><a href="https://codeforces.com/problemset/problem/1430/D">String Deletion</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll n; </span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        queue&lt;ll&gt; q;</span><br><span class="line">        ll tot = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(tot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>, del = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            del+=<span class="number">2</span>;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() == i)&#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                del++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (n-del+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lonely-Numbers"><a href="#Lonely-Numbers" class="headerlink" title=" Lonely Numbers"></a><a href="https://codeforces.com/problemset/problem/1423/K"> Lonely Numbers</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">vector&lt;ll&gt; pri;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:pri)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*x&gt;N)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            vis[i*x]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%x==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>)&#123;</span><br><span class="line">        ans[i] = ans[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) ans[i]++;</span><br><span class="line">        ll x = <span class="built_in">sqrt</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(x*x == i &amp;&amp; x!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[x])&#123;</span><br><span class="line">                ans[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        cout&lt;&lt;ans[n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sage’s-Birthday-hard-version"><a href="#Sage’s-Birthday-hard-version" class="headerlink" title="Sage’s Birthday (hard version)"></a><a href="https://codeforces.com/problemset/problem/1419/D2">Sage’s Birthday (hard version)</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; p,q,o;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=n/<span class="number">2</span>) p.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll np = p.<span class="built_in">size</span>(),nq = q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,np<span class="number">-1</span>) o.<span class="built_in">push_back</span>(q[i]),o.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    <span class="keyword">if</span>(np&lt;nq) o.<span class="built_in">push_back</span>(q[nq<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(o[i]&lt;o[i<span class="number">-1</span>] &amp;&amp; o[i]&lt;o[i+<span class="number">1</span>])</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;o[i]&lt;&lt; <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="k-Amazing-Numbers"><a href="#k-Amazing-Numbers" class="headerlink" title="k-Amazing Numbers"></a><a href="https://codeforces.com/problemset/problem/1416/A">k-Amazing Numbers</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">vector&lt;ll&gt; cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) cnt[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(n+<span class="number">5</span>,INF)</span></span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i],cnt[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ll pre = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">            ll sz = cnt[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">0</span>,sz<span class="number">-1</span>)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,cnt[i][j]-pre);</span><br><span class="line">                pre = cnt[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res,n-pre+<span class="number">1</span>);</span><br><span class="line">            ans[res] = <span class="built_in">min</span>(ans[res],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ans[i] = <span class="built_in">min</span>(ans[i],ans[i<span class="number">-1</span>]);</span><br><span class="line">            cout&lt;&lt;(ans[i]==INF?<span class="number">-1</span>:ans[i])&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Two-Platforms"><a href="#Two-Platforms" class="headerlink" title="Two Platforms"></a><a href="https://codeforces.com/problemset/problem/1409/E">Two Platforms</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N],l[N],r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll n,k,y;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) cin&gt;&gt;y;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        ll j = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;=n &amp;&amp; a[j]-a[i]&lt;=k;j++);</span><br><span class="line">            r[i] = j-i;</span><br><span class="line">        &#125;</span><br><span class="line">        j = n;</span><br><span class="line">        <span class="built_in">dec</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;=<span class="number">1</span> &amp;&amp; a[i]-a[j]&lt;=k;j--);</span><br><span class="line">            l[i] = i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        r[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) l[i] = <span class="built_in">max</span>(l[i],l[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">dec</span>(i,n,<span class="number">1</span>) r[i] = <span class="built_in">max</span>(r[i],r[i+<span class="number">1</span>]);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) ans = <span class="built_in">max</span>(ans,l[i]+r[i+<span class="number">1</span>]);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Chocolate-Bunny"><a href="#Chocolate-Bunny" class="headerlink" title=" Chocolate Bunny"></a><a href="https://codeforces.com/problemset/problem/1407/C"> Chocolate Bunny</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x&lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout.<span class="built_in">flush</span>();</span><br><span class="line">    ll z;</span><br><span class="line">    cin&gt;&gt;z;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ll mx = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        ll a = <span class="built_in">ask</span>(mx,i);</span><br><span class="line">        ll b = <span class="built_in">ask</span>(i,mx);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">            ans[mx] = a;</span><br><span class="line">            mx = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[i] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[mx] = n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;! &quot;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) cout&lt;&lt;ans[i]&lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TowPointer</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP</title>
    <url>/2021/12/14/TCP-IP/</url>
    <content><![CDATA[<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><span id="more"></span>

<p>是IP的补充，用于IP传输时的差错报告、拥塞控制、路径控制以及时间、掩码等信息的获取。 </p>
<h2 id="差错报告"><a href="#差错报告" class="headerlink" title="差错报告"></a>差错报告</h2><p>丢弃出错的IP数据报</p>
<p>向信源机报告差错，不纠错，纠错留给高层协议</p>
<p>报文的数据区包含出错数据报的首部及其前64比特的数据，帮助信源机确定出错分组</p>
<p>报文作为一般数据传输</p>
<h3 id="信宿不可达"><a href="#信宿不可达" class="headerlink" title="信宿不可达"></a>信宿不可达</h3><p>当路由器无法转发数据报，或信宿机无法向上层提交数据时，丢弃当前的IP数据报，并向信源发送ICMP信宿不可达报告。</p>
<ol>
<li>网络不可达 0</li>
<li>主机不可达 1</li>
<li>协议不可达 2</li>
<li>端口不可达 3</li>
</ol>
<h3 id="数据报超时"><a href="#数据报超时" class="headerlink" title="数据报超时"></a>数据报超时</h3><p>TTL超时：TTL减为0</p>
<p>分片重组超时：信宿机分片重组时会启动定时器</p>
<h3 id="数据报参数错"><a href="#数据报参数错" class="headerlink" title="数据报参数错"></a>数据报参数错</h3><p>路由器或信宿机发现IP首部的字段值有问题或空缺，就丢弃该数据报，并向信源发送ICMP数据报参数错报告。</p>
<h2 id="控制报文"><a href="#控制报文" class="headerlink" title="控制报文"></a>控制报文</h2><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>源抑制控制报文</p>
<p>为什么要源抑制：<strong>IP时无连接的，中间路由不会预留缓冲区。</strong>当大量IP数据报进入路由器或信宿机时，可以能会造成其缓冲区溢出，出现拥塞。</p>
<h4 id="源抑制步骤"><a href="#源抑制步骤" class="headerlink" title="源抑制步骤"></a>源抑制步骤</h4><p>发现拥塞：路由器或者信宿机如果因为<strong>缓冲区溢出</strong>而丢弃数据报，立即向丢弃数据报的信源发送ICMP源抑制报文</p>
<p>解决拥塞：信源机按一定的规则，<strong>降低去往相应信宿的数据报速率</strong>，直到不再收到更多的源抑制报文为止</p>
<p>恢复：如果信源机在<strong>一段时间没有收到相应源抑制报文</strong>，则认为此方向拥塞已解除，则<strong>逐渐恢复</strong>去往相应信宿的数据报发送速率。</p>
<h3 id="路径控制"><a href="#路径控制" class="headerlink" title="路径控制"></a>路径控制</h3><p>重定向报文：用于主机路由表的更新，实现路径控制。</p>
<p>路由器和主机都有路由表(可使用route print或netstat –r 命令查看) 。路由器的初始路由表只含直接相连网络或管理员设置的路由表；主机的初始路由表只包含默认网关。</p>
<p><strong>路由表用ICMP重定向报文进行更新</strong></p>
<h2 id="请求应答"><a href="#请求应答" class="headerlink" title="请求应答"></a>请求应答</h2><h3 id="回应请求与应答报文"><a href="#回应请求与应答报文" class="headerlink" title="回应请求与应答报文"></a>回应请求与应答报文</h3><p>作用：用来测试设备的网络可达性，以及设备IP协议是否正常工作。<br>ping命令：基于ICMP回应请求与应答报文。 </p>
<h3 id="时间戳请求与应答报文"><a href="#时间戳请求与应答报文" class="headerlink" title="时间戳请求与应答报文"></a>时间戳请求与应答报文</h3><p>作用：网络设备的存在时钟差异，而一些分布式应用要求各设备的时钟是同步的。此类报文可实现设备的时钟同步。<br>基本思路：设备通过此类报文，获取信息往返另一设备的时间戳信息，从而估算出设备间时钟差异，并进行相应调整。</p>
<h3 id="地址掩码请求与应答报文"><a href="#地址掩码请求与应答报文" class="headerlink" title="地址掩码请求与应答报文"></a>地址掩码请求与应答报文</h3><p>作用：获取设备所在网络的掩码。<br>应用：无盘机通过RARP获得IP地址后，可向所在网络的路由器发送ICMP地址掩码请求报文，获得所在网络掩码。</p>
<h3 id="路由器请求与通告报文"><a href="#路由器请求与通告报文" class="headerlink" title="路由器请求与通告报文"></a>路由器请求与通告报文</h3><p>作用：获取所在网络的默认路由器的IP地址。<br>实现过程：<strong>主机引导时会广播或组播路由器请求报文，所在网络的路由器收到后返回通告报文</strong>，通告本网络所有路由器地址和优先级，主机选择优先级高的作为其默认路由器。</p>
<h1 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h1><p>直接传递：在信宿网络中，直接传到信宿</p>
<p>间接传递：在非信宿网络中的传递过程</p>
<p>网关：网间连接器，在传输层上以实现网络互连，用于两个高层协议不同的网络互连</p>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><p>信宿地址一般采用信宿网络地址</p>
<p><strong>网络远少于主机</strong>，减小路由表<br>与网络拓扑结构相对应。网络拓扑中，只有路由器和网络，没有主机<br>主机的增减不会对路由表产生影响<br>减小使用和维护的开销，简化设备的设计和实现</p>
<h3 id="路由表字段"><a href="#路由表字段" class="headerlink" title="路由表字段"></a>路由表字段</h3><p>信宿地址：一般为信宿网络地址。特殊情况：特定主机路由表项中为信宿主机地址;在默认路由表项中为0.0.0.0</p>
<p>子网掩码：一般为信宿网络的掩码。在特定主机路由表项中为255.255.255.255; 默认路由表项中为0.0.0.0。</p>
<p>下一跳地址：间接交付：下一个路由器的入口地址;直接交付：<br>本路由器在信宿网络的出口地址</p>
<p>输出接口：指明数据报在本设备输出的接口。</p>
<p>度量：本设备到信宿机的距离，一般为跨越的路由器的个数，路由器到直连网络的跳数为1。</p>
<h3 id="路由表表项"><a href="#路由表表项" class="headerlink" title="路由表表项"></a>路由表表项</h3><h4 id="普通路由表项"><a href="#普通路由表项" class="headerlink" title="普通路由表项"></a>普通路由表项</h4><p>信宿网络地址 + 信宿网络的掩码</p>
<h4 id="特定主机路由表项"><a href="#特定主机路由表项" class="headerlink" title="特定主机路由表项"></a>特定主机路由表项</h4><p>信宿主机地址 + 255.255.255.255<br>作用：为特定主机指定路由，用于网络测试或安全等</p>
<h4 id="默认路由表项"><a href="#默认路由表项" class="headerlink" title="默认路由表项"></a>默认路由表项</h4><p>信宿地址0.0.0.0 + 掩码0.0.0.0<br>一般位于路由表的最后<br>作用：<strong>为剩余目的网络指定路由</strong>，可减小路由表，隐藏网络细节</p>
<p>表项的顺序：直接交付表项 &gt; 特定主机路由表项 &gt; 普通路由表项 &gt; 默认路由表项</p>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>路由器之间周期性地交互路由信息，根据最短路径优先原则，计算并更新各自的路由表。<br>最短路径优先原则特点：只考虑路径长度，不考虑拥塞和负载等，不保证所选路径是最优的。计算简单，可以简化路由协议的设计和实现。</p>
<h3 id="VD-vector-distance"><a href="#VD-vector-distance" class="headerlink" title="VD vector-distance"></a>VD vector-distance</h3><p><strong>路由表更新策略</strong></p>
<p>假设A收到B的路由表</p>
<p>对于目的网络N，A的下一跳是B，则按照B中的N更新</p>
<p>新项目直接加进来</p>
<p>下一跳不是B，并且距离更短</p>
<p>缺点：</p>
<p>收敛慢</p>
<h3 id="LS-link-status"><a href="#LS-link-status" class="headerlink" title="LS link status"></a>LS link status</h3><p>收敛速度较快：链路状态信息的发布是面向所有路由器，每个路由器都能够迅速获知变化。<br>信息交换量较小：<strong>只发布自己与相邻路由器的链路状态信息</strong>；此后只在网络变化时，发布变化部分。<br>扩展能力强：可采用分层的结构。</p>
<p>缺点：</p>
<p>路由器计算量大</p>
<h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p>路由环路：</p>
<p>由于V-D算法收敛慢，可能由于信息不一致导致路由环路。因此，RIP规定：有效路径的跳数不能超过15，跳数为16为无效路径。</p>
<p>相同距离路径问题<br>若去往某一信宿存在多条距离相同的路径，先入为主</p>
<h4 id="失效路径"><a href="#失效路径" class="headerlink" title="失效路径"></a>失效路径</h4><p>如果在6个周期(3分钟)内，没有收到与某一表项相关的V-D信息，就将该表项的度量值设置成16，并标注为删除。等过一段时间，该路径失效信息传播开去后，才真正删除该表项。</p>
<h4 id="计数到无穷"><a href="#计数到无穷" class="headerlink" title="计数到无穷"></a>计数到无穷</h4><p>慢收敛的极端情况</p>
<p>水平分割法：</p>
<p>如果路由器从某个接口收到某些网络的VD信息，不允许再从此接口发出这些网络的信息。</p>
<p>毒性逆转法：</p>
<p>从I接口收到VD信息，这个接口发送此网络的VD信息跳数设置为16（水平分割法的变形）</p>
<p>保持法：</p>
<p>在直连网络不可达的一段时间之内，禁止用收到的VD报文刷新此不可达信息</p>
<h2 id="RIP报文及封装"><a href="#RIP报文及封装" class="headerlink" title="RIP报文及封装"></a>RIP报文及封装</h2><p>帧首部 IP首部 UDP首部 RIP报文 帧尾部</p>
<p><a href="https://imgtu.com/i/TY8wRK"><img src="https://s4.ax1x.com/2021/12/24/TY8wRK.png" alt="TY8wRK.png"></a></p>
<p>v2改进：</p>
<p>支持子网，支持可变长子网掩码和无类别域间路由CIDR<br>提供报文鉴别机制，采用口令方式<br>采用组播来发送路由通告，组播地址224.0.0.9对应所有RIP v2路由器</p>
<h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><p>每个区域至少有一个区域边界路由器<strong>ABR</strong>用于汇总本区域的路径信息</p>
<p>OSPF采用链路-状态算法，每个路由器测试自己与其相邻路由器的链路状态信息，<strong>发现变化后在区域内以泛洪方式广播变化信息。</strong><br><strong>每个路由器(包括ABR)收到区域内路由器的信息后，可得知区域的网络结构</strong>，计算最新最短路径优先树，并进行相应路由表更新。而区域之间的路由信息则通过ABR进行交互。</p>
<p>采用<strong>层次结构</strong>，支持扩展，易于管理。<br><strong>支持特定</strong>主机、特定子网、分类网络、无类网络的路由。<br>不同的区域可以使用不同的报文鉴别方法。<br><strong>采用组播</strong>，减少不相关设备的负担。</p>
<h2 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h2><p>自治系统边界路由器(ASBR)通过内部网关协议(例如RIP或OSPF)收集自治系统内部的路由信息，然后与其他自治系统的ASBR通过BGP交换信息（信宿，下一跳和去往信宿的路径）。<br>相邻的ASBR收到后，计算并刷新自己的路由表。</p>
<p><strong>BGP的路由不是最短路径优先</strong>，而是基于管理员配置的路由策略，通常与政治、经济或安全等有关。<br><strong>BGP协议位于应用层</strong>，使用TCP作为传输层协议。两个ASBR路由器在交换路由信息前，必须先建立一条TCP连接。TCP协议将在下一章介绍。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>三元组标识一个进程：</p>
<p>主机地址，传输层协议，端口号</p>
<p>网络通信是使用相同传输层协议的两个进程的通信。</p>
<p>五元组标识一个网络通信:</p>
<p>传输层协议, 本地主机地址, 本地进程端口号, 远方主机地址, 远方进程端口号</p>
<p><strong>进程通信常采用客户机/服务器(C/S)方式</strong>：</p>
<p>熟知端口：</p>
<p>由服务器进程使用，有公认用途的端口，包含TCP和UDP的0-1023端口：<br>            SMTP服务器进程：TCP 25端口<br>            DHCP服务器进程：UDP 67端口<br>            FTP服务器的控制进程：TCP 21端口<br>            FTP服务器的数据进程：TCP 20端口 </p>
<p>临时端口：由客户进程使用，通信前向操作系统申请，通信后归还，包含TCP和UDP的1024~65535端口。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><strong>传输控制协议TCP</strong> (Transmission Control Protocol)：面向连接的传输层协议<br>特点：基于无连接、<strong>不可靠的IP</strong>，采取了一系列措施，例如建立和拆除逻辑连接，<strong>流量控制、拥塞控制、差错控制</strong>等，向应用层提供面向连接的、可靠的<strong>字节流传输</strong>服务。</p>
<h2 id="TCP段的格式"><a href="#TCP段的格式" class="headerlink" title="TCP段的格式"></a>TCP段的格式</h2><p>将应用层要传输的字节流分块，封装成若干个TCP段:<br>段首部：<strong>固定首部（20个字节） + 选项（0到40字节之间，且必须为4字节的整数倍）</strong><br>数据：<strong>2字节的整数倍</strong></p>
<p><a href="https://imgtu.com/i/TtdMOP"><img src="https://s4.ax1x.com/2021/12/24/TtdMOP.png" alt="TtdMOP.png"></a></p>
<p><strong>TCP总长度=IP中数据报总长度字段-首部长度*4</strong></p>
<p><strong>求校验和</strong>：首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。把TCP报头中的校验和字段置为0</p>
<p>其次，用反码相加法累加所有的16位字（进位也要累加）。<br>最后，对计算结果取反，作为TCP的校验和。</p>
<h2 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h2><p>TCP连接中传送的数据流中的每一个字节都编上一个序号。<br>序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。<br>如：流序号为=X，数据长度=L<br>则：报文的序号为X，下一个    报文序号为X+L<br>特点<br>报文的顺序关系<br>数据流的位置，更便于流的复原<br>较大的序号空间（32bits，4Gbyte）<br>报文的序号不连续</p>
<p><a href="https://imgtu.com/i/TtyEu9"><img src="https://s4.ax1x.com/2021/12/24/TtyEu9.png" alt="TtyEu9.png"></a></p>
<h2 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h2><p><a href="https://imgtu.com/i/TNuau9"><img src="https://s4.ax1x.com/2021/12/24/TNuau9.png" alt="TNuau9.png"></a></p>
<p>结束选项：作为整个TCP选项的结束。</p>
<p>最大段大小(MSS)选项：4字节。内容字段告诉对方，本机所在网络能够接受的最大TCP段数据区的字节数。如以太网的MSS可达1460字节，默认为536字节。</p>
<p>固定首部中的窗口字段最多只能表示65535个字节的空闲接收缓存大小。本选项用来扩大其表示，扩展后的空闲缓存大小为：<br>                                  Wn = Wo×2f<br>    Wo为窗口字段的值，f为窗口规模因子。</p>
<p>连接的建立需要请求和响应，但是基于不可靠IP，可能丢失。<br><strong>TCP：使用超时重传来解决IP不可靠问题。</strong><br>重传导致重复连接问题。<br><strong>TCP：根据TCP段的序号来查重。</strong><br>为了可靠建立连接，TCP设计了三次握手方式。</p>
<p><a href="https://imgtu.com/i/TNrlh8"><img src="https://s4.ax1x.com/2021/12/24/TNrlh8.png" alt="TNrlh8.png"></a></p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>SYN seq = x</p>
<p>ACK SYN seq = y ack = x+1</p>
<p>ACK seq = x+1 ack = y+1</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>-&gt;FIN ACK seq = u ack = v</p>
<p>&lt;-ACK seq = v ack = u+1</p>
<p>&lt;-FIN ACK seq = w ack = u+1</p>
<p>-&gt;ACK = 1 seq = u+1 ack = w+1</p>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>控制发送方发送数据的速率，使得接收方来得及接收和处理。</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>拥塞：网络中传输的数据过多，造成路由器缓存溢出导致数据丢失。数据丢失引起超时重传，进一步加剧网络拥塞。</p>
<p>TCP拥塞控制：也是控制发送方的发送速率，使得网络来得及传输。 </p>
<p>TCP流量控制：发送方的发送窗口（swnd）不能大于接收方的接收窗口（rwnd）</p>
<p>拥塞窗口(cwnd)：表示当前网络的转发能力，由发送方根据网络状况动态设置。</p>
<p><a href="https://imgtu.com/i/RmWi8S"><img src="https://z3.ax1x.com/2021/06/23/RmWi8S.png" alt="RmWi8S.png"></a></p>
<h2 id="TCP差错控制"><a href="#TCP差错控制" class="headerlink" title="TCP差错控制"></a>TCP差错控制</h2><p><strong>段丢失</strong>。检测：发送方使用重传计时器。处理：超时重传。确认段的丢失不需处理，因为TCP采用累计确认。<br><strong>段损坏</strong>。检测：接收方使用校验和字段。处理：丢弃出错的段，不返回确认段，由发送方超时重传。<br><strong>段重复</strong>。一般由超时重传造成的。检测：接收方分析段序号。处理：直接丢弃重复段。<br><strong>段失序。</strong>由于TCP基于IP，不能保证按序到达。处理：接收方对先到达的段暂不确认，放入接收缓存，直到前面的段都到齐了再一起向上提交并返回确认。</p>
<p>重传计时器<br>发送方发送每个段时，启用重传计时器，如在超时时间内未收到对方确认，则重传。<br>超时值：最常用的：<br>$$<br>Timeout = 2\cross RTT<br>$$</p>
<p>$$<br>RTT=\alpha \cross RTT_0+(1-\alpha)\cross RTT_1<br>$$</p>
<p>其中RTT0为之前计算的RTT值，RTT1为最新计算的RTT值，系数α通常为0.9。<br>RTT0和RTT1的计算：</p>
<ol>
<li>通过TCP段的时间戳选项；</li>
<li>通过计时器。</li>
</ol>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><a href="https://imgtu.com/i/TNfsg0"><img src="https://s4.ax1x.com/2021/12/24/TNfsg0.png" alt="TNfsg0.png"></a></p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>Domain Name System</p>
<p>DNS既可以基于TCP，也可以基于UDP，服务器则使用熟知端口53<br>对UDP或TCP的使用原则：</p>
<p><strong>使用A查询请求某个域名对应的IP地址时使用UDP。</strong></p>
<p><strong>如果响应报文长度大于512字节，则UDP仅返回前512字节，并设置报文首部“参数”字段的“截断”位。客户收到这个响应后，使用TCP重新发送原来的请求。</strong></p>
<p><strong>如果一次查询的名字很多，则客户可能会直接使用TCP。</strong></p>
<p>在主域名服务器和辅助域名服务器间进行区域传送时，使用TCP。<br>核心：<strong>数据传输量少，可靠性要求低的时候用UDP；否则用TCP。</strong></p>
<h1 id="引导协议与动态主机配置"><a href="#引导协议与动态主机配置" class="headerlink" title="引导协议与动态主机配置"></a>引导协议与动态主机配置</h1><p>计算机上网通常需要：<br><strong>IP地址</strong><br><strong>所在网络的掩码</strong><br><strong>默认路由器的IP地址</strong><br><strong>默认DNS服务器的IP地址</strong></p>
<h2 id="BOOTP："><a href="#BOOTP：" class="headerlink" title="BOOTP："></a>BOOTP：</h2><p>BOOTstrap Protocol</p>
<p><strong>位于应用层，基于UDP协议</strong><br>作用：使计算机获得上述四种网络参数。<br>RARP使用链路层广播也能获取IP地址，但不能跨路由器。因此，RARP很少用了。</p>
<p>服务器进程使用UDP 67端口侦听。<br>客户机进程使用UDP 68端口在网络层中<strong>广播BOOTP请求</strong>(目的地址255.255.255.255，目的端口UDP 67；如果不知道自己的IP地址，<strong>则源地址0.0.0.0</strong>，源端口UDP 68)，数据中包含客户机的MAC地址。</p>
<p><a href="https://imgtu.com/i/Tw3dUg"><img src="https://s4.ax1x.com/2021/12/26/Tw3dUg.png" alt="Tw3dUg.png"></a></p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>动态主机配置协议</p>
<p>客户机启动时，<strong>广播DHCPDISCOVER报文</strong>。<br>服务器响应<strong>DHCPOFFER报文(单播)<strong>，提供了可用于客户机的IP地址等信息。<br>客户机一般选择最先到达的响应，并向相应服务器发送</strong>DHCPREQUEST报文(广播)。</strong><br>相应服务器收到后，<strong>返回DHCPACK报文</strong>。客户机收到后，开始租用此服务器提供的IP地址(单播) 。</p>
<p>反正客户机始终都是单播</p>
<p>1）如果收到DHCPDISCOVER报文，则从地址池中选择一个空闲IP，并提供租用时间，构造DHCPOFFER响应报文；同时把此IP地址锁定，并记录于地址分配表。<br> 2）如果收到DHCPREQUEST，根据客户机的硬件地址，查找地址分配表，若找到，则响应DHCPACK报文；否则响应DHCPNAK报文。<br> 3）如果收到DHCPDECLINE报文，会禁用报文中的IP地址，不再给客户机分配这个IP地址。<br>4）如果收到DHCPRELEASE报文，则解除地址绑定，此IP地址可被重新分配。</p>
<p>兼容BOOTP，BOOTP客户机可向DHCP服务器请求静态IP配置。报文格式基本相同；服务器进程UDP 67端口，客户进程UDP 68端口；<br>为特定客户机分配固定的静态IP地址；<br>为普通客户机分配临时的动态IP地址；<br>客户机可对多个服务器提供的服务作出选择和响应；<br><strong>可以跨网通信（通过路由器的中继代理程序），不需要在每个网络上都设置服务器。</strong></p>
<h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><p>位置：应用层，基于传输层的TCP。<br>作用：实现不同计算机之间可靠的文件传输。不同操作系统、不同字符集、不同文件结构和存储方式等。</p>
<p>FTP建立两条TCP连接：<br>一条传送控制信息(命令和响应) ；<br>另一条传送文件数据。<br>双方4个进程：<br>服务器控制进程：TCP 21端口<br>服务器数据进程：TCP 20端口</p>
<h1 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h1><p>(1)<strong>建立连接</strong><br>客户进程周期性扫描邮件缓存。如发现有邮件要发送，就主动发起并建立与服务器进程的TCP连接。<br>TCP连接建立完毕，服务器返回“220 Service ready”<br>客户机向服务器发送HELO命令，附上自己的域名，用来表明自己是谁。<br>服务器有能力接收邮件，则返回“250 OK”，否则返回“421 Service not available”。</p>
<p>(2)<strong>邮件传送</strong><br>客户机发出MAIL FROM命令，后跟发信人地址。如：MAIL FROM  <a href="mailto:&#x31;&#x32;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#x32;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a><br>若服务器已准备好接收，则返回“250 OK”；<br>否则，返回具体错误代码。如：451(处理时出错)，452(存储空间不够)，500(命令无法识别)等。<br>收到“250 OK”后，客户机发出RCPT TO命令，后跟收信人地址<br>例如： RCPT TO <a href="mailto:&#52;&#53;&#x36;&#64;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x6e;&#x6a;&#x75;&#115;&#116;&#46;&#x65;&#100;&#117;&#46;&#99;&#110;">&#52;&#53;&#x36;&#64;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x6e;&#x6a;&#x75;&#115;&#116;&#46;&#x65;&#100;&#117;&#46;&#99;&#110;</a></p>
<p>(3)<strong>拆除连接</strong><br>客户机发送QUIT命令，表示邮件发送完毕。<br>服务器返回“250 OK”。然后双方拆除TCP连接</p>
<p>MIME就是可以传图片和附件</p>
<hr>
<p>IMAP4与POP3比较<br>1）相同之处<br>作用相同，基于TCP<br>客户机要通过身份验证<br> 2）不同之处<br>POP3中邮件由客户端管理，IMAP由服务器管理<br>IMAP中可只下载部分附件，在低速链路上非常有用</p>
<h1 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h1><p>位置：工作在应用层，基于传输层的TCP，服务器进程使用TCP 23端口。<br>作用：提供远程登录功能，客户机将命令传送到服务器上执行，服务器返回执行结果。</p>
<p>NVT的作用：建立数据表示的一致性。<br>Telnet客户端：用户的击键信息发送给终端驱动程序，这些本地字符被送到Telnet客户进程转换成NVT ASCII字符，再发送出去。<br>Telnet服务器：服务器收到NVT ASCII字符后，将其转换成本计算机的相应字符，再交给伪终端驱动程序，然后传递给适当的应用程序进行处理。</p>
<p>选项协商命令（3字节）：</p>
<p>IAC 命令码 选项码</p>
<p>IAC (255)<br>命令码：4个控制字符。WILL (251)、WONT (252) 、 DO (253) 、 DONT (254)</p>
<h1 id="三角路由问题"><a href="#三角路由问题" class="headerlink" title="三角路由问题"></a>三角路由问题</h1><p>三角形路径问题会引入流量的时延，容易引起归属代理处的路由瓶颈。例如，即使在校园网这样的网络规模中，移动IP的三角路由也会使报文的平均时延增加45%。</p>
<p>解决办法：将移动主机的<strong>转交地址与其归属地址进行绑定</strong>，当归属代理收到发给移动主机的第一个包时，将包转发给外区代理，同时发一个更新绑定包给远地主机，以便远地主机以后向这台移动主机发送信息时直接使用转交地址。<strong>远地主机将绑定信息存放在高速缓冲中</strong>。</p>
<p>出现新问题：移动主机的再次移动会造成远地主机高速缓冲中内容的过时。所以当移动主机再次移动时，<strong>归属代理必须向远程主机发送报警包，通告变化。</strong> </p>
<h1 id="各种封装"><a href="#各种封装" class="headerlink" title="各种封装"></a>各种封装</h1><p>ICMP：帧头 IP首部 ICMP首部 ICMP数据 CRC</p>
<p>ARP：目的地址(6) 源地址(6) 帧类型(2) ARP/RARP(28) PAD(18) CRC(4)</p>
<p>由于ARP和RARP报文较短（28个字节），后面必须增加18个字节的填充PAD，以达到以太网最小帧长度的要求。64B-1518B</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>数论学习</title>
    <url>/2021/04/27/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="常用数论"><a href="#常用数论" class="headerlink" title="常用数论"></a>常用数论</h1><span id="more"></span>

<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$$<br>\displaystyle \sum_{i=1}^n[gcd(i,n)=1]<br>$$<br>性质：</p>
<p>不大于n且与n互质的整数和:<br>$$<br>\frac{n*\varphi(n)}{2}<br>$$</p>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>$$<br>gcd(M,N)=1\Rightarrow\boldsymbol\varphi(NM)=\boldsymbol \varphi(N)\cdot\boldsymbol\varphi(M)<br>$$</p>
<p>求法：<br>$$<br>\displaystyle \boldsymbol\varphi(n)=n\prod_{i=1}^m{p_i-1\over p_i}<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">euler</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll res = n, a = n;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><p>$$<br>\boldsymbol\varphi(p\times n)=\boldsymbol\varphi(n)\times<br>\begin{cases}<br>p,p\mid n<br>\\ \<br>p-1,p\nmid n<br>\end{cases}<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri.push_back(i), phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            phi[i * pri[j]] = phi[i] * phi[pri[j]];</span><br><span class="line">            <span class="keyword">if</span> ((i % pri[j]) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果lcm是大数，求每个数分解质因数的最大数，然后用大数乘法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll ans[<span class="number">10005</span>];</span><br><span class="line">ll pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1e4</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt;= pos)</span><br><span class="line">        ans[cur--] *= x;</span><br><span class="line">    cur = <span class="number">1e4</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt;= pos)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[cur - <span class="number">1</span>] += ans[cur] / <span class="number">10</span>;</span><br><span class="line">        ans[cur--] %= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans[pos - <span class="number">1</span>])</span><br><span class="line">            pos--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;ll, ll&gt; mp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pri.<span class="built_in">size</span>() &amp;&amp; pri[i]*pri[i]&lt;=k; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k % pri[i] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k /= pri[i];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt)</span><br><span class="line">        mp[pri[i]] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">    mp[k]++;</span><br></pre></td></tr></table></figure>



<p>欧拉筛</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;ll&gt; pri; <span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : pri)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ll)i * x &gt; N)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            vis[i * x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % x == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>A转化成B进制，有多少位<br>$$<br>log(A)/log(B)+1<br>$$</p>
<p>约数的x次方求和</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/226f33de9452ff7dae0bec1088e6cc74ae62f2ed" alt="{\displaystyle \sigma _{x}(n)=\sum _{d\mid n}d^{x}\,\!,}"></p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7b304c810f7c9f6f974d7815e4ca985c1e5d4833" alt="{\displaystyle \sigma _{x}(n)=\prod _{i=1}^{r}{\frac {p_{i}^{(a_{i}+1)x}-1}{p_{i}^{x}-1}}.}"></p>
<h2 id="区间素数"><a href="#区间素数" class="headerlink" title="区间素数"></a>区间素数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(p , p + N, <span class="number">1</span>);</span><br><span class="line">ll a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; pri[i] * pri[i] &lt;= b; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll j =<span class="built_in">max</span>(<span class="number">2ll</span>, (a + pri[i] - <span class="number">1</span>) / pri[i]) * pri[i]; j &lt;= b; j += pri[i])</span><br><span class="line">        p[j - a] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">0</span>, b - a)</span><br><span class="line">    ans += p[i];</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">    ans--;</span><br></pre></td></tr></table></figure>



<p>已知a和lcm(a,b)，求b</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll ans = lcm / a;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ll g = <span class="built_in">gcd</span>(ans, a);</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ans *= g;</span><br><span class="line">    a /= g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调和级数：$\sum_{i=1}^n\frac{1}{i}(n大于10^4的时候用) $<br>$$<br>f(n)≈ln(n)+C+\frac{1}{2n}  (C=0.57721566490153286060651209)<br>$$</p>
<p>更进一步求：$\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor (n\leq10^9)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ans += (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>被除数 $n$ 的商个数是 $O(\sqrt{n})$ 级别的</p>
<p>因此当题目需要考虑的是$\forall i\in Z_+,\lfloor{n\over i}\rfloor$时，可枚举$(2\sqrt n+1)$来实现</p>
<p>假设，对于$\forall i\in[l,r]\bigcap Z$，有$\lfloor{n\over l-1}\rfloor\neq \lfloor{n\over l}\rfloor=\lfloor{n\over i}\rfloor=\lfloor{n\over r}\rfloor\neq \lfloor{n\over r+1}\rfloor$<br>$$<br>\therefore \displaystyle \sum_{i=l}^r\lfloor{n\over i}\rfloor=\sum_{i=1}^r\lfloor{n\over l}\rfloor=\lfloor{n\over l}\rfloor(r-l+1)<br>$$<br>那么，若我们能已知所有的$l,r$，就能递推出下一个区间$l,r$</p>
<p>对于区间$[l,r]$由于$\forall i\in[l,r]\bigcap Z$，有$\lfloor{n\over l-1}\rfloor\neq \lfloor{n\over l}\rfloor=\lfloor{n\over i}\rfloor=\lfloor{n\over r}\rfloor\neq \lfloor{n\over r+1}\rfloor$</p>
<p>$r=max(i)\implies{n\over r}=min({n\over i})\geq \lfloor{n\over l}\rfloor$</p>
<p>$r\in Z_+ \implies r\leq {n\over \lfloor{n\over l}\rfloor}$</p>
<p>$\therefore r=n/(n/l)$</p>
<p>同理</p>
<p>$l=n/(n/r+1)+1$</p>
<p>从左往右整除分块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=k;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> d=n/l;</span><br><span class="line">    r=min(n/d,k);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从右往左整除分块：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=k,l;r&gt;=<span class="number">1</span>;r=l<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> d=n/r;</span><br><span class="line">    l=n/(d+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，考虑给定下界、同时给定上下界的整除分块</p>
<p>我们发现，实际上，给定上界的整除分块用从右往左更方便；其余情况（给定下界、给定上下界、范围为 1~n ）的用从左往右更方便（因为代码更好记）</p>
<hr>
<p>小于n，有多少对$lcm(a,b)=n （a&lt;b）$<br>$$<br>\frac{\prod_{i=1}^n (2p_i+1)+1}{2}(p_i代表第i个质因数的个数)<br>$$<br>LOJ1236 <a href="https://www.cnblogs.com/WTSRUVF/p/9185140.html">https://www.cnblogs.com/WTSRUVF/p/9185140.html</a></p>
<hr>
<p>连续的数加起来等于sum，问这样连续的数组有多少个：</p>
<p>$sum=a+(a+1){\cdots}+(a+k-1) \implies sum = \frac{k(2a+k-1)}{2}$</p>
<p>$\implies \frac {sum}{k}-\frac{k-1}{2}=a$</p>
<p>$k-1$为偶数，$k$为奇数</p>
<p>$\therefore$ 只需要求sum的奇数因数个数</p>
<hr>
<p>输出$n^k$的前三位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = k * <span class="built_in">log10</span>(n);</span><br><span class="line">d -= (<span class="keyword">int</span>)d;</span><br><span class="line"><span class="keyword">double</span> pre = <span class="built_in">pow</span>(<span class="number">10.0</span>, d);</span><br><span class="line">ans1 = pre * <span class="number">100</span>;</span><br></pre></td></tr></table></figure>



<hr>
<p>节约空间的素数筛</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span> <span class="params">()</span>   <span class="comment">//筛素数,数组从0开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	prime[<span class="number">0</span>]=data[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">	np=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   <span class="comment">//扫所有奇数</span></span><br><span class="line">		<span class="keyword">if</span> (!(visit[i/<span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; ((i/<span class="number">2</span>)%<span class="number">16</span>))))</span><br><span class="line">		&#123;</span><br><span class="line">			prime[np]=i;</span><br><span class="line">			data[np]=data[np<span class="number">-1</span>]*i;  <span class="comment">//预处理</span></span><br><span class="line">			np++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">3</span>*i;j&lt;N;j+=<span class="number">2</span>*i)  <span class="comment">//改成i*i会超int范围</span></span><br><span class="line">				visit[j/<span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; ((j/<span class="number">2</span>)%<span class="number">16</span>));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>$lcm$的一个性质<br>$$<br>lcm(p,n+1) =<br>        \begin{cases}<br>        lcm(n)\cdot p,  &amp; \text{if n+1 is a perfect power of prime p} \<br>        lcm(n), &amp; \text{otherwise}<br>        \end{cases}<br>$$</p>
<p>对$n!$分解因式：对n不断除素数p，直到n为0时，此时商的和即该素因子的指数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c &amp;&amp; pri[i] &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    LL t = n;</span><br><span class="line">    LL ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        ct += t / pri[i];</span><br><span class="line">        t /= pri[i];</span><br><span class="line">    &#125;</span><br><span class="line">    mp[pri[i]] = ct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="积性函数-1"><a href="#积性函数-1" class="headerlink" title="积性函数"></a>积性函数</h1><h2 id="迪利克雷卷积"><a href="#迪利克雷卷积" class="headerlink" title="迪利克雷卷积"></a>迪利克雷卷积</h2><p><img src="https://www.zhihu.com/equation?tex=(f*g)(n):=%5Csum_%7Bxy=n%7Df(x)g(y)" alt="[公式]"></p>
<p>也常常等价地写作：</p>
<p><img src="https://www.zhihu.com/equation?tex=(f*g)(n):=%5Csum_%7Bd%7Cn%7D%7Bf(d)g%5Cleft(%5Cfrac+nd%5Cright)%7D" alt="[公式]"></p>
<center><a href="https://imgtu.com/i/g4aczq"><img src="https://z3.ax1x.com/2021/05/19/g4aczq.png" alt="g4aczq.png" border="0" /></a></center>

<p>莫比乌斯反演：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：<br>$$<br>F(n)=\sum_{d|n}f(d)<br>$$<br>那么存在一个结论：<br>$$<br>f(n)=\sum_{d|n}\mu(d)F(\lfloor\frac{n}{d}\rfloor)<br>$$</p>
<h2 id="mu数组筛法"><a href="#mu数组筛法" class="headerlink" title="mu数组筛法"></a>mu数组筛法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; pri;</span><br><span class="line">ll mu[N], sum[N], cnt, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            pri.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j]&lt;N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mu[i * pri[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>常见的积性函数：$\varphi,\mu,\sigma,d$</li>
<li>常见的完全积性函数：$\epsilon,I,id$</li>
</ul>
<p>$ \epsilon(n) = [n=1], I(n) = 1, id(n) = n$</p>
<h2 id="迪利克雷卷积性质"><a href="#迪利克雷卷积性质" class="headerlink" title="迪利克雷卷积性质"></a>迪利克雷卷积性质</h2><p>$\mu*I=\epsilon$</p>
<p>$\varphi*I=id$</p>
<p>$\mu*id=\varphi$</p>
<h2 id="莫比乌斯反演证明"><a href="#莫比乌斯反演证明" class="headerlink" title="莫比乌斯反演证明"></a>莫比乌斯反演证明</h2><p>$g=f*I$</p>
<p>$\therefore g<em>\mu=f</em>I<em>\mu=f</em>\epsilon=f$</p>
<p>$g*\mu=f$</p>
<p>杜教筛：</p>
<p>求：$\sum_{i=1}^{n}f(i)=S(n)$</p>
<p>构造：<br>$$<br>\sum_{i=1}^{n}(f*g)(i)<br>=\sum_{i=1}^{n}\sum_{d|i}f(d)g(\frac i d)<br>$$</p>
<p>$$<br>=\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor \frac n d \rfloor}f(i)<br>$$</p>
<p>$$<br>=\sum_{d=1}^{n}g(d)S(\lfloor \frac n d \rfloor)<br>$$</p>
<p>考虑$g(1)S(n)$<br>$$<br>g(1)S(n)=\sum_{i=1}^{n}g(i)S(\lfloor \frac n d \rfloor)-\sum_{i=2}^{n}g(i)S(\lfloor \frac n d \rfloor)<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 算 f 前缀和的函数</span></span><br><span class="line">  ll ans = <span class="built_in">f_g_sum</span>(n); <span class="comment">// 算 f * g 的前缀和</span></span><br><span class="line">  <span class="comment">// 以下这个 for 循环是数论分块</span></span><br><span class="line">  <span class="keyword">for</span>(ll l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123; <span class="comment">// 注意从 2 开始</span></span><br><span class="line">    r = (n / (n / l)); </span><br><span class="line">    ans -= (<span class="built_in">g_sum</span>(r) - <span class="built_in">g_sum</span>(l - <span class="number">1</span>)) * <span class="built_in">GetSum</span>(n / l);</span><br><span class="line">    <span class="comment">// g_sum 是 g 的前缀和</span></span><br><span class="line">    <span class="comment">// 递归 GetSum 求解</span></span><br><span class="line">  &#125; <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Min25筛"><a href="#Min25筛" class="headerlink" title="Min25筛"></a>Min25筛</h2><p>求$\sum_{i=1}^n f(i),f(i)$是积性函数。</p>
<p>Min25筛能用的前提：质数处的$f(p)$值是关于$p$的多项式,质数次方处$f(p^e)$可以快速计算。</p>
<p>例：求$\sum_{i=1}^n f(i),f(i)$是积性函数，且$f(p^k)=p^k(p^k-1)$</p>
<p>先分类：<br>$$<br>\sum_{i=1}^{n}f(i)=\sum_{1 \leq p\leq n}f(p)+\sum_{i=1 &amp;\ i\  is\ not\ a\ prime}^{n}f(i)<br>$$</p>
<p>$$<br>=\sum_{1 \leq p\leq n}f(p)+<br>\sum_{1 \leq p^e\leq n,1 \leq p\leq \sqrt n}f(p^e)<br>\left(\sum_{1 \leq i\leq\frac {n} {p^e} \ &amp; \ LPF(i)&gt;p}f(i)\right)<br>$$</p>
<p>整个式子就变成了两个部分，第一部分是所有质数的<em><strong>f</strong></em>之和，另一部分是枚举最小质因子后，求所有最小质因子大于这个质因子的<em><strong>f</strong></em>之和。</p>
<p>构造DP数组，表示求1到<em>n</em>之间所有满足条件的数的<em>k</em>次方和，条件就是要么是质数要么最小质因子大于$p_j$：<br>$$<br>g(n,j)=\sum_{i=1}^{n}[LPF(i)&gt;p_j]i^k<br>$$<br>$g$的递推式：<br>$$<br>g(n,j)=g(n,j-1)-p^k_j\left(<br>g\left(\frac n p_j ,j-1 \right)-g(p_{j-1},j-1)<br>\right)<br>$$<br>1到$n$中所有质数的$k$次方和其实就是$g(n,x)$，其中$p_x$是最后一个小于等于$\sqrt n$的质数。为了方便，我们把它记作$ g(n)$</p>
<p>由于$n$很大，无法对每一个$n$求出$g(n,x)$，所以需要分块</p>
<p>设$S(n,x)$表示$1$到$n$中，所有最小质因子大于$p_x$的$f$值之和，答案就是$S(n,0)$<br>$$<br>S(n,j)=g(n,|P|)-\sum_{i=1}^{j-1}f(P_i)+\sum_{k\ge j}\sum_{e}(F(P_k^e)S(\frac{n}{P_k^e},k+1)+F(P_k^{e+1}))<br>$$</p>
<hr>
<h1 id="一些板子"><a href="#一些板子" class="headerlink" title="一些板子"></a>一些板子</h1><p>阶：</p>
<p>若$(a,m)=1$ ，使$a^l\equiv1(mod\ m)$成立的最小的$l$ ，称为 关于模$m$的阶，记为$ord_ma$ 。</p>
<p>原根：</p>
<p>$(g,m)=1$，若$ord_mg=\varphi(m)$ ，则称$g$为$m$的一个原根。</p>
<p>求最小原根模板（m为素数）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zc=n,all=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=all;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">    	zc=zc/i*(i<span class="number">-1</span>);</span><br><span class="line">    	<span class="keyword">while</span>(n%i==<span class="number">0</span>)n/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)zc=zc/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> zc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> PHI=phi(m);</span><br><span class="line">	q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> limit=<span class="built_in">sqrt</span>(PHI);<span class="keyword">int</span> zc=PHI;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=limit;i++)</span><br><span class="line">		<span class="keyword">if</span>(zc%i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			q[++q[<span class="number">0</span>]]=PHI/i;</span><br><span class="line">			<span class="keyword">while</span>(zc%i==<span class="number">0</span>)zc/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(zc&gt;<span class="number">1</span>)zc=q[++q[<span class="number">0</span>]]=PHI/zc;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> g=<span class="number">2</span>;;g++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> fla=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">pow</span>(g,PHI,m)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q[<span class="number">0</span>];i++)</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">pow</span>(g,q[i],m)==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				fla=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(fla)<span class="keyword">return</span> g;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><p>求解$a^x=b(mod\ p)\ p$是素数。</p>
<p>考虑费马小定理：<br>$$<br>a^{p-1}\equiv 1(mod\ p)<br>$$<br>而:<br>$$<br>a^0\equiv1(mod \ p)<br>$$<br>由于出现循环，可见，$x\in[0,p-2]$中已经包含所有结果，所以只需要枚举0到p-2</p>
<p>令$x=A\lceil \sqrt p \rceil -B$ ，其中$0 \leq A,B \leq \lceil \sqrt p \rceil $ ，则有 ，稍加变换，则有 $a^{A\lceil \sqrt p \rceil } \equiv ba^B mod (p)$ 。</p>
<p>我们已知的是$a,b$ ，所以我们可以先算出等式右边的$ba^B$ 的所有取值，枚举$B$ ，用 <code>hash</code>/<code>map</code> 存下来，然后逐一计算$a^{A\lceil \sqrt p \rceil }$ ，枚举$A$ ，寻找是否有与之相等的$ba^B$ ，从而我们可以得到所有的$x$ ，$x=A\lceil \sqrt p \rceil -B$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ll p, b, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p &gt;&gt; b &gt;&gt; n;</span><br><span class="line"><span class="comment">//b^l=n mod p</span></span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; mp;</span><br><span class="line">ll t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i&lt;= t; i++)</span><br><span class="line">&#123;</span><br><span class="line">    mp[<span class="function">n * <span class="title">qpow</span><span class="params">(b, i, p)</span>%p]</span>=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fg = <span class="number">0</span>;</span><br><span class="line">ll ans = INF;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i&lt;= t; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ll m = qpow(b, i * t, p);</span><br><span class="line">    <span class="keyword">if</span> (mp.count(m) &amp;&amp; i * t - mp[m]&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fg = <span class="number">1</span>;</span><br><span class="line">        ans = min(ans, i * t - mp[m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!fg)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>求$x^a\equiv b \ mod(p)$：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a ? gcd(b % a, a) : b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">powmod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">    a = a * a % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Finds the primitive root modulo p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">generator</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fact;</span><br><span class="line">  <span class="keyword">int</span> phi = p - <span class="number">1</span>, n = phi;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">      fact.push_back(i);</span><br><span class="line">      <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>) fact.push_back(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> res = <span class="number">2</span>; res &lt;= p; ++res) &#123;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> factor : fact) &#123;</span><br><span class="line">      <span class="keyword">if</span> (powmod(res, phi / factor, p) == <span class="number">1</span>) &#123;</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This program finds all numbers x such that x^k=a (mod n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, k, a;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;k, &amp;a);</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1\n0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> g = generator(n);</span><br><span class="line">  <span class="comment">// Baby-step giant-step discrete logarithm algorithm</span></span><br><span class="line">  <span class="keyword">int</span> sq = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">.0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dec(sq);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">    dec[i - <span class="number">1</span>] = &#123;powmod(g, i * sq * k % (n - <span class="number">1</span>), n), i&#125;;</span><br><span class="line">  sort(dec.begin(), dec.end());</span><br><span class="line">  <span class="keyword">int</span> any_ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sq; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> my = powmod(g, i * k % (n - <span class="number">1</span>), n) * a % n;</span><br><span class="line">    <span class="keyword">auto</span> it = lower_bound(dec.begin(), dec.end(), <span class="built_in">make_pair</span>(my, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != dec.end() &amp;&amp; it-&gt;first == my) &#123;</span><br><span class="line">      any_ans = it-&gt;second * sq - i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (any_ans == <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Print all possible answers</span></span><br><span class="line">  <span class="keyword">int</span> delta = (n - <span class="number">1</span>) / gcd(k, n - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> cur = any_ans % delta; cur &lt; n - <span class="number">1</span>; cur += delta)</span><br><span class="line">    ans.push_back(powmod(g, cur, n));</span><br><span class="line">  sort(ans.begin(), ans.end());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans.size());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> answer : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h2><p>求解大组合数取模的问题，p一定为素数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ll n, m, p;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((a[n] * qpow(a[m], p - <span class="number">2</span>, p)) % p * qpow(a[n - m], p - <span class="number">2</span>, p) % p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, p)</span><br><span class="line">        a[i] = (a[i - <span class="number">1</span>] * i) % p;<span class="comment">//init</span></span><br><span class="line">    <span class="keyword">if</span> (!m)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n % p, m % p) * Lucas(n / p, m / p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>CRT：求解如下形式的一元线性同余方程组（其中$n_1,n_2,…,n_k$ 两两互质）：</p>
<ol>
<li>计算所有模数$n_i$的积$M$ ；</li>
<li>对于第$i$个方程：<ol>
<li>计算$m_i= \frac M {n_i}$；</li>
<li>计算$m_i$在模$n_i$意义下的逆元$m_i^{-1}$；</li>
<li>计算$c_i=m_im_i^{-1}$<strong>（不要对$n_i$取模）</strong>。</li>
</ol>
</li>
<li>方程组的唯一解为：$a=\sum_{i=1}^{k}a_ic_i\ mod\ M$。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; x, ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;x = <span class="number">1</span>, y = <span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line">ll m[N], Mi[N] , r[N];</span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ll n, M = <span class="number">1</span> , ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//x = r[i] mod m[i]</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m[i] &gt;&gt; r[i];</span><br><span class="line">        M *= m[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        Mi[i] = M / m[i];</span><br><span class="line">        ll x, y;</span><br><span class="line">        exgcd(Mi[i], m[i], x, y);</span><br><span class="line">        ans += r[i] * Mi[i] * ((x + m[i]) % m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans % M &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EXCRT"><a href="#EXCRT" class="headerlink" title="EXCRT"></a>EXCRT</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y, k;</span><br><span class="line">    ll M = bi[<span class="number">1</span>], ans = ai[<span class="number">1</span>];<span class="comment">//第一个方程的解特判</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a = M, b = bi[i], c = (ai[i] - ans % b + b) % b;<span class="comment">//ax≡c(mod b)</span></span><br><span class="line">        ll g = <span class="built_in">gcd</span>(a,b), bg = b / g;</span><br><span class="line">        <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">        <span class="keyword">if</span> (c % g != <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断是否无解，然而这题其实不用</span></span><br><span class="line"></span><br><span class="line">        x = (x*(c/g))%bg;</span><br><span class="line">        ans += x * M;<span class="comment">//更新前k个方程组的答案</span></span><br><span class="line">        M *= bg;<span class="comment">//M为前k个m的lcm</span></span><br><span class="line">        ans = (ans % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p><em>a</em> 与 <em>m</em> 互质时，$a^{\varphi(m)}\equiv 1\ mod \ m$</p>
<p>扩展欧拉定理：（注意$b$要大于$\varphi(m)$才加$\varphi(m)$）<br>$$<br>b\geq\varphi(m),a^b\equiv a^{(b\ mod\ \varphi(m))+\varphi(m)}\ mod\ m<br>$$</p>
<hr>
<h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>求约数个数：</p>
<p>d(i) 表示 i 的约数个数,num[i] 表示 i 的最小素因子的个数</p>
<p>1.$i%p != 0$ ，则$p_j$是$i<em>p_j$的最小质因数，且$p_j$这个质因数第一次出现在$i</em>p_j$内，次数为1，则$num[i<em>p_j]=1,d[i</em>p_j]=d[i]*2$</p>
<p>2.$i%p=0$，则$p_j$在$i<em>p_j$中的次数加一，对于约数个数，先除以原来的$num[i]+1$ ，再乘上新的$num[i] + 2$，则$num[i</em>p_j]=num[i]+1,d[i<em>p_j]=d[i]/(num[i]+1)</em>(num[i]+2)=d[i]/num[i<em>p_j]</em>(num[i*p_j]+1)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// d(i) 表示 i 的约数个数,num[i] 表示 i 的最小素因子的个数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i, d[i] = <span class="number">2</span>, num[i] = <span class="number">1</span>;  <span class="comment">//i是质数，d[i] = 2, num[i] = 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; ++j) &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;  <span class="comment">// i % pj == 0, num[i * pj] = num[i] + 1, d[i *pj] = d[i] / num[i * pj] * (num[i * pj] + 1)</span></span><br><span class="line">                num[i * prime[j]] = num[i] + <span class="number">1</span>;</span><br><span class="line">                d[i * prime[j]] = d[i] / num[i * prime[j]] * (num[i * prime[j]] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i % pj ！= 0， num[i * pj] = 1, d[i * pj] = d[i] * 2</span></span><br><span class="line">            num[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            d[i * prime[j]] = d[i] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="求约数和"><a href="#求约数和" class="headerlink" title="求约数和"></a>求约数和</h2><p>f[i]表示i的约数和，g[i]表示i的最小质因数的$p^0+p^1+…+p^k$</p>
<p>1.$i%p != 0$ ，则$p_j$是$i<em>p_j$的最小质因数，且$p_j$这个质因数第一次出现在$i</em>p_j$内，次数为1，则$f[i*p_j]=f[i]<em>f[p_j],g[i</em>p_j]=1+p_j$</p>
<p>2.$i%p=0$，则$p_j$在$i<em>p_j$中的次数加一，则$g[i</em>p_j]=g[i]<em>p_j+1,f[i</em>p_j]=f[i]/g[i]<em>g[i</em>p_j]$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f[i] 表示i的约数和，g[i]表示i的最小质因数的p^0 + p^1 + ... + p^k</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    g[<span class="number">1</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[cnt++] = i, g[i] = <span class="number">1</span> + i, f[i] = i + <span class="number">1</span>;  <span class="comment">// i是质数，g[i] = 1 + i, f[i] = i + 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; ++j) &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;  <span class="comment">// i % pj == 0, g[i * pj] = g[i] * pj + 1, f[i * pj] = f[i] / g[i] * g[i * pj]</span></span><br><span class="line">                g[i * prime[j]] = g[i] * prime[j] + <span class="number">1</span>;</span><br><span class="line">                f[i * prime[j]] = f[i] / g[i] * g[i * prime[j]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i % pj != 0, f[i * pj] = f[i] * f[pj], g[i * pj] = 1 + pj</span></span><br><span class="line">            f[i * prime[j]] = f[i] * f[prime[j]];</span><br><span class="line">            g[i * prime[j]] = <span class="number">1</span> + prime[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>$$<br>nx+i=my+j<br>$$</p>
<p>求最小的x：</p>
<p>x0 = x + m / gcd( n , m ) * t</p>
<p>y0 = y + n / gcd( n , m ) * t</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=x*(a/b);</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xn+cc 和 ym+dd的最小的共同值</span></span><br><span class="line"><span class="function">ll <span class="title">Get_common</span><span class="params">(ll n, ll m, ll cc, ll dd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b, c, x, y;</span><br><span class="line">    a = n;</span><br><span class="line">    b = -m;</span><br><span class="line">    c = dd - cc;</span><br><span class="line">    ll g = exgcd(a, b, x, y);</span><br><span class="line">    <span class="keyword">if</span> (c % g != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    x *= c / g;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>)b = -b;</span><br><span class="line">    ll t = b / g;</span><br><span class="line">    x = (x % t + t) % t;<span class="comment">//最小的x</span></span><br><span class="line">    ll ans = x * n + cc;</span><br><span class="line">    ll lcm = (n * m) / gcd(n, m);</span><br><span class="line">    ans = ((ans - <span class="number">1</span>) % lcm + lcm) % lcm + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mind</span><span class="params">(N, <span class="number">-1</span>)</span>, <span class="title">val</span><span class="params">(N)</span></span>;<span class="comment">//整除i的最小素数，i整除i的素数个数</span></span><br><span class="line">mind[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) <span class="keyword">if</span> (mind[i] == <span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i) <span class="keyword">if</span> (mind[j] == <span class="number">-1</span>)</span><br><span class="line">    mind[j] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> j = i / mind[i];</span><br><span class="line">  val[i] = val[j] + (mind[i] != mind[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="MIN25筛素数"><a href="#MIN25筛素数" class="headerlink" title="MIN25筛素数"></a>MIN25筛素数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="keyword">int</span> lenp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">7000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> g[<span class="number">7000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=lim)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> len-n/x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	lim=<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i=a[len]+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a[++len]=n/(n/i);</span><br><span class="line">		g[len]=a[len]<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=lim;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(g[i]!=g[i<span class="number">-1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			++lenp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=len;a[j]&gt;=<span class="number">1ll</span>*i*i;--j)</span><br><span class="line">				g[j]=g[j]-g[get_index(a[j]/i)]+lenp<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;g[len];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="MIN25筛素数和"><a href="#MIN25筛素数和" class="headerlink" title="MIN25筛素数和"></a>MIN25筛素数和</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> Min25 &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> prime[N], id1[N], id2[N], flag[N], ncnt, m;</span><br><span class="line"> </span><br><span class="line">    LL g[N], sum[N], a[N], T, n;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= T ? id1[x] : id2[n / x];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">f</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - <span class="number">1</span>] + i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= T; j++) &#123;</span><br><span class="line">                flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (LL l = <span class="number">1</span>; l &lt;= n; l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">            a[++m] = n / l;</span><br><span class="line">            <span class="keyword">if</span> (a[m] &lt;= T) id1[a[m]] = m; <span class="keyword">else</span> id2[n / a[m]] = m;</span><br><span class="line">            g[m] = calc(a[m]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; (LL)prime[i] * prime[i] &lt;= a[j]; j++) </span><br><span class="line">                g[j] = g[j] - (LL)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> n = x, init(), g[ID(n)];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Min25::solve(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="区间筛"><a href="#区间筛" class="headerlink" title="区间筛"></a>区间筛</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> v1[Max_n1]; <span class="comment">//数组大小为sqrt(b)</span></span><br><span class="line"><span class="keyword">bool</span> v2[Max_n2]; <span class="comment">//数组大小为b-a</span></span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">Prime</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i*i&lt;b;i++)v1[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;b-a;i++)v2[i]=<span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;b;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v1[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(ll j=<span class="number">2</span>*i;j*j&lt;b;j+=i)v1[j]=<span class="literal">false</span>; <span class="comment">//筛[2,b)</span></span><br><span class="line">            <span class="keyword">for</span>(ll j=max(<span class="number">2LL</span>,(a+i<span class="number">-1</span>)/i)*i;j&lt;b;j+=i)v2[j-a]=<span class="literal">false</span>; <span class="comment">//筛[a,b)</span></span><br><span class="line">            <span class="comment">//2LL是2的长整数形式</span></span><br><span class="line">            <span class="comment">//((a+i-1)/i)*i是符合&gt;=a最小是i倍数的数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;b-a;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v2[i])k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">316300</span>;</span><br><span class="line">ll n, g[N&lt;&lt;<span class="number">1</span>], a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> id, cnt, sn, prime[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Id</span><span class="params">(ll x)</span></span>&#123; <span class="keyword">return</span> x&lt;=sn?x:id-n/x+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n), sn=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i=a[id]+<span class="number">1</span>) a[++id]=n/(n/i), g[id]=a[id]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=sn; ++i) <span class="keyword">if</span>(g[i]!=g[i<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="comment">// 这里 i 必然是质数，因为 g[] 是前缀质数个数</span></span><br><span class="line">        <span class="comment">// 当 &lt;i 的质数的倍数都被筛去，让 g[] 发生改变的位置只能是下一个质数</span></span><br><span class="line">        <span class="comment">// 别忘了 i&lt;=sn 时，ID(i) 就是 i。</span></span><br><span class="line">        prime[++cnt]=i;</span><br><span class="line">        ll sq=(ll)i*i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=id; a[j]&gt;=sq; --j) g[j]-=g[Id(a[j]/i)]-(cnt<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, g[id]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="素数区间求和"><a href="#素数区间求和" class="headerlink" title="素数区间求和"></a>素数区间求和</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll l,r;</span><br><span class="line"><span class="keyword">double</span> n,now,f1[N],f2[N],inv[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span>*x*(x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> S=<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">if</span>(!n)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S;++i)  f1[i]=calc(i),f2[i]=calc(n/i),inv[i]=<span class="number">1.0</span>/i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=S;++p)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(f1[p]-f1[p<span class="number">-1</span>])&lt;=eps)  <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> lim=min((ll)S,n/p/p);now=n/p;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*p&lt;=S;++i)  f2[i]-=(f2[i*p]-f1[p<span class="number">-1</span>])*p;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=S/p+<span class="number">1</span>;i&lt;=lim;++i)  f2[i]-=(f1[(<span class="keyword">int</span>)(now*inv[i]+<span class="number">1e-7</span>)]-f1[p<span class="number">-1</span>])*p;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=(ll)p*p;--i)  f1[i]-=(f1[(<span class="keyword">int</span>)(i*inv[p]+<span class="number">1e-7</span>)]-f1[p<span class="number">-1</span>])*p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f2[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.0lf\n&quot;</span>,solve(r)-solve(l<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linebasis</span>&#123;</span></span><br><span class="line">    ll p[<span class="number">65</span>], b[<span class="number">65</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">62</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!p[i])&#123;</span><br><span class="line">                    p[i] = x;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x ^= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x) cnt++;</span><br><span class="line">        <span class="keyword">else</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Linebasis <span class="keyword">operator</span> +(<span class="keyword">const</span> Linebasis &amp; r) <span class="keyword">const</span>&#123;</span><br><span class="line">        Linebasis res = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">62</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i])</span><br><span class="line">                res.insert(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">querymax</span><span class="params">(ll x = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        ll res = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">62</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((res ^ p[i]) &gt; res) res ^= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">querymin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">62</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]) <span class="keyword">return</span> p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">62</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>((p[i] &gt;&gt; j) &amp; <span class="number">1</span>) p[i] ^= p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">62</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]) b[cnt++] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">kthmax</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) k--;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= (<span class="number">1ll</span> &lt;&lt; cnt)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">62</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k &gt;&gt; i) &amp; <span class="number">1</span>) res ^= b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sol;</span><br></pre></td></tr></table></figure>

<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> a[][MAXN],<span class="keyword">bool</span> l[],<span class="keyword">double</span> ans[],<span class="keyword">const</span> <span class="keyword">int</span>&amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		l[i]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = r; i &lt; n; ++j)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i]&gt;EPS))</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; n; ++k)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[j][k],a[r][k]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fabs</span>(a[r][i])&lt;EPS)</span><br><span class="line">		&#123;</span><br><span class="line">			++res;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j!=r&amp;&amp;<span class="built_in">fabs</span>(a[j][i])&gt;EPS)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">double</span> tmp=a[j][i]/a[r][i];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">				&#123;</span><br><span class="line">					a[j][k]-=tmp*a[r][k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		l[i]=<span class="literal">true</span>,++r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(l[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i &lt; n; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i]&gt;<span class="number">0</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					ans[i]=a[j][n]/a[j][i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="降幂公式"><a href="#降幂公式" class="headerlink" title="降幂公式"></a>降幂公式</h2><p>$$<br>a^b= \begin{cases} a^{b % \varphi(p)} &amp;  gcd(a,p)=1 \  a^b &amp;  gcd(a,p)\neq 1,b &lt; \varphi (p) \  a^{b% \varphi (p) + \varphi (p)} &amp; gcd(a,p)\neq 1,b \geq \varphi (p) \end{cases}<br>$$</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>铜牌题练习</title>
    <url>/2021/10/15/%E9%93%9C%E7%89%8C%E9%A2%98%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="题目集1"><a href="#题目集1" class="headerlink" title="题目集1"></a>题目集1</h1><span id="more"></span>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p><a href="https://vjudge.net/contest/412612#problem/A">https://vjudge.net/contest/412612#problem/A</a></p>
<p>求有多少个S子串满足长度是M*L，子串划分为M节长度为L的小子串，M节小子串的每一位都不同</p>
<p>解：哈希然后尺取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ull base[N], h[N];</span><br><span class="line"><span class="function">ull <span class="title">gethash</span><span class="params">(ll l, ll r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * base[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n, m;</span><br><span class="line">    ll seed = <span class="number">31</span>;</span><br><span class="line">    base[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        base[i] = base[i - <span class="number">1</span>] * <span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            h[i] = h[i - <span class="number">1</span>] * seed + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m &amp;&amp; i+n*m &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            map&lt;ull,ll&gt; mp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i,k = <span class="number">0</span>; k &lt; n; j += m,k++) &#123;</span><br><span class="line">                mp[<span class="built_in">gethash</span>(j, j + m - <span class="number">1</span>)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">size</span>() == n)</span><br><span class="line">                ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (s.<span class="built_in">size</span>() - n * m - i)/m; j++) &#123;</span><br><span class="line">                ll tmp = <span class="built_in">gethash</span>(i + j * m, i + j * m + m - <span class="number">1</span>);</span><br><span class="line">                mp[tmp]--;</span><br><span class="line">                <span class="keyword">if</span> (mp[tmp] == <span class="number">0</span>)</span><br><span class="line">                    mp.<span class="built_in">erase</span>(tmp);</span><br><span class="line">                mp[<span class="built_in">gethash</span>(i + j * m + n * m, i + j * m + m - <span class="number">1</span> + m * n)]++;</span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">size</span>() == n)</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><a href="https://vjudge.net/contest/412612#problem/B">https://vjudge.net/contest/412612#problem/B</a></p>
<p>有n个试题，每个题目分值是ai，正确率为0.5，设得分为x，p为最终得分不超过x的概率，求得分ans，满足：P(X&lt;=ans)=p。</p>
<p>解：dp一哈，$f_{ij}$代表前i个题目得分j的概率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line">ll a[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="keyword">double</span> p;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt;<span class="built_in">f</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">double</span>&gt;(sum + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;        </span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, sum) &#123;</span><br><span class="line">                f[i][j] += f[i - <span class="number">1</span>][j] * <span class="number">0.5</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=a[i])</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][j - a[i]] * <span class="number">0.5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, sum) &#123;</span><br><span class="line">            ans += f[n][i];</span><br><span class="line">            <span class="keyword">if</span> (ans &gt;= p)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p><a href="https://vjudge.net/contest/412612#problem/C">https://vjudge.net/contest/412612#problem/C</a></p>
<p>水题</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p><a href="https://vjudge.net/contest/412612#problem/D">https://vjudge.net/contest/412612#problem/D</a></p>
<p>n个数字，求从k（1~n），n中选择k个数异或，然后把所有的情况加起来就是答案。</p>
<p>解：拆位，组合数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line">ll c[<span class="number">1005</span>][<span class="number">1005</span>], a[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">1000</span>) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, i) &#123;</span><br><span class="line">            c[i][j] = (c[i - <span class="number">1</span>][j] + c[i<span class="number">-1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">cnt</span><span class="params">(<span class="number">35</span>)</span></span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">31</span>) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                cnt[i] += (a[j] &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(k, <span class="number">1</span>, n) &#123;</span><br><span class="line">            ll ans = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">31</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j += <span class="number">2</span>) &#123;</span><br><span class="line">                    ans = (ans + (c[cnt[i]][j] * c[n - cnt[i]][k - j]) % mod * (<span class="number">1</span> &lt;&lt; i) % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans;</span><br><span class="line">            <span class="keyword">if</span>(k!=n)</span><br><span class="line">                cout&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p><a href="https://vjudge.net/contest/412612#problem/E">https://vjudge.net/contest/412612#problem/E</a></p>
<p>思维</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll r, y, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; r &gt;&gt; y &gt;&gt; b) &#123;</span><br><span class="line">        ll le = <span class="number">0</span>, ri = <span class="number">0</span>;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">0</span>)</span><br><span class="line">            le++, r--;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>)</span><br><span class="line">            res += le, le++, y--;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">            res += le, le++, b--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">0</span>)</span><br><span class="line">            ri++, r--, res += le;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>)</span><br><span class="line">            res += le + ri, ri++, y--;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">            res += le + ri, ri++, b--;</span><br><span class="line"></span><br><span class="line">        res += (r + y + b) * (le + ri);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p><a href="https://vjudge.net/contest/412612#problem/F">https://vjudge.net/contest/412612#problem/F</a></p>
<p>模拟</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">50</span>][<span class="number">50</span>], b[<span class="number">50</span>][<span class="number">50</span>],h[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">dec</span>(j, n, <span class="number">1</span>) &#123;</span><br><span class="line">            h[n-j+<span class="number">1</span>][i] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            a[i][j] = h[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == b[i][j])</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n,n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                cin &gt;&gt; b[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="built_in">getDiff</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">rotate</span>();</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">getDiff</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><a href="https://vjudge.net/contest/412612#problem/G">https://vjudge.net/contest/412612#problem/G</a></p>
<p>旅行商问题，bfs求距离后暴力</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line"><span class="keyword">char</span> g[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">ll dis[<span class="number">6</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">ll finalDis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">map&lt;pll, ll&gt; mp;</span><br><span class="line">ll d[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(ll x, ll y, ll cur)</span> </span>&#123;</span><br><span class="line">    queue&lt;pll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; x,y &#125;);</span><br><span class="line">    dis[cur][x][y] = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">vis</span>(n + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pll f = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">3</span>) &#123;</span><br><span class="line">            ll dx = f.first + d[i][<span class="number">0</span>], dy = f.second + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dx &lt;= n &amp;&amp; dx &gt;= <span class="number">1</span> &amp;&amp; dy &lt;= m &amp;&amp; dy &gt;= <span class="number">1</span> &amp;&amp; !vis[dx][dy] &amp;&amp; g[dx][dy] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; dx,dy &#125;);</span><br><span class="line">                vis[dx][dy] = <span class="number">1</span>;</span><br><span class="line">                dis[cur][dx][dy] = dis[cur][f.first][f.second] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) &#123;</span><br><span class="line">        finalDis[cur][it.second] = dis[cur][it.first.first][it.first.second];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n, m) &#123;</span><br><span class="line">        ll sx, sy;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; g[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                    sx = i, sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        mp[&#123;sx, sy&#125;] = <span class="number">0</span>;</span><br><span class="line">        ll k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        vector&lt;ll&gt; permutation;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">            ll x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            mp[&#123;x, y&#125;] = i;</span><br><span class="line">            permutation.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, k) &#123;</span><br><span class="line">                finalDis[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, n) &#123;</span><br><span class="line">                <span class="built_in">rep</span>(p, <span class="number">0</span>, m) &#123;</span><br><span class="line">                    dis[i][j][p] = INF;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : mp) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(x.first.first, x.first.second, x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = INF;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ll tot = finalDis[<span class="number">0</span>][permutation[<span class="number">0</span>]];</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, k - <span class="number">2</span>) &#123;</span><br><span class="line">                tot += finalDis[permutation[i]][permutation[i + <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, tot);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(permutation.<span class="built_in">begin</span>(), permutation.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">if</span> (ans == INF)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p><a href="https://vjudge.net/contest/412612#problem/H">https://vjudge.net/contest/412612#problem/H</a></p>
<p>暴力，遍历到中间不合要求的得剪枝，否则过不了。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line"><span class="keyword">char</span> g[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">pll mp[<span class="number">20</span>];</span><br><span class="line">ll cnt;</span><br><span class="line">ll d[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    vector&lt;ll&gt; lights;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, cnt - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x&gt;&gt;i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            lights.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,(ll)lights.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">3</span>) &#123;</span><br><span class="line">            set&lt;pll&gt; st;</span><br><span class="line">            <span class="keyword">bool</span> fg = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">0</span>, lights.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                ll x = mp[lights[k]].first, y = mp[lights[k]].second;</span><br><span class="line">                ll dx = x+d[<span class="number">0</span>][<span class="number">0</span>], dy = y+d[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (k == i) &#123;</span><br><span class="line">                    dx = x+d[j][<span class="number">0</span>], dy = y+d[j][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (g[dx][y] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[x][y] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[x][dy] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[dx][y] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        st.<span class="built_in">insert</span>(&#123; dx,y &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        st.<span class="built_in">insert</span>(&#123; x,y &#125;);</span><br><span class="line">                    <span class="keyword">if</span>(g[x][dy] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        st.<span class="built_in">insert</span>(&#123; x,dy &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fg = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">size</span>() == cnt &amp;&amp; fg) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getNum</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>)</span><br><span class="line">            ans++;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n, m) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, n + <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, m + <span class="number">1</span>)</span><br><span class="line">                g[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    mp[cnt++] = &#123; i,j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = INF;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, (<span class="number">1</span>&lt;&lt;cnt) - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123;  </span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">getNum</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == INF)</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p><a href="https://vjudge.net/contest/412612#problem/I">https://vjudge.net/contest/412612#problem/I</a></p>
<p>感觉这个思路比较重要，确定出一张图的上下限，就可以判断是否可以构造出来。如果要去通过构造来说明可以构造的话也太难了而且时间也不允许。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    ll u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u, ll v)</span> </span>&#123;</span><br><span class="line">    ll fu = <span class="built_in">find</span>(u),fv = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (fu != fv)</span><br><span class="line">        f[fu] = fv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(e[i].u) != <span class="built_in">find</span>(e[i].v)) &#123;</span><br><span class="line">            <span class="built_in">add</span>(e[i].u, e[i].v);</span><br><span class="line">            ans += e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll fa = <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) != fa)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll fib[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>, fib[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">3</span>, <span class="number">45</span>) &#123;</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="built_in">rep</span>(cas,<span class="number">1</span>,T) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        e = vector&lt;edge&gt;(m + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;   </span><br><span class="line">            <span class="built_in">add</span>(e[i].u, e[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cas &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>()) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(e.<span class="built_in">begin</span>() + <span class="number">1</span>, e.<span class="built_in">end</span>(), [](edge a, edge b) &#123;<span class="keyword">return</span> a.w &lt; b.w; &#125;);</span><br><span class="line">            ll down = <span class="built_in">getVal</span>();</span><br><span class="line">            <span class="built_in">sort</span>(e.<span class="built_in">begin</span>() + <span class="number">1</span>, e.<span class="built_in">end</span>(), [](edge a, edge b) &#123;<span class="keyword">return</span> a.w &gt; b.w; &#125;);</span><br><span class="line">            ll up = <span class="built_in">getVal</span>();</span><br><span class="line">            <span class="keyword">bool</span> fg = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">45</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fib[i] &lt;= up &amp;&amp; fib[i] &gt;= down)</span><br><span class="line">                    fg = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fg) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p><a href="https://vjudge.net/contest/412612#problem/J">https://vjudge.net/contest/412612#problem/J</a></p>
<p>猜的结论，大边和大边组合，贪心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n+<span class="number">1</span>, [](<span class="keyword">double</span> u, <span class="keyword">double</span> v) &#123;<span class="keyword">return</span> u &gt; v; &#125;);</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>] + a[i + <span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="keyword">double</span> p = (a[i] + a[i + <span class="number">1</span>] + a[i + <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">                ans += <span class="built_in">sqrt</span>(p * (p - a[i]) * (p - a[i+<span class="number">1</span>]) * (p - a[i+<span class="number">2</span>]));    </span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><p><a href="https://vjudge.net/contest/412612#problem/K">https://vjudge.net/contest/412612#problem/K</a></p>
<p>最短路</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll id, w;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a,node b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;node&gt;&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dijkstra</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>,INF)</span></span>;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">1</span>,<span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node f = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[f.id] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nxt : g[f.id]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt.id != x &amp;&amp; nxt.w+dis[f.id]&lt;dis[nxt.id]) &#123;</span><br><span class="line">                dis[nxt.id] = nxt.w + dis[f.id];</span><br><span class="line">                <span class="keyword">if</span>(!vis[nxt.id])</span><br><span class="line">                    q.<span class="built_in">push</span>(nxt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m,n,m) &#123;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        g = vector&lt;vector&lt;node&gt;&gt;(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            ll u, v, w;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            g[u].<span class="built_in">push_back</span>(&#123; v,w &#125;);</span><br><span class="line">            g[v].<span class="built_in">push_back</span>(&#123; u,w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dijkstra</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == INF)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inf&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><p><a href="https://vjudge.net/contest/412612#problem/L">https://vjudge.net/contest/412612#problem/L</a></p>
<p>区间[1,R-L+1]与区间[L,R]的长度一样，所以如果输出YES，那么区间[L,R]中的数字就是1到R-L+1数字的全排列形式。那么就判断这个满足下面两点就行</p>
<p>1、区间和等于（R-L+2）*(R-L+1)/2;</p>
<p>2.该段区间内没有重复数字。</p>
<p>坑：ll把我T飞了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tr[N &lt;&lt; <span class="number">2</span>], a[N], b[N], sum[N], pos[N];</span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    tr[x] = <span class="built_in">max</span>(tr[<span class="built_in">ls</span>(x)] , tr[<span class="built_in">rs</span>(x)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        tr[p] = b[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll ql, ll qr, ll l, ll r, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; ql || qr &lt; l)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> tr[p];</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(ql, qr, l, mid, <span class="built_in">ls</span>(p)), <span class="built_in">query</span>(ql, qr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            pos[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            b[i] = pos[a[i]];</span><br><span class="line">            pos[a[i]] = i;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            ll ql, qr;</span><br><span class="line">            cin &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line">            ll tmp = qr - ql + <span class="number">1</span>;           </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">query</span>(ql, qr, <span class="number">1</span>, n, <span class="number">1</span>) &lt; ql &amp;&amp; (<span class="number">1</span> + tmp) * tmp / <span class="number">2</span> == sum[qr] - sum[ql<span class="number">-1</span>])</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p><a href="https://vjudge.net/contest/412612#problem/M">https://vjudge.net/contest/412612#problem/M</a></p>
<p>暴力</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> mp[<span class="number">220</span>][<span class="number">220</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (point a, point b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x == b.x)</span><br><span class="line">            <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> &#123;</span></span><br><span class="line">    point p1, p2;</span><br><span class="line">    ll area;</span><br><span class="line">    <span class="built_in">rectangle</span>(point tp1, point tp2) &#123;</span><br><span class="line">        p1 = tp1;</span><br><span class="line">        p2 = tp2;</span><br><span class="line">        area = (p2.x - p1.x) * (p2.y - p1.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rectangle</span>() &#123;&#125;;</span><br><span class="line">&#125;r[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(ll i, ll j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r[i].p2.x &lt; r[j].p1.x ||</span><br><span class="line">        r[i].p2.y &lt; r[j].p1.y ||</span><br><span class="line">        r[i].p1.x &gt; r[j].p2.x ||</span><br><span class="line">        r[i].p1.y &gt; r[j].p2.y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r[i].p1.x &lt; r[j].p1.x &amp;&amp;</span><br><span class="line">        r[i].p1.y &lt; r[j].p1.y &amp;&amp;</span><br><span class="line">        r[j].p2.x &lt; r[i].p2.x &amp;&amp;</span><br><span class="line">        r[j].p2.y &lt; r[i].p2.y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n,n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">            mp[p[i].x][p[i].y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, i + <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp[p[i].x][p[j].y] &amp;&amp; mp[p[j].x][p[i].y] &amp;&amp;</span><br><span class="line">                    p[j].x &gt; p[i].x &amp;&amp; p[j].y&gt;p[i].y) &#123;</span><br><span class="line">                    <span class="comment">//r[++cnt].p1 = p[i],r[cnt].p2 = p[j],r[cnt].area = (p[j].y-p[i].y)*(p[j].x - p[i].x);</span></span><br><span class="line">                    r[++cnt] = <span class="built_in">rectangle</span>(p[i], p[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, cnt) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, cnt) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(i, j)==<span class="number">1</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, r[i].area + r[j].area);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">check</span>(i, j) == <span class="number">2</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, r[i].area);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;imp&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>铜牌题</tag>
      </tags>
  </entry>
  <entry>
    <title>DP in AcWing</title>
    <url>/2022/01/23/DP-in-AcWing/</url>
    <content><![CDATA[<h3 id="AcWing-271-杨老师的照相排列"><a href="#AcWing-271-杨老师的照相排列" class="headerlink" title="AcWing 271. 杨老师的照相排列"></a><a href="https://www.acwing.com/problem/content/273/">AcWing 271. 杨老师的照相排列</a></h3><span id="more"></span>

<p>从高到低依次安排每个同学的位置，那么在安排过程中，当前同学一定占据每排最靠左的连续若干个位置，且从后往前每排人数单调递减。否则一定不满足“每排从左到右身高递减，从后到前身高也递减”这个要求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">ll dp[<span class="number">31</span>][<span class="number">31</span>][<span class="number">31</span>][<span class="number">31</span>][<span class="number">31</span>], s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n,n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">            s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cin &gt;&gt; s[i];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(a, <span class="number">0</span>, s[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(b, <span class="number">0</span>, <span class="built_in">min</span>(a,s[<span class="number">2</span>])) &#123;</span><br><span class="line">                <span class="built_in">rep</span>(c, <span class="number">0</span>, <span class="built_in">min</span>(b, s[<span class="number">3</span>])) &#123;</span><br><span class="line">                    <span class="built_in">rep</span>(d, <span class="number">0</span>, <span class="built_in">min</span>(c, s[<span class="number">4</span>])) &#123;</span><br><span class="line">                        <span class="built_in">rep</span>(e, <span class="number">0</span>, <span class="built_in">min</span>(d, s[<span class="number">5</span>])) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; a &gt;= b - <span class="number">1</span>) dp[a][b][c][d][e] += dp[a - <span class="number">1</span>][b][c][d][e];</span><br><span class="line">                            <span class="keyword">if</span> (b &gt; <span class="number">0</span> &amp;&amp; b &gt;= c - <span class="number">1</span>) dp[a][b][c][d][e] += dp[a][b - <span class="number">1</span>][c][d][e];</span><br><span class="line">                            <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; c &gt;= d - <span class="number">1</span>) dp[a][b][c][d][e] += dp[a][b][c - <span class="number">1</span>][d][e];</span><br><span class="line">                            <span class="keyword">if</span> (d &gt; <span class="number">0</span> &amp;&amp; d &gt;= e - <span class="number">1</span>) dp[a][b][c][d][e] += dp[a][b][c][d - <span class="number">1</span>][e];</span><br><span class="line">                            <span class="keyword">if</span> (e &gt; <span class="number">0</span>) dp[a][b][c][d][e] += dp[a][b][c][d][e - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[s[<span class="number">1</span>]][s[<span class="number">2</span>]][s[<span class="number">3</span>]][s[<span class="number">4</span>]][s[<span class="number">5</span>]] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-272-最长公共上升子序列"><a href="#AcWing-272-最长公共上升子序列" class="headerlink" title="AcWing 272. 最长公共上升子序列"></a><a href="https://www.acwing.com/problem/content/274/">AcWing 272. 最长公共上升子序列</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n,a[N], b[N], dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll maxn = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//a[1~i] b[1~j]以b[j]结尾的公共上升子序列集合中长度最大值</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], maxn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; b[j])</span><br><span class="line">                maxn = <span class="built_in">max</span>(maxn, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-273-分级"><a href="#AcWing-273-分级" class="headerlink" title="AcWing 273. 分级"></a><a href="https://www.acwing.com/problem/content/275/">AcWing 273. 分级</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">ll dp[N][N], a[N], b[N];<span class="comment">// 前i个 最后一个用a[j]的最小值</span></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll minn = INF;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            dp[i][j] = minn + <span class="built_in">abs</span>(a[i] - b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = INF;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        res = <span class="built_in">min</span>(res, dp[n][i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    ll res = <span class="built_in">solve</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    res = <span class="built_in">min</span>(res, <span class="built_in">solve</span>());</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-274-移动服务"><a href="#AcWing-274-移动服务" class="headerlink" title="AcWing 274. 移动服务"></a><a href="https://www.acwing.com/problem/content/276/">AcWing 274. 移动服务</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">1005</span>][N][N];</span><br><span class="line">ll g[N][N], a[<span class="number">1005</span>];</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, INF, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == j || j == k || a[i] == k)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dp[i + <span class="number">1</span>][j][k] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j][k],dp[i][j][k] + g[a[i]][a[i + <span class="number">1</span>]]);</span><br><span class="line">                dp[i + <span class="number">1</span>][a[i]][k] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][a[i]][k], dp[i][j][k] + g[j][a[i + <span class="number">1</span>]]);</span><br><span class="line">                dp[i + <span class="number">1</span>][j][a[i]] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j][a[i]], dp[i][j][k] + g[k][a[i + <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = INF;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dp[m][i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-275-传纸条"><a href="#AcWing-275-传纸条" class="headerlink" title="AcWing 275. 传纸条"></a><a href="https://www.acwing.com/problem/content/277/">AcWing 275. 传纸条</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line">ll n, m;</span><br><span class="line">ll dp[<span class="number">105</span>][<span class="number">55</span>][<span class="number">55</span>], g[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">max</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;);</span><br><span class="line">    <span class="built_in">rep</span>(k, <span class="number">2</span>, n + m) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>,k-m);i&lt;=n &amp;&amp; i&lt;k;i++) &#123;<span class="comment">//注意这个范围！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">max</span>(<span class="number">1</span>, k - m); j &lt;= n &amp;&amp; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j &amp;&amp; k!=<span class="number">2</span> &amp;&amp; k!=n+m)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dp[k][i][j] = <span class="built_in">max</span>(dp[k][i][j], <span class="built_in">max</span>(&#123; dp[k - <span class="number">1</span>][i - <span class="number">1</span>][j],dp[k - <span class="number">1</span>][i][j - <span class="number">1</span>],dp[k - <span class="number">1</span>][i][j],dp[k - <span class="number">1</span>][i - <span class="number">1</span>][j - <span class="number">1</span>] &#125;) + g[i][k - i] + g[j][k - j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n + m][n][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mondriaan’s-Dream"><a href="#Mondriaan’s-Dream" class="headerlink" title="Mondriaan’s Dream"></a><a href="http://poj.org/problem?id=2411">Mondriaan’s Dream</a></h3><p>突然想起来，完美覆盖比较有意思，乱入一哈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">12</span>][<span class="number">1</span> &lt;&lt; <span class="number">11</span>], s[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n, m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) &#123;</span><br><span class="line">            ll cnt = <span class="number">0</span>, odd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                    odd |= cnt, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s[i] = odd | cnt ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (ll k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; m; k++) &#123;</span><br><span class="line">                    <span class="comment">//不可以上下都是1，如果上下是0，也不可以单独地出现</span></span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; s[j | k]) &#123;</span><br><span class="line">                        dp[i][j] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[n][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-277-饼干"><a href="#AcWing-277-饼干" class="headerlink" title="AcWing 277. 饼干"></a><a href="https://www.acwing.com/problem/content/279/">AcWing 277. 饼干</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">31</span>][<span class="number">5001</span>], s[<span class="number">31</span>], ans[<span class="number">31</span>];</span><br><span class="line">pll g[<span class="number">31</span>];</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; g[i].first, g[i].second = i;</span><br><span class="line">    <span class="built_in">sort</span>(g + <span class="number">1</span>, g + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(g + <span class="number">1</span>, g + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + g[i].first;</span><br><span class="line">    <span class="built_in">memset</span>(dp, INF, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, i, m) &#123;</span><br><span class="line">            dp[i][j] = dp[i][j - i];</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">1</span>, i) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - k][j - k] + (s[i] - s[i - k]) * (i - k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    ll i = n, j = m, h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &amp;&amp; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] == dp[i][j - i])</span><br><span class="line">            j -= i, h++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">rep</span>(k, <span class="number">1</span>, i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == dp[i - k][j - k] + (s[i] - s[i - k]) * (i - k)) &#123;</span><br><span class="line">                    <span class="built_in">dec</span>(u, i, i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                        ans[g[u].second] = h + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i -= k, j -= k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-278-数字组合"><a href="#AcWing-278-数字组合" class="headerlink" title="AcWing 278. 数字组合"></a><a href="https://www.acwing.com/problem/content/280/">AcWing 278. 数字组合</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">10001</span>], a[<span class="number">101</span>];</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">dec</span>(j,m,<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= j)</span><br><span class="line">                dp[j] += dp[j - a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-279-自然数拆分"><a href="#AcWing-279-自然数拆分" class="headerlink" title="AcWing 279. 自然数拆分"></a><a href="https://www.acwing.com/problem/content/281/">AcWing 279. 自然数拆分</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">2147483648</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">4001</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, i, n) &#123;</span><br><span class="line">            dp[j] += dp[j-i];</span><br><span class="line">            dp[j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (dp[n]<span class="number">-1</span>)%mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-280-陪审团"><a href="#AcWing-280-陪审团" class="headerlink" title="AcWing 280. 陪审团"></a><a href="https://www.acwing.com/problem/content/description/282/">AcWing 280. 陪审团</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">205</span>][<span class="number">25</span>][<span class="number">805</span>], p[<span class="number">205</span>], d[<span class="number">205</span>], n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll cas = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n, m) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Jury #&quot;</span> &lt;&lt; cas++ &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cin &gt;&gt; p[i] &gt;&gt; d[i];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        ll base = <span class="number">400</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][base] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, i) &#123;</span><br><span class="line">                <span class="built_in">rep</span>(k, <span class="number">0</span>, <span class="number">800</span>) &#123;</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    ll c = k - p[i] + d[i];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; c&gt;=<span class="number">0</span> &amp;&amp; c&lt;=<span class="number">800</span>)</span><br><span class="line">                        dp[i][j][k] = <span class="built_in">max</span>(dp[i][j][k], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][c] + p[i] + d[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (dp[n][m][base + v] &lt; <span class="number">0</span> &amp;&amp; dp[n][m][base - v] &lt; <span class="number">0</span>)</span><br><span class="line">            v++;</span><br><span class="line">        v = base + (dp[n][m][base + v] &gt; dp[n][m][base - v] ? v : -v);</span><br><span class="line">        vector&lt;ll&gt; ans;</span><br><span class="line"></span><br><span class="line">        ll i = n, j = m;</span><br><span class="line">        <span class="keyword">while</span> (j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j][v] == dp[i - <span class="number">1</span>][j][v])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                v -= p[i] - d[i];</span><br><span class="line">                i--, j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll sp = <span class="number">0</span>, sd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">            sp += p[x];</span><br><span class="line">            sd += d[x];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Best jury has value &quot;</span> &lt;&lt; sp &lt;&lt; <span class="string">&quot; for prosecution and value &quot;</span> &lt;&lt; sd &lt;&lt; <span class="string">&quot; for defence:\n&quot;</span>;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重背包问题-III"><a href="#多重背包问题-III" class="headerlink" title="多重背包问题 III"></a><a href="https://www.acwing.com/problem/content/6/">多重背包问题 III</a></h3><p>太经典了多来几遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][M];</span><br><span class="line"><span class="keyword">int</span> q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; v[i]; ++ r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &lt;= m; j += v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; j - q[hh] &gt; s[i] * v[i]) hh ++ ;</span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; f[i - <span class="number">1</span>][q[tt]] + (j - q[tt]) / v[i] * w[i] &lt;= f[i - <span class="number">1</span>][j]) -- tt;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][q[hh]] + (j - q[hh]) / v[i] * w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][M];</span><br><span class="line"><span class="keyword">int</span> q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; v[i]; ++ r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &lt;= m; j += v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; j - q[hh] &gt; s[i] * v[i]) hh ++ ;</span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][q[tt]] + (j - q[tt]) / v[i] * w[i] &lt;= f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j]) -- tt;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                f[i &amp; <span class="number">1</span>][j] = f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][q[hh]] + (j - q[hh]) / v[i] * w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n &amp; <span class="number">1</span>][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-281-硬币"><a href="#AcWing-281-硬币" class="headerlink" title="AcWing 281. 硬币"></a><a href="https://www.acwing.com/problem/content/283/">AcWing 281. 硬币</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">2147483648</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll a[<span class="number">101</span>], c[<span class="number">101</span>], dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n, m) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            cin &gt;&gt; c[i];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ll used[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, m) &#123;</span><br><span class="line">                used[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">rep</span>(j, a[i], m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dp[j] &amp;&amp; dp[j - a[i]] &amp;&amp; used[j - a[i]] &lt; c[i])</span><br><span class="line">                    dp[j] = <span class="number">1</span>, used[j] = used[j - a[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i])</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-282-石子合并"><a href="#AcWing-282-石子合并" class="headerlink" title="AcWing 282. 石子合并"></a><a href="https://www.acwing.com/problem/content/284/">AcWing 282. 石子合并</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n, a[<span class="number">305</span>], dp[<span class="number">305</span>][<span class="number">305</span>], pre[<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i], dp[i][i] = <span class="number">0</span>, pre[i] = pre[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="built_in">rep</span>(len, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n-len+<span class="number">1</span>) &#123;</span><br><span class="line">            ll j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(k, i, j<span class="number">-1</span> ) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + pre[j] - pre[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-283-多边形"><a href="#AcWing-283-多边形" class="headerlink" title="AcWing 283. 多边形"></a><a href="https://www.acwing.com/problem/content/285/">AcWing 283. 多边形</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n, dp[<span class="number">2</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll w;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; w;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            dp[j][i + n][i + n] = dp[j][i][i] = w;</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(len, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">2</span>*n - len + <span class="number">1</span>) &#123;</span><br><span class="line">            ll j = i + len - <span class="number">1</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i][j] = INF, dp[<span class="number">1</span>][i][j] = -INF;</span><br><span class="line">            <span class="built_in">rep</span>(k, i, j - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[k+<span class="number">1</span>] == <span class="string">&#x27;t&#x27;</span>) &#123;</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="built_in">min</span>(dp[<span class="number">0</span>][i][j], dp[<span class="number">0</span>][i][k] + dp[<span class="number">0</span>][k + <span class="number">1</span>][j]);</span><br><span class="line">                    dp[<span class="number">1</span>][i][j] = <span class="built_in">max</span>(dp[<span class="number">1</span>][i][j], dp[<span class="number">1</span>][i][k] + dp[<span class="number">1</span>][k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="built_in">min</span>(&#123; dp[<span class="number">0</span>][i][j],dp[<span class="number">0</span>][i][k] * dp[<span class="number">0</span>][k + <span class="number">1</span>][j], </span><br><span class="line">                                                    dp[<span class="number">0</span>][i][k] * dp[<span class="number">1</span>][k + <span class="number">1</span>][j], </span><br><span class="line">                                                    dp[<span class="number">1</span>][i][k] * dp[<span class="number">0</span>][k + <span class="number">1</span>][j], </span><br><span class="line">                                                    dp[<span class="number">1</span>][i][k] * dp[<span class="number">1</span>][k + <span class="number">1</span>][j], &#125;);</span><br><span class="line">                    dp[<span class="number">1</span>][i][j] = <span class="built_in">max</span>(&#123; dp[<span class="number">1</span>][i][j], dp[<span class="number">0</span>][i][k] * dp[<span class="number">0</span>][k + <span class="number">1</span>][j], </span><br><span class="line">                                                     dp[<span class="number">0</span>][i][k] * dp[<span class="number">1</span>][k + <span class="number">1</span>][j],  </span><br><span class="line">                                                     dp[<span class="number">1</span>][i][k] * dp[<span class="number">0</span>][k + <span class="number">1</span>][j],  </span><br><span class="line">                                                     dp[<span class="number">1</span>][i][k] * dp[<span class="number">1</span>][k + <span class="number">1</span>][j], &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll maxn = -INF;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, dp[<span class="number">1</span>][i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; ans;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxn == dp[<span class="number">1</span>][i][i + n - <span class="number">1</span>])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxn &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-284-金字塔"><a href="#AcWing-284-金字塔" class="headerlink" title="AcWing 284. 金字塔"></a><a href="https://www.acwing.com/problem/content/286/">AcWing 284. 金字塔</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">ll dp[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    ll n = s.<span class="built_in">size</span>();</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll len = <span class="number">3</span>;len &lt;= n;len+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n - len + <span class="number">1</span>) &#123;</span><br><span class="line">            ll j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll k = i;k&lt;=j<span class="number">-1</span>;k+=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[k] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i][k] * dp[k + <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-285-没有上司的舞会"><a href="#AcWing-285-没有上司的舞会" class="headerlink" title="AcWing 285. 没有上司的舞会"></a><a href="https://www.acwing.com/problem/content/287/">AcWing 285. 没有上司的舞会</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; g[<span class="number">6005</span>];</span><br><span class="line">ll a[<span class="number">6005</span>], dp[<span class="number">2</span>][<span class="number">6005</span>], d[<span class="number">6005</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>][x] = a[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">        dp[<span class="number">0</span>][x] += <span class="built_in">max</span>(dp[<span class="number">1</span>][to], dp[<span class="number">0</span>][to]);</span><br><span class="line">        dp[<span class="number">1</span>][x] += dp[<span class="number">0</span>][to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        ll u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        d[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ll f = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(f);</span><br><span class="line">        ans += <span class="built_in">max</span>(dp[<span class="number">0</span>][f], dp[<span class="number">1</span>][f]);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-286-选课"><a href="#AcWing-286-选课" class="headerlink" title="AcWing 286. 选课"></a><a href="https://www.acwing.com/problem/content/288/">AcWing 286. 选课</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">305</span>][<span class="number">305</span>], a[<span class="number">305</span>];</span><br><span class="line">vector&lt;ll&gt; g[<span class="number">305</span>];</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">        <span class="built_in">dec</span>(i, m, <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">1</span>, i) &#123;</span><br><span class="line">                dp[x][i] = <span class="built_in">max</span>(dp[x][i], dp[x][i - j] + dp[to][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dec</span>(i, m, <span class="number">1</span>) &#123;</span><br><span class="line">        dp[x][i] = dp[x][i - <span class="number">1</span>] + a[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll u;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; a[i];</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-287-积蓄程度"><a href="#AcWing-287-积蓄程度" class="headerlink" title="AcWing 287. 积蓄程度"></a><a href="https://www.acwing.com/problem/content/289/">AcWing 287. 积蓄程度</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;pll&gt; g[<span class="number">200005</span>];</span><br><span class="line">ll sum[<span class="number">200005</span>], d[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x, ll fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to.first == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (d[to.first] == <span class="number">1</span>) &#123;</span><br><span class="line">            sum[x] += to.second;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(to.first, x);</span><br><span class="line">        sum[x] += <span class="built_in">min</span>(to.second, sum[to.first]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll x, ll fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to.first == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (d[x] == <span class="number">1</span>) &#123;</span><br><span class="line">            sum[to.first] += to.second;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[to.first] += <span class="built_in">min</span>(to.second, sum[x] - <span class="built_in">min</span>(sum[to.first], to.second));</span><br><span class="line">        <span class="built_in">dfs1</span>(to.first, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            g[i].<span class="built_in">clear</span>(), sum[i] = <span class="number">0</span>, d[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            ll u, v, w;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            d[u]++, d[v]++;</span><br><span class="line">            g[u].<span class="built_in">push_back</span>(&#123; v,w &#125;);</span><br><span class="line">            g[v].<span class="built_in">push_back</span>(&#123; u,w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum[i]);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-288-休息时间"><a href="#AcWing-288-休息时间" class="headerlink" title="AcWing 288. 休息时间"></a><a href="https://www.acwing.com/problem/content/290/">AcWing 288. 休息时间</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll n, b;</span><br><span class="line">ll dp[<span class="number">2</span>][<span class="number">4005</span>][<span class="number">2</span>], a[<span class="number">4005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; b;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, b) &#123;</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = dp[n &amp; <span class="number">1</span>][b][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, b) &#123;</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, dp[n &amp; <span class="number">1</span>][b][<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-289-环路运输"><a href="#AcWing-289-环路运输" class="headerlink" title="AcWing 289. 环路运输"></a><a href="https://www.acwing.com/problem/content/291/">AcWing 289. 环路运输</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll n, b;</span><br><span class="line">ll a[<span class="number">2000005</span>], q[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        cin &gt;&gt; a[i], a[i + n] = a[i];</span><br><span class="line">    ll hh = <span class="number">0</span>, tt = <span class="number">-1</span>, ans = <span class="number">0</span>, len = n / <span class="number">2</span>;</span><br><span class="line">    q[++tt] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n+len) &#123;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; i - q[hh] &gt;= len) hh++;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a[q[hh]] - q[hh] + i + a[i]);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]]-q[tt] &lt; a[i] - i) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-292-炮兵阵地"><a href="#AcWing-292-炮兵阵地" class="headerlink" title="AcWing 292. 炮兵阵地"></a><a href="https://www.acwing.com/problem/content/294/">AcWing 292. 炮兵阵地</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; <span class="number">10</span>][<span class="number">1</span> &lt;&lt; <span class="number">10</span>],cnt[<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">105</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; st, head[<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(st &amp; st &gt;&gt; <span class="number">1</span> || st &amp; st &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (st) res += st &amp; <span class="number">1</span>, st &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, m<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            g[i] += (c == <span class="string">&#x27;H&#x27;</span>) &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(s, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(s)) &#123;</span><br><span class="line">            st.<span class="built_in">push_back</span>(s);</span><br><span class="line">            cnt[s] = <span class="built_in">count</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cur : st) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pre : st) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(cur &amp; pre)) &#123;</span><br><span class="line">                head[cur].<span class="built_in">push_back</span>(pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : st) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(g[i] &amp; s)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p1 : head[s]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> p2 : head[p1]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(s &amp; p2)) &#123;</span><br><span class="line">                            dp[i &amp; <span class="number">1</span>][s][p1] = <span class="built_in">max</span>(dp[i &amp; <span class="number">1</span>][s][p1], dp[i - <span class="number">1</span> &amp; <span class="number">1</span>][p1][p2] + cnt[s]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s : st) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pre : head[s]) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[n &amp; <span class="number">1</span>][s][pre]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-529-宝藏"><a href="#AcWing-529-宝藏" class="headerlink" title="AcWing 529. 宝藏"></a><a href="https://www.acwing.com/problem/content/531/">AcWing 529. 宝藏</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">12</span>][<span class="number">12</span>], g[<span class="number">1</span> &lt;&lt; <span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) d[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        a--, b--;</span><br><span class="line">        d[a][b] = d[b][a] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="keyword">if</span> (d[j][k] != INF)</span><br><span class="line">                        g[i] |= <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[<span class="number">1</span> &lt;&lt; i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (i - <span class="number">1</span>); j; j = (j - <span class="number">1</span>) &amp; i)</span><br><span class="line">            <span class="keyword">if</span> ((g[j] &amp; i) == i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> remain = i ^ j;</span><br><span class="line">                <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="keyword">if</span> (remain &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> t = INF;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line">                            <span class="keyword">if</span> (j &gt;&gt; u &amp; <span class="number">1</span>)</span><br><span class="line">                                t = <span class="built_in">min</span>(t, d[k][u]);</span><br><span class="line">                        cost += t;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++) f[i][k] = <span class="built_in">min</span>(f[i][k], f[j][k - <span class="number">1</span>] + cost * k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = <span class="built_in">min</span>(res, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="邻值查找"><a href="#邻值查找" class="headerlink" title="邻值查找"></a><a href="https://www.acwing.com/problem/content/description/138/">邻值查找</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    set&lt;pll&gt; st;</span><br><span class="line">    set&lt;pll&gt;::iterator it;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        st.<span class="built_in">insert</span>(&#123; x,i &#125;);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        it = st.<span class="built_in">find</span>(&#123; x,i &#125;);</span><br><span class="line">        pll ans = &#123; INF,<span class="number">-1</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span> (++it != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ans = &#123; (*it).first - x,(*it).second &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">if</span> (it-- != st.<span class="built_in">begin</span>() &amp;&amp; ans.first &gt;= x - (*it).first) &#123;</span><br><span class="line">            ans = &#123; x - (*it).first,(*it).second &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-300-任务安排1"><a href="#AcWing-300-任务安排1" class="headerlink" title="AcWing 300. 任务安排1"></a><a href="https://www.acwing.com/problem/content/302/">AcWing 300. 任务安排1</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">ll n, s;</span><br><span class="line">ll st[<span class="number">5005</span>], sc[<span class="number">5005</span>], dp[<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        cin &gt;&gt; st[i] &gt;&gt; sc[i];</span><br><span class="line">        st[i] += st[i - <span class="number">1</span>];</span><br><span class="line">        sc[i] += sc[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">0</span>, i<span class="number">-1</span>) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + st[i] * (sc[i] - sc[j]) + s * (sc[n] - sc[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AcWing-2889-再探石子合并"><a href="#AcWing-2889-再探石子合并" class="headerlink" title="AcWing 2889. 再探石子合并"></a><a href="https://www.acwing.com/problem/content/2892/">AcWing 2889. 再探石子合并</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(ll i=(a);i&lt;=(b);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,a,b) for(ll i=(a);i&gt;=(b);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, pre[<span class="number">5005</span>], dp[<span class="number">5005</span>][<span class="number">5005</span>], m[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        cin &gt;&gt; pre[i];</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        m[i][i] = i;</span><br><span class="line">        pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(len, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n -len +<span class="number">1</span>) &#123;</span><br><span class="line">            ll j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = m[i][j - <span class="number">1</span>]; k &lt;= m[i + <span class="number">1</span>][j]; k++) &#123;</span><br><span class="line">                ll tmp = dp[i][k] + dp[k + <span class="number">1</span>][j] + pre[j] - pre[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> ( tmp &lt; dp[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = tmp;</span><br><span class="line">                    m[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>软件建模</title>
    <url>/2021/10/11/%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h1 id="用例与用例图"><a href="#用例与用例图" class="headerlink" title="用例与用例图"></a>用例与用例图</h1><span id="more"></span>

<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p><strong>一个用例</strong>(use case)表示系统中一部分<strong>功能和行为</strong>；系统<strong>所有</strong>的功能和行为都可建模为用例。</p>
<p>一个用例是系统所执行的<strong>一组动作的规范</strong>；</p>
<p>这些动作的执行将产生一个<strong>可观察的结果</strong>；</p>
<p>该结果对参与者或相关人具有<strong>特殊价值</strong>。</p>
<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><p>一个<strong>参与者</strong>actor确定了一种<strong>角色</strong>；<br>该角色由用户或其它系统所扮演；<br>用户或其它系统在与主题subject<strong>交互时扮演特定角色</strong>。</p>
<p>角色role表示参与特定语境中的某实体被命名的特定行为。<br><strong>参与者之间关系：泛化关系、关联关系。</strong></p>
<h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>表示一组用例、参与者及关系的图。</p>
<p>表现<strong>系统的行为</strong>，系统对其外部提供的<strong>可见的服务</strong>。</p>
<h2 id="语境"><a href="#语境" class="headerlink" title="语境"></a>语境</h2><p>所有存在于系统外部，并与系统交互的事物。</p>
<h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><p>一个子用例(sub use case)和一个超用例(super use case)间的关系;<br>子用例是其超用例的一种特殊形式；<br>子用例继承超用例中所有的特征和关联，并可增加新的特征和关联。<br>子用例的一次执行要求其超用例的一次执行。</p>
<h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><p>每个类元都需要一个<strong>名字</strong>。<br><strong>名词或名词短语</strong>，作为类或接口的名称。<br>类和接口的名字由字符、数字、其它符号组成的字符串，而且<strong>首字符大写</strong>。<br><strong>同一个包中类的名字具有唯一性。</strong></p>
<h2 id="类元"><a href="#类元" class="headerlink" title="类元"></a>类元</h2><p>类、接口、用例、参与者等元素的泛称。</p>
<p>每个类元都需要一个名字。</p>
<p>一个类元中可说明一组<strong>特征</strong>。每个特征都要确定是否是<strong>静态</strong>static的。<br><strong>静态特征是属于类元自身的特征</strong>，模型中用下划线表示<br>非静态特征是类元的实例各自持有的特征(缺省)</p>
<p>特征可分为<br>结构特征, <strong>性质属于结构特征</strong><br>行为特征, <strong>操作属于行为特征</strong></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>对类中每个对象所包含的某一种<strong>数据或状态的抽象</strong>。</p>
<p><strong>一个对象在特定时刻在每个属性上都有确定值</strong>。</p>
<p>语义：表示类的特征的名词或名词短语。<br>语法：可仅表示属性名，也可详细描述：类型、缺省值等。<br>属性名[：类型[ = 缺省值]]<br>一般首字符小写，后面其它词首字符大写。</p>
<p>readOnly 表示只读，不可改。<br>union表示该性质是多个子集合的一个派生的并集。<br>subsets &lt;性质名&gt; 该性质的值是指定某性质的值的一个子集。<br>redefines &lt;性质名&gt; 该性质是继承而来的某个指定性质的重定义。<br>ordered 表示该性质的多个值是有序的。<br>unique 表示该性质的多个值不重复。<br><prop-constraint> 用一个表达式来约束该属性的值。</p>
<h3 id="性质类型"><a href="#性质类型" class="headerlink" title="性质类型"></a>性质类型</h3><p>构造类型<br><strong>枚举类型</strong>也可作为性质的类型。枚举Enumeration是一种数据类型，包含一组枚举字面值。枚举的一个实例就是其枚举字面值中的任意一个。</p>
<h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><p>表示实例及实例间的<strong>链</strong>link<br>一个<strong>对象图</strong>是相关类图在<strong>特定运行时刻的一个“快照”</strong>snapshot<br>对象图中所描述的对象特征应符合相关类的特征，以及类之间的关系。<br>对于复杂对象的建模，往往始于对象图，<strong>多个对象图的抽象可得到类图。</strong></p>
<h3 id="实例规范"><a href="#实例规范" class="headerlink" title="实例规范"></a>实例规范</h3><p>一个实例规范表示一个实体的全部或部分<strong>特征</strong>，包括：<br>实体所属的类元classifiers；<br>实体的种类取决于其所属类元，例如<strong>类的实例是对象</strong>，而<strong>关联的实例是连接link</strong><br>实体结构特征的值的规范；</p>
<h3 id="值规范"><a href="#值规范" class="headerlink" title="值规范"></a>值规范</h3><p>一个<strong>值规范</strong>(value specification)是关于<strong>一组实例的规范</strong>，可以是<strong>对象</strong>，也可以是<strong>数据值</strong>，用于标识模型中的一个值或一组值。<strong>一个值规范可能只引用一个实例</strong>，也可能用一个表达式来表示或计算多个实例。所以<strong>一个值规范将产生零个或多个值</strong>，这些值的类型和个数应符合语境要求。<br>值规范有四种具体形式：<strong>字面规范、实例值</strong>、表达式、隐性表达式。 </p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>业务对象描述<br>实例场景描述 </p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>操作(operation)：该类对象可被请求而提供的一项服务。</p>
<p>调用操作可改变对象<strong>自身</strong>的数据或状态，或可访问对象内部的数据或状态。</p>
<p>语义：表示类的特征的动词或动词短语。<br>语法：操作名及形参，首字符小写，后面其它词的首字符大写。抽象的操作用斜体字表示。<br>同一个类中每个操作具有<strong>唯一基调</strong>(signature)：<strong>操作名</strong>及<strong>形参</strong></p>
<p><strong>一个类中的一组操作表示对本类的性质的计算。</strong></p>
<p>操作用来实现用例。<strong>每个用例都应对应有至少一个操作来实现</strong>。还需要添加更多操作。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口interface：<br><strong>类class的一种构造型stereotype;</strong><br>一组外部可见的操作的一个命名集合;<br>由一组类、构件或子系统提供实现。<br>接口描述<strong>行为规范</strong>，但不描述行为如何实现。<br>由一组类提供接口的实现。<br>类可实现接口，根据<strong>操作的基调</strong>，提供具体的实现方法method。<br>接口不能直接实例化创建对象。<br>一个接口的实例是实现该接口的类的实例。<br>一般首字母大写，建议用“I”开头。<br>语法：圆圈，或方框(与类相似，仅描述各操作)。</p>
<p><strong>供口provide interface：一个类所实现的接口</strong><br><strong>需口required interface：一个类需使用的接口</strong></p>
<p>一个接口与其他类元之间可能存在关联，这意味着该接口的实现类元与其他类元之间存在关联。两个接口之间的关联隐含着这两个接口的实现类元之间存在关联。 </p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束(Constraint)表示条件或限制，可用自然语言或形式化语言描述，对建模元素的某些语义进行限定。一个约束包含一个值规范，以规范一个或多个建模元素的附加语义。<br>约束有两类：UML预定义和用户定义。<br>模型中表示约束：<br>可以是自由文本或OCL(Object Constraint Language)表示<br>注解note方式<br>语法：花括号，{约束}</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释(comment)是连接到一组模型元素的一个文本字符串，对元素添加说明，以增强理解。注释中的内容对建模元素没有语义上的强制性，但对建模人员或其他人员可提供很多有用的信息。<br>注释一般采用注解框表示，即右上角带折角的一个矩形文本框，再用虚线连接到被注释的元素上。<br>直接连接到一个模型元素的一个文本字符串，也可以是任何可读文档，如源程序。</p>
<hr>
<h1 id="第一章、概述"><a href="#第一章、概述" class="headerlink" title="第一章、概述"></a>第一章、概述</h1><ol>
<li><p>对象的概念包括哪些含义？</p>
<blockquote>
<p>对象是具有<strong>明确定义的边界和唯一标识</strong>的一个实体</p>
<p>对象是<strong>状态和行为</strong>的一个封装体</p>
<p>对象是某个类的一个<strong>实例</strong></p>
<blockquote>
<p>实例是比对象更抽象的概念，所以一个实例不一定是一个对象</p>
</blockquote>
</blockquote>
</li>
<li><p>类的概念包括哪些含义？</p>
<blockquote>
<p>类是一组具有相同属性、操作和语义的<strong>对象的抽象描述</strong>，也能定义创建对象的方式</p>
<blockquote>
<p>类是静态的，对象是动态的</p>
</blockquote>
</blockquote>
</li>
<li><p>面向对象的基本特性有哪些？</p>
<blockquote>
<p>封装性（信息隐藏和状态保持）、继承性、多态性</p>
</blockquote>
</li>
<li><p>封装性有哪三个方面的解释？</p>
<blockquote>
<p>对象的封装、类的封装和包的封装</p>
</blockquote>
</li>
<li><p>类的封装有哪些视图？</p>
<blockquote>
<p>成员特征、可见性、静态与非静态特征</p>
</blockquote>
</li>
<li><p>多态性有哪些类型？</p>
<blockquote>
<p>类型多态性：子类对象属于父类对象</p>
<p>行为多态性：重载（同类同名操作）操作或重构（子类改写超类）操作</p>
</blockquote>
</li>
<li><p>面向对象的核心思想是什么？</p>
<blockquote>
<p>面向对象封装、信息/实现隐藏及状态保持</p>
</blockquote>
</li>
<li><p>接口的用途及实现途径？</p>
<blockquote>
<p>接口能描述使用规范，隔离使用方和实现方，划分两者的界限，</p>
<p>接口需要由类来提供实现，接口的实例是实现类的实例</p>
</blockquote>
</li>
<li><p>模型的定义及特点？</p>
<blockquote>
<p>模型是对现实的简化和抽象（定义）</p>
<p>模型是局部性的，一个模型只反映一个侧面</p>
<p>模型是抽象的，且拥有不同抽象级别，不是实际的、物理性的系统</p>
<p>模型的目的是特定的，总是出于特定的目的或意图来建立</p>
<blockquote>
<p>原型同模型是两个概念，原型一般是可执行的，模型是难以直接执行的</p>
</blockquote>
</blockquote>
</li>
<li><p>好的模型具有哪些特点？</p>
<blockquote>
<p>规范性：符合面向对象概念、原理和建模规范</p>
<p>正确性：能够正确反映客观规律</p>
<p>一致性：一套模型各部分不矛盾、不冲突</p>
<p>完备性：模型相对完整，不遗漏重要内容</p>
</blockquote>
</li>
<li><p>软件建模希望达成的目的？</p>
<blockquote>
<p>规范化设计：规范设计复杂系统的结构和行为</p>
<p>可视化表达：形象反应系统的重要特征</p>
<p>构建：获得构建系统的模板</p>
<p>存档：成为设计决策文档的组成部分</p>
</blockquote>
</li>
<li><p>建模的要素有哪些？</p>
<blockquote>
<p>建模对象：被建模的事物</p>
<p>建模规范：建模使用的建模规范，一个模型应仅采用一种建模规范</p>
<p>建模方法：建模的方式</p>
</blockquote>
</li>
<li><p>UML2的图种类：</p>
<blockquote>
<p>结构图：<strong>类图、对象图</strong>、<em><strong>包图</strong></em>、构件图、<em>复合结构图</em>、部署图</p>
<p>行为图：<strong>用例图</strong>、交互图（<strong>序列图</strong>、通信图、交互纵览图、计时图）、<strong>状态图、活动图</strong></p>
</blockquote>
</li>
</ol>
<h1 id="第二章、用例和用例图"><a href="#第二章、用例和用例图" class="headerlink" title="第二章、用例和用例图"></a>第二章、用例和用例图</h1><ol>
<li><p>用例表示什么？</p>
<blockquote>
<p>用例表示系统中一部分功能和行为，<strong>不描述实现的方式</strong></p>
<p>具体而言：</p>
<blockquote>
<p>一个用例是系统所执行的<strong>一组动作</strong>的规范</p>
<p>动作的执行将产生一个<strong>可观察</strong>的结果</p>
<p>该结果对相关的参与者具有<strong>特殊用途或价值</strong></p>
</blockquote>
</blockquote>
</li>
<li><p>参与者表示什么？</p>
<blockquote>
<p>一个参与者确定了一种<strong>用户或其他系统</strong>在与主题交互时所扮演的角色</p>
</blockquote>
</li>
<li><p>用例图中的要素都有哪些？</p>
<blockquote>
<p>用例、参与者、关系，注解、约束和包</p>
</blockquote>
</li>
<li><p>用例图中的关系有哪些？它们的概念？</p>
<blockquote>
<p>依赖关系、泛化关系和关联关系</p>
<blockquote>
<p>依赖：包括包含关系（指向被包含用例）和拓展关系（指向被扩展用例，即大用例）</p>
<p>泛化：子用例和超用例间的关系，由子用例指向超用例</p>
</blockquote>
<blockquote>
<p>参与者之间只存在依赖（如聚合关系）和泛化关系</p>
<p>参与者和用例之间只存在关联关系</p>
</blockquote>
</blockquote>
</li>
<li><p>语境的概念？</p>
<blockquote>
<p>存在于系统外部，并与系统交互的事物的抽象，定义了元素存在的环境</p>
<blockquote>
<p>用例图对系统的语境建模，用例图不能脱离语境</p>
</blockquote>
</blockquote>
</li>
<li><p>用例的建模技术有哪些？</p>
<blockquote>
<p>语境建模：先确定系统边界</p>
<p>用例及关系建模：先确定参与者的行为</p>
<p>场景建模：对用例进行深入描述</p>
</blockquote>
</li>
</ol>
<h1 id="第三章、类与接口"><a href="#第三章、类与接口" class="headerlink" title="第三章、类与接口"></a>第三章、类与接口</h1><ol>
<li><p>类元可以说明的特征种类？</p>
<blockquote>
<p>结构特征：性质</p>
<p>行为特征：操作</p>
</blockquote>
</li>
<li><p>性质的规范说明中包括哪些部分？</p>
<blockquote>
<p>[可见性] [‘/‘] 《性质名》[‘：’类型] [多重性] [默认值] [{修饰符1, [修饰符2],…}]</p>
<p>可见性包括+-#~，表public、private、protected和默认可见性</p>
<p>/表示性质的值是派生的，不是原始定义的</p>
<p>类型是该性质所属的某个类型名，默认为String</p>
<p>多重性说明值的基数，通常由上下界表示，说明有多少个，缺省为[0..1]，（注意[*]==[0..*]）</p>
<p>修饰符有多种选择</p>
<blockquote>
<p>readOnly 只读，不可改</p>
<p>union 该性质是由多个子集合的一个派生并集</p>
<p>subset+性质 表该性质的值是指定的性质值得子集</p>
<p>redefines+性质 表该性质是继承而来的某元素的重定义</p>
<p>ordered 表该性质多个值有序</p>
<p>unique 表该性质多个值不重复</p>
<p>&lt;prop-constraint&gt; 用表达式表述约束（值约束)</p>
</blockquote>
</blockquote>
</li>
<li><p>性质的类型有哪些？</p>
<blockquote>
<p>基本类型：String、Boolean、Integer和Unlimited Natural</p>
<p>构造类型：自定义类及枚举类型</p>
</blockquote>
</li>
<li><p>集聚的种类？</p>
<blockquote>
<p>一个性质如果为多值，就构成一个集聚</p>
<table>
<thead>
<tr>
<th>有序</th>
<th>唯一</th>
<th>UML种类</th>
<th>Java类型</th>
</tr>
</thead>
<tbody><tr>
<td>false</td>
<td>true</td>
<td>Set</td>
<td>Set,HashSet</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>OrderedSet</td>
<td>SortedSet,TreeSet</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>Bag</td>
<td></td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>Sequence</td>
<td>List,LinkedList,ArrayList</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>值规范的含义和具体形式？</p>
<blockquote>
<p>值规范是关于一组实例的规范，可以是对象或数据值，用于表示模型中的一个或<strong>一组</strong>值，可能引用一个实例或<strong>计算多个实例</strong>，产生<strong>零个或多个</strong>值</p>
<p>形式：字面规范、实例值、表达式、隐性表达式</p>
</blockquote>
</li>
<li><p>操作的规范说明中包括哪些部分？</p>
<blockquote>
<p>[可见性]《名称》（[参数表1] [参数表2]） [返回值] {操作约定}</p>
<p>参数表::=参数1，[参数2]</p>
<blockquote>
<p>参数[方向] 《名称》:《类型》[多重性] [默认值] [{修饰符1,修饰符2}]</p>
<p>方向取**’in’’out’或’inout’**，缺省为in，表示仅为输入量，操作完成后代有输出结果或两者均有</p>
</blockquote>
<p>返回值：表返回类型，可描述多重性</p>
<p>操作性质：</p>
<blockquote>
<p>redefines: 重定义</p>
<p>query: 不改变系统状态</p>
<p>ordered: 返回的多个值有序</p>
<p>unique: 返回多个值不重复</p>
<p>&lt;oper-constraint&gt;作用约束，如前置后置条件</p>
</blockquote>
</blockquote>
</li>
<li><p>操作和性质、用例的关系？</p>
<blockquote>
<p>和性质的关系：一个类中的一组操作表示对本类性质的计算</p>
<p>和用例的关系：操作用来实现用例，每个用例至少对应一个操作实现</p>
<blockquote>
<p>访问方法（getter,setter）一般可以省略</p>
</blockquote>
</blockquote>
</li>
<li><p>接口和类之间的关系？</p>
<blockquote>
<p>供口：一个类实现的接口，可用圆圈表示，或用空心虚线箭头指向供口</p>
<p>需口：一个类需使用的接口，可用半圆圈表示，或用尖头虚线箭头指向需口</p>
<p>若两接口间存在关联，则两接口的实现类元之间也存在关联</p>
</blockquote>
</li>
<li><p>约束的概念和类型？</p>
<blockquote>
<p>概念：约束表示条件和限制，可用自然语言或形式化语言描述</p>
<p>类型：UML预定义和用户定义</p>
</blockquote>
</li>
<li><p>注释的表示？</p>
<blockquote>
<p>用右上角带折角的举行文本框（注解框）表示，并用虚线连接到被注释的元素上</p>
</blockquote>
</li>
<li><p>类图的主要用途?</p>
<blockquote>
<p>对概念建模：组织相关概念进行建模，封装一系列概念</p>
<p>对简单协作建模：对被建模的机制进行建模，建立、聚集元素间的关系</p>
<p>对数据库模式建模：能识别永久对象</p>
</blockquote>
</li>
</ol>
<h1 id="第四章、关系建模"><a href="#第四章、关系建模" class="headerlink" title="第四章、关系建模"></a>第四章、关系建模</h1><ol start="0">
<li><p>关系描述元素之间的联系，<strong>自身也是元素</strong>，主要分为关联、泛化和依赖三种</p>
</li>
<li><p>关联的含义和表示？</p>
<blockquote>
<p>含义：关联是一种表示类间静态结构关系的非定向关系，同时也是一种类元；它确定了类型的实例之间的语义关系</p>
<p>表示：表示为连线和说明，可以表示角色，即关联中一方对另一方职责的命名，并表示多重性；可在连线上方关联名旁标箭头，表示阅读方向；可在连线标箭头，表示从箭头端容易查找箭尾端（建议不标）</p>
</blockquote>
</li>
<li><p>多重性的种类？</p>
<blockquote>
<p>传统的多重性有“1对1”，“1对多”，“多对多”三种</p>
<p>非传统的多重性如“1对2”等</p>
<blockquote>
<p>缺省为“*”,即0个到多个</p>
</blockquote>
</blockquote>
</li>
<li><p>关联的种类及对应表示？</p>
<blockquote>
<p>非聚集：无菱形，一条连线</p>
<p>共享聚集：空心菱形，各部分对象生命周期独立，即“has-a”或“has-many”关系，菱形位于整体端</p>
<p>复合聚集：实心菱形，各部分对象生命周期受限于整体，菱形位于整体端</p>
<blockquote>
<p>聚集式关联可以是自关联</p>
</blockquote>
</blockquote>
</li>
<li><p>关联类的含义及表示？</p>
<blockquote>
<p>含义：关联类是表示关联的一个类，连接一组类元且可定义自身的一组性质和操作</p>
<p>表示：虚线连接关联，类名与关联名相同</p>
</blockquote>
</li>
<li><p>限定关联的含义及表示？</p>
<blockquote>
<p>含义：限定关联是具有限定符的关联；一个限定符包含了一个或多个属性，其一个实例包含每个属性的一个值（限定符实例），限定符另一端的多重性通常为“0..1”，表示通过限定符能够简单获取另一端的一个对象</p>
<p>表示：从限定符的管理者处引出小矩形框，将关联接在矩形框上</p>
</blockquote>
</li>
<li><p>多元关联的多重性如何确立？</p>
<blockquote>
<p>限定n-1方都唯一时，检查第n方的多重性</p>
</blockquote>
</li>
<li><p>关联端可标识的修饰符有哪些？</p>
<blockquote>
<blockquote>
<p>关联端是一个性质，故所有性质的修饰符均可标识关联端</p>
</blockquote>
<p>subsets&lt;性质名&gt;：表示该端是指定性质的子集</p>
<p>redefines&lt;端名&gt;：表示该端是指定端的重定义</p>
<p>/端名：说明该端是一个派生的关联端，往往与union相关</p>
<p>union：说明该端十多个自己和构成的派生并集</p>
<p>ordered：表示该端多个元素为有序集合</p>
<p>bag：表示该端是一个集聚</p>
<p>sequence或seq：表示该端是一个序列</p>
<blockquote>
<p>缺省下关联端的类型是一个集合set</p>
</blockquote>
</blockquote>
</li>
<li><p>能够同时存在的关系有哪些？</p>
<blockquote>
<p>可以同时存在泛化和关联关系（数组和类型）、泛化和关联均隐含依赖关系</p>
</blockquote>
</li>
<li><p>泛化集的两个重要属性？</p>
<blockquote>
<p>isDisjoint（是否完全）和isCovering（是否不相交）</p>
<p>缺省为不完全和相交</p>
</blockquote>
</li>
<li><p>如何将多继承转换成单继承？</p>
<blockquote>
<p>选择一个重要的类来继承，把其他类改为接口</p>
</blockquote>
</li>
<li><p>常见的依赖关系有哪些？</p>
<blockquote>
<p>假设在client到supplier间存在映射关系（一方变化，另一方也会变化）</p>
</blockquote>
<blockquote>
<p>abstraction    抽象关系</p>
<p>derive    client可通过supplier计算得到</p>
<p>refine    client是supplier的细化</p>
<p>trace    表示不同模型中的相同概念</p>
<p>implement    client是supplier的实现</p>
<p>use    表示client需要suppier元素提供实现或操作</p>
<p>call    表示client的一个操作调用suppier的操作</p>
<p>create    表示client类元创建supplier类元的实例，指向实例</p>
<p>instantiate    表示client的某个操作创造supplier类元的实例</p>
</blockquote>
</li>
<li><p>依赖关系是否具有传递性？依赖关系是否具有可逆性？依赖关系是否具有自反性？</p>
<blockquote>
<p>都具有</p>
</blockquote>
</li>
</ol>
<h1 id="第五章、其他结构建模？"><a href="#第五章、其他结构建模？" class="headerlink" title="第五章、其他结构建模？"></a><em>第五章、其他结构建模？</em></h1><ol>
<li><p>标记值的表示及作用？</p>
<blockquote>
<p>表示：“tag=value”</p>
<p>作用：附加在构造型中，为元素添加新的性质</p>
</blockquote>
</li>
<li><p>构造型的表示、使用及作用？</p>
<blockquote>
<p>表示：利用&lt;&lt;stereotype&gt;&gt;表示，必须拥有一个名称</p>
<p>使用：将名称用两对尖括号括起，作为新类的构造型，并用注释中的标记值表示拓展值</p>
<p>作用：表示一个已有元模型元素的子类，是一种拓展机制</p>
</blockquote>
</li>
<li><p>包的概念及性质？</p>
<blockquote>
<p>概念：一种对元素分组并提供命名空间的有效的组织管理机制</p>
<p>性质：同一个包中多个元素的命名不能重复</p>
</blockquote>
</li>
<li><p>包之间可能具有的关系？</p>
<blockquote>
<p>包含关系：一个包可包含其他包作为其内层的子包</p>
<p>导入关系：一个包可导入其他包的特定成员或所有成员</p>
<p>合并关系：一个包可与其他包合并</p>
</blockquote>
</li>
<li><p>包中成员的可见性有哪些？</p>
<blockquote>
<p>public和private，包括在包内定义的成员和从外部导入的成员</p>
</blockquote>
</li>
<li><p>包导入、包合并的表示？</p>
<blockquote>
<p>包导入：使用虚线尖箭头指向要导入的包，并加入下述符号的一种</p>
<p>&lt;&lt;import&gt;&gt;：公有public导入，导入成员对包外可见</p>
<p>&lt;&lt;access&gt;&gt;：私有private导入，导入成员对包外不可见</p>
<p>包合并：使用虚线尖箭头指向被合并的包，并在虚线上标记&lt;&lt;merge&gt;&gt;</p>
</blockquote>
</li>
<li><p>复合结构图与类图的区别？</p>
<blockquote>
<p>在类元方框内表示内部结构，更形象的表示类元内部构造及协作关系</p>
</blockquote>
</li>
<li><p>端口的表示及使用？</p>
<blockquote>
<p>表示：端口是一种类元的性质，在方框边上绘制小正方形，并引出供口和需口</p>
<p>使用：在环境符合端口供口及需口的规范时，将端口对象连接到其他对象上</p>
<blockquote>
<p>模型中的端口不能映射到编程语言程序中</p>
</blockquote>
</blockquote>
</li>
<li><p>协作的表示及用途？</p>
<blockquote>
<p>表示1：用一个虚线椭圆表示，在上部区间表明名称，并在内部放入角色（其他类的对象）</p>
<p>表示2：用一个虚线椭圆表示，椭圆内写入协作名称，连接外部的类，并在连线上指明角色名称和约束条件</p>
<p>作用：定义一组协同操作的实例及角色，定义实例间的通信路径，用来描述设计模式</p>
</blockquote>
</li>
</ol>
<h1 id="第六章、交互与交互图"><a href="#第六章、交互与交互图" class="headerlink" title="第六章、交互与交互图"></a>第六章、交互与交互图</h1><ol>
<li><p>行为建模的三个方面分别对什么进行建模？</p>
<blockquote>
<p>交互（消息流）</p>
<p>状态机（状态的变化、状态流、事件流）</p>
<p>活动（做什么动作、控制流、对象流）</p>
</blockquote>
</li>
<li><p>交互内部可以描述什么？</p>
<blockquote>
<p>生命线、消息、交互片段、门、动作、(发生规范和执行规范)</p>
</blockquote>
</li>
<li><p>交互如何表示？</p>
<blockquote>
<p>描述在一个矩形框内，并在左上角的标签内标明交互的名字、形参、返回值等内容，交互中的对象之间使用链和连接件通信</p>
</blockquote>
</li>
<li><p>交互图的种类有哪些？分别强调什么？</p>
<blockquote>
<p>序列图：强调消息的时间顺序</p>
<p>通信图：强调在对象的某些结构组织的语境中消息的排列顺序（组织结构）</p>
<p>计时图：强调生命线的状态改变和时间度量</p>
<p>交互纵览图：纵览整个控制流，也表示交互细节</p>
</blockquote>
</li>
<li><p>生命线的描述规范和表示？</p>
<blockquote>
<p>描述规范：(【&lt;元素名&gt;【‘[’&lt;选择子&gt;’]’】】【:&lt;类名&gt;】)|’self’（self表示生命线式交互类元的实例）</p>
<p>表示：一个矩形框下垂一条虚线，并在矩形框内说明描述规范</p>
</blockquote>
</li>
<li><p>消息的含义和分类？</p>
<blockquote>
<p>含义：消息是一种命名元素，表示一种特定通信，定义了交互中一种特定通信</p>
<p>类型（同步异步）：同步调用、应答（回应同步调用）、异步调用（调用方得不到结果）、异步信号</p>
<p>类型（发送调用）：complete（两方都完整描述）、lost（消息没能达到目标，箭头处用小圈表示）、found（消息来源在描述范围之外），unknown（两方都不清楚，不应发生）</p>
<blockquote>
<p>有的同步调用可以转换为两个异步<strong>信号</strong></p>
</blockquote>
</blockquote>
</li>
<li><p>消息的表示规范和描述规范？</p>
<blockquote>
<p>表示规范：同步调用应答（实心箭头和虚线细箭头)、细箭头（实与虚线）、细箭头</p>
<p>描述规范：【&lt;attribute&gt;‘=’】&lt;signal-or-operation-name&gt;【’(‘【&lt;argument1&gt;…】’)’】【’:’】 </p>
<blockquote>
<p>&lt;return-value&gt;)</p>
<p>attribute:属性，保存因调用操作返回的结果</p>
<p>signal-or-operation-name:信号或操作名，不可省略</p>
<p>argument:实参，未确定实参用‘-’表示</p>
</blockquote>
</blockquote>
</li>
<li><p>创建和撤销消息的意义和表示</p>
<blockquote>
<p>意义：若交互开始前实例不存在，生命线需要明确一个创建消息；若交互结束后实例终止，实例被撤销时需要明确撤销消息</p>
<p>创建消息：虚线箭头指向实例</p>
<p>撤销消息：实现箭头指向生命线，尾端打叉</p>
</blockquote>
</li>
<li><p>发生规范和执行规范的含义及表示？</p>
<blockquote>
<p>含义：</p>
<p>发生规范是对系统执行过程中某事件发生所作的说明<strong>（发送、接收消息、门都是发生规范）</strong></p>
<p>执行规范（控制焦点）是对生命线中所执行行为的描述（表示某执行的持续时间）</p>
<p>表示：</p>
<p>执行规范表示为沿生命线的细长的垂直矩形</p>
</blockquote>
</li>
<li><p>组合片段的含义？</p>
<blockquote>
<p>一个组合片段<strong>定义了多个交互片段</strong>的一个“表达式”，有一个操作符和若干操作域组成，每个操作是整个交互的一个结构化子片段</p>
</blockquote>
</li>
<li><p>常用组合片段的操作域个数及其含义？</p>
<blockquote>
<p>alt（多个）：条件选择（switch-case），只执行其中一块或不执行</p>
<p>opt（一个）：条件满足时执行，不满足时不执行</p>
<p>par（多个）：并行，执行不相互影响</p>
<p>loop（一个）：循环执行</p>
</blockquote>
</li>
<li><p>”交互使用“的用途和表示？</p>
<blockquote>
<p>含义：在一个交互中定义另一个交互，即引用交互（使用另一个定义过的交互）</p>
<p>表示：一个用“ref”作为标签的矩形框，内含交互名并需提供对应实参，也可同消息描述规范一般获取返回值</p>
</blockquote>
</li>
<li><p>门的用途、特点及表示？</p>
<blockquote>
<p>用途：描述一个交互或交互片段的内部或外部之间的消息连接点，有输入门和输出门</p>
<p>特点：<strong>同交互的形参不同</strong>，门可在交互执行过程中与外界<strong>持续通信</strong>，在交互启动前和交互结束后仍在持续进行通信</p>
</blockquote>
</li>
<li><p>增强生命线的两种主要方式？</p>
<blockquote>
<p>状态不变式：说明处于某个状态需要满足的条件，相当于断言，使用大括号或圆角矩形描述</p>
<p>动作：描述导致对象状态发生改变的重要动作，使用矩形框表示</p>
</blockquote>
</li>
<li><p>交互图同用例、类之间的关系？</p>
<blockquote>
<p>用例：一个交互涉及一个或多个用例，并隐含着用例之间的扩展和包含关系</p>
<p>类：每条生命线的类型都应是类图中已确定的类型，调用是类图中已确定的操作</p>
</blockquote>
</li>
</ol>
<h1 id="第七章、状态机与状态图"><a href="#第七章、状态机与状态图" class="headerlink" title="第七章、状态机与状态图"></a>第七章、状态机与状态图</h1><ol>
<li><p>状态机的含义和语境？</p>
<blockquote>
<p>含义：一种行为建模元素，描述一种对象或一种交互在生命期中响应各种事件经历的一系列状态转换，及对事件的反映效果</p>
<p>语境：行为依赖于过去的行为或需要响应外部的信号的对象</p>
<blockquote>
<p><strong>状态机不关心事件来自何处</strong></p>
</blockquote>
</blockquote>
</li>
<li><p>状态的含义和表示？</p>
<blockquote>
<p>一个状态是一个对象在生命期中一个命名的条件或状况，会<strong>持续</strong>有限的时间，期间（或关系）：</p>
<blockquote>
<p>对象满足某些条件</p>
<p>对象执行一些特定的活动、动作</p>
<p>对象等待某些事件发生</p>
</blockquote>
</blockquote>
</li>
<li><p>状态的分类（按内部构成）？</p>
<blockquote>
<p>简单状态：内部没有子状态、没有区间及子机状态</p>
<p>复合状态：内部有子状态和一组装换，具有多个正交区间，也可具有嵌套结构</p>
<p>子机状态：复合状态的另一种表示，使一个状态机能使用另一个状态机</p>
</blockquote>
</li>
<li><p>状态转换的含义、要素及规范表示？</p>
<blockquote>
<p>含义：从一个原状态到一个目标状态的有向关系</p>
<p>要素：源、目的、<strong>触发器、约束、行为</strong></p>
<p>表示：【&lt;trigger&gt;【’,’&lt;trigger&gt;】*【’[‘guard’]’】【’/‘&lt;behavior-expression&gt;】】</p>
<blockquote>
<p>trigger：触发器，可引发转移的一组触发器，一个触发器关联一个事件</p>
<p>guard：一个约束条件，缺省为真，当且仅当约束条件为真时才进行转移</p>
<p>behavior-expression：当转移发生时所进行的行为</p>
</blockquote>
</blockquote>
</li>
<li><p>事件的含义、特性？</p>
<blockquote>
<p>含义：事件是在特定时间、地点发生的事情</p>
<p>特性：事件是<strong>瞬间发生的，不延续</strong>；事件<strong>不可再分割，具原子性</strong>；</p>
<blockquote>
<p>称没有先后次序或先后次序无关紧要的事件称作<strong>可并发的</strong></p>
</blockquote>
</blockquote>
</li>
<li><p>事件的常见类型？</p>
<blockquote>
<p>调用事件：对象接收到对于某操作的调用请求，在状态图中不关心请求的来源，要指定名称和实参</p>
<p>改变事件：一个改变导致布尔表达式条件为真，<strong>只要表达式的值变为真，就说明发生了改变事件</strong>，一般用when开头进行表示</p>
<p>信号事件：接收到异步信号的一种消息事件，是对象之间进行异步通信的手段，信号是瞬时的，不会有持续性（可用于分辨改变事件和信号事件）</p>
<p>时间事件：确立时间点，在时间点发生的事件为事件时间，可用after（相对时间）或at（绝对时间）开头进行表示</p>
</blockquote>
</li>
<li><p>状态内部可以表示哪些信息？</p>
<blockquote>
<p>内部活动：在一个状态内部的动作或活动，当处于该状态，动作或活动就执行，包括入口行为“entry/do”、出口行为”exit/do”和状态活动”do/dosth”（状态活动可执行多次）</p>
<p>内部转换：在状态内部的状态转换，没有目标状态也不会导致状态改变，可说明事件、条件和动作，用signal/do表示</p>
<p>延迟事件：表示某不触发状态转换的事件的识别处理被推迟到之后进行，用do/defer表示</p>
<p><em>复合状态：划分隔间并在其中说明复合状态</em></p>
</blockquote>
</li>
<li><p>复合状态的类型和表示？</p>
<blockquote>
<p>单区间复合状态：表示为嵌套的状态图（子状态互斥，同一对象不可同时位于两个子状态中）</p>
<p>多区间复合状态：用正交区间分割，在每个区间内绘制可并发的状态图，一个对象可以同时处于多个区间的某个子状态中（各区间内部子状态互斥）</p>
</blockquote>
</li>
<li><p>复合状态的状态转换规则有哪些？</p>
<blockquote>
<p>转入一个复合状态等价于转入其中的（每个）始态</p>
<p>转出复合状态等价于转换作用于其中每个子状态</p>
<p>当且仅当各区间都达到终态后，复合状态无触发转出</p>
<p>状态转换可穿越多个状态边界，离开一层状态时就要执行出口行为，进入一层状态就执行入口行为</p>
</blockquote>
</li>
<li><p>复合状态的状态转换类型？</p>
<blockquote>
<p>外部转换：在复合状态外部的转换，需要执行对应的入口行为及出口行为</p>
<p>内部转换：没有状态改变，在状态内部用signal/do的方式表示</p>
<p>局部转换：没有离开复合状态，但作用于所有子状态，执行子状态的入口和出口行为，表现为连接复合状态边框和子状态的箭头</p>
</blockquote>
</li>
<li><p>常见的伪状态及其含义？</p>
<blockquote>
<blockquote>
<p>伪状态：状态机的一类顶点，是<strong>瞬态</strong>的抽象</p>
</blockquote>
<p>始态：表示缺省的起始状态，表现为一个缺省实心圆，只有输出</p>
<p>终结：表示终止状态机的运行，即拥有状态机的对象被撤销，表现为一个大‘X’</p>
<p>分叉：将同一个转换分开成为两个或多个<strong>并发执行</strong>的转换，表现为一条粗横线，一个输入，多个输出</p>
<p>汇合：将不同正交区间中的多个转换合并，实现<strong>控制同步</strong>，表现为一条粗横线，多个输入，一个输出</p>
<p>接合：将多个转换连接起来，构建组合转换的路径，实现<strong>静态条件分支</strong>，表现为一个实心圆，<strong>多个输入</strong>输出，输出边上条件<strong>不能同时为真</strong></p>
<p>选择：实现<strong>动态条件分支</strong>，计算触发器条件并转移，表现为一个空心菱形，<strong>一个输入</strong>多个输出，输出边条件<strong>可以同时为真</strong>，此时任选其一</p>
<p><em>深历史deepHistory：表示复合状态最近激活配置，能恢复到任意深层的子状态中，表示为带H*的圆</em></p>
<p><em>浅历史shallowHistory：记录通过一层次最近激活的子状态，不包括更深层的子状态，表示为带H的圆</em></p>
<p>入口点entryPoint：提供封装机制，定义多个初始状态供外部使用，表现为在状态边缘的空心圆，标记名字</p>
<p>出口点exitPoint：提供封装机制，定义多个终态供外部使用，表现为在状态边缘的带X圆，标记名字</p>
<blockquote>
<p>终态不是伪状态，多区间复合状态中的终态具有持续时间</p>
</blockquote>
</blockquote>
</li>
</ol>
<h1 id="第八章、活动与活动图"><a href="#第八章、活动与活动图" class="headerlink" title="第八章、活动与活动图"></a>第八章、活动与活动图</h1><ol>
<li><p>活动的概念和内容？</p>
<blockquote>
<p>概念：活动是带参行为的一种规范，包含了一组动作的协同执行序列，其执行<strong>包含了一系列内部动作的执行（一次或多次）</strong></p>
<p>内容：活动名字、输入输出形参、前置后置条件，是否只读和是否单件执行（缺省非只读、非单件执行）（isReadOnly，isSingleExecution）</p>
</blockquote>
</li>
<li><p>常见的动作有哪些？</p>
<blockquote>
<p>基本功能：算术运算等</p>
<p>行为调用：调用另一个活动或操作</p>
<p>通信动作：发送或等待接收信号，或等待时间点</p>
<p>对象处理：对属性或关联值的读写</p>
<blockquote>
<p>动作可以包含一组入边和出边，既可以是对象流也可以是控制流</p>
</blockquote>
</blockquote>
</li>
<li><p>令牌包含的内容？</p>
<blockquote>
<p>令牌可以包含一个对象、多个数据项或控制点，可放置在活动图的特定节点上</p>
<blockquote>
<p>即便持有相同的值，每个<strong>令牌仍然区别于其他令牌</strong></p>
</blockquote>
</blockquote>
</li>
<li><p>活动图的构成？</p>
<blockquote>
<p>活动图由结点（动作结点、控制结点、对象结点）和边（控制流、对象流）构成</p>
</blockquote>
</li>
<li><p>动作的执行步骤包括哪些？各步骤对令牌如何处理？</p>
<blockquote>
<p>执行步骤：创建（检查条件）、启动（消耗令牌）、操作（主体部分）、完成（输出令牌）、清理（资源回收）</p>
<p>令牌处理：当所有进入的控制边都有控制令牌，引脚都有对象令牌时，动作才能执行，在启动阶段全部消耗，在完成阶段提供新的令牌</p>
</blockquote>
</li>
<li><p>如何表示动作执行过程中持续获取输入或产生输出？</p>
<blockquote>
<p>使用[stream]对动作进行标识</p>
</blockquote>
</li>
<li><p>动作结点的常见特殊类别及表示方法？</p>
<blockquote>
<p>调用动作：包含调用行为动作和调用操作动作</p>
<p>调用行为动作：调用另一个活动的动作，可表示同步调用或异步调用，表示为一个带活动名称的圆角矩形，并在右下角标记树形符号<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211015163201803.png" alt="image-20211015163201803" style="zoom:50%;" /></p>
<p>调用操作动作：向一个目标对象传送某个操作的请求，表现为以操作名为动作名（下部可标注类名）的圆角矩形，动作名称可以与操作名称不同，但此时必须指明操作名</p>
<p>发送信号动作：创建信号实例并发送到目标对象，也可不描述信号接收方（但应当需要流终止？），表现为一个带信号名的凸边矩形</p>
<p>接收事件动作：等待满足特定条件事件的发生，可以没有输入边，能处理<strong>异步调用、信号动作和时间信号</strong>，表现为带名字的凹边矩形</p>
<blockquote>
<p>时间动作是一种接收事件动作</p>
</blockquote>
</blockquote>
</li>
<li><p>调用行为动作中的令牌如何处理？</p>
<blockquote>
<p>在启动过程中消耗所有输入令牌，作为实参值；完成过程中输出<strong>新生成令牌的一个副本</strong></p>
</blockquote>
</li>
<li><p>控制结点的类别、概念、表示及令牌处理规则？</p>
<blockquote>
<p>起始：当活动被调用时执行，表示为实心圆，没有输入边，输出边只能是控制边，生成控制流令牌</p>
<blockquote>
<p>活动不一定都是从起始节点启动，也能从接收动作结点、活动形参结点启动</p>
</blockquote>
<p>分叉：把一个流分成多个并发的流，表示为黑粗横线，有一个入边和多个出边，将到达分叉的令牌对每个出边复制一个</p>
<p>汇合：把多个流进行同步，表示为黑粗直线，有多个入边和一个出边，当每个入边都有令牌到达时，出边才提供令牌，<strong>若其中有对象令牌，则提供对象令牌</strong></p>
<p>判断：在多个输出流的条件进行选择，表现为空心菱形，有一个入边和多个出边，令牌沿一个出边传递</p>
<p>合并：将多个可选的流合并起来，<strong>不能处理并发流</strong>，表示为菱形符号，有多个入边和一个出边，令牌直接从出边传递</p>
<p>活动终止：终止活动中所有的流，但不影响异步调用当前活动的行为，有竞争关系，表示为内部实心的同心圆，入边<strong>只能是控制流</strong>，撤销当前活动中的所有令牌并终止所有动作</p>
<p>流终止：终止一个流，不影响当前活动中其他并行的流，表示为内部为X的圆，销毁到达令牌</p>
</blockquote>
</li>
<li><p>对象结点的含义及本质？</p>
<p>对象节点是一种用于定义对象流的特殊活动节点，本质上是一个实例和一组同类型的实例，表示实例状态如何变化</p>
</li>
<li><p>一个对象结点可以包括哪些内容？其令牌的类型是什么？</p>
<p>可以包括类型、名字、实例集合、上下界、排序属性等内容，只能持有<strong>一个或多个符合对象结点类型</strong>的对象令牌</p>
</li>
<li><p>对象结点的常见类别及其用途、表示？</p>
<blockquote>
<p>一般对象结点：表示为一个矩形框，如果为信号，表示为向右凸的旗形</p>
<p>引脚：描述输入给动作的值或动作输出的结果，表示为在动作矩形边上的小矩形，并可在下方永方括号说明状态，能利用引脚输出表示异常（在边上放三角形）</p>
<blockquote>
<p>以下为特殊对象结点</p>
</blockquote>
<p>活动形参结点：描述活动的形参，使活动与外界能沟通对象流，表示为在活动边缘的对象结点，当流开始时输入或在流结束时输出，可以描述为{stream}，也可表示异常输出（在结点入边及结点上方绘制三角形）</p>
<p>中心缓冲结点：专门在对象节点之间对令牌进行缓冲和传递，可描述竞争和排队规则，不能作为对象的引脚连接到动作，也不能作为活动形参结点连接到活动，用&lt;&lt;centralBuffer&gt;&gt;表示</p>
<p>数据存储结点：持久存储对象的非瞬态信息，保存所有进入的令牌，当特定令牌选定移到下游时就复制该令牌，用&lt;&lt;datastore&gt;&gt;描述</p>
</blockquote>
</li>
<li><p>引脚可以表示的常见行为效果？</p>
<blockquote>
<p>{create}：删除传递来的对象</p>
<p>{delete}：创建对象输出</p>
<p>{read}：读取对象数据</p>
<p>{update}：更新对象内容</p>
</blockquote>
</li>
<li><p>活动边的类型及内容？</p>
<blockquote>
<p>类型：控制流边、对象流（数据流）边</p>
<p>内容：监护条件（结果为真时才进行传递）、权重（通过令牌的最小数目）</p>
<blockquote>
<p>权重使用{weight=?}描述，特殊地，{weight=all/null}表示空权重</p>
</blockquote>
</blockquote>
</li>
<li><p>活动边能否驻留令牌？</p>
<blockquote>
<p>不行</p>
</blockquote>
</li>
<li><p>控制流上的令牌如何变化？</p>
<blockquote>
<p>控制流连接两个控制结点或动作结点，传递控制令牌，把源节点提供的所有控制令牌都传递给目标节点</p>
</blockquote>
</li>
<li><p>对象流用于连接哪些结点？当多个对象流连接同一个源结点时是否竞争同一个对象令牌？</p>
<blockquote>
<p>对象流用于连接一个动作节点和一个对象节点</p>
<p>需要竞争同一个令牌，如果要获得相同令牌，可用分叉节点控制</p>
</blockquote>
</li>
<li><p>除了监护条件、权重，对象流还可以描述什么内容？</p>
<blockquote>
<p>选择：从源结点按一定次序选择令牌进行传递，使用选择行为构造型描述</p>
<p>转换：改变或替换流经的对象令牌，有一个输入形参和输出形参，能从一个对象导航到另一个对象，使用转换行为构造型描述</p>
<p>多点传送或多点接收：连接多个活动结点或把多个活动结点连接到该结点，使用对应构造型描述</p>
</blockquote>
</li>
<li><p>分区（泳道）的用途？</p>
<blockquote>
<p>分区是一种特殊的活动，可对活动的行为表示某种约束或提供某种视图，明确复杂活动中有什么角色或机构负责哪些行为</p>
</blockquote>
</li>
<li><p>可中断活动区间的用途？其所具有的特殊边如何表示？</p>
<blockquote>
<p>用途：能反应终止区间活动、转去处理发生的事件且不回头执行活动的情形，表示为一个虚框圆角矩形</p>
<p>表示：特殊边表示为中断边，连接区间内的源节点和区间外的目标节点，表示为闪电符号</p>
</blockquote>
</li>
<li><p>一个异常处理器包括和关联哪些内容，表现为什么形式？</p>
<blockquote>
<p>包括：可执行结点、异常类型、异常输入（对象结点）</p>
<p>关联：被保护结点</p>
<p>表现：同“闪电”的一条活动边，连接可执行结点</p>
</blockquote>
</li>
<li><p>活动进行中引发异常如何处理？</p>
<blockquote>
<p>包含该动作的结点中的所有令牌全部终结，在此结点上关联的一组异常处理器检查异常类型，若有多个匹配，选择其中之一，异常对象作为令牌置于异常输入结点上，输出值代替源结点作为输出值。若未被捕获，则传播到外层，若为异步调用，丢弃，否则继续传播直至顶层</p>
</blockquote>
</li>
<li><p>结构化活动结点用途？如何表示？包括哪三种结构？</p>
<blockquote>
<p>用途：表示某个动作的概念，能够描述复杂过程的行为，对行为进行结构化建模</p>
<p>表示：虚线圆角矩形框，描述子节点和边，用&lt;&lt;structured&gt;&gt;进行标识</p>
<p>结构：顺序节点、条件节点和循环节点</p>
<blockquote>
<p><em>扩展区间是一种特殊的结构化活动结点</em></p>
</blockquote>
</blockquote>
</li>
<li><p>扩展区间的建模用途？</p>
<blockquote>
<p>用于描述聚集数据的处理而避免使用循环控制</p>
</blockquote>
</li>
<li><p>扩展结点是什么？</p>
<blockquote>
<p>扩展结点表示扩展区间的输入结点和输出结点，输入结点每次只消耗一个令牌，具体执行由该扩展区间的模式定义</p>
<blockquote>
<p>并行：多次执行可并行执行，但不做强制</p>
<p>迭代：缺省模式，按元素次序逐个执行过程</p>
<p>流式：区间一次性执行并将输出进行集聚</p>
</blockquote>
</blockquote>
</li>
<li><p>活动图与状态图的区别？</p>
<blockquote>
<ol>
<li>状态图仅关注一类对象或一个交互的状态变化序列而不关注其它，其它对象通过事件作用于状态机</li>
<li>状态图中结点表示状态，有<strong>时间延续</strong>，活动图动作结点大多是<strong>瞬时执行</strong>的，没有时间延续性，只等待执行完成</li>
<li>状态图<strong>边表示状态转换，瞬时发生</strong>，需要描述事件、条件和行为效果。活动图的边是控制流或者对象流，可描述条件、权重，对象流还可描述选择、转换等</li>
<li>状态图里面没有对象结点，而活动图有，也能表示控制流驱动对象状态变化的规律</li>
</ol>
</blockquote>
</li>
<li><p>活动图与交互图的关系？</p>
<blockquote>
<p>两者都能描述一个用例或一个操作如何实现，都能描述条件、循环、并发执行，都能描述行为主体；序列图用生命线表示，活动图用分区表示；序列图描述消息交换比动作节点中的字符串描述更加详细，也融合了活动图中的动作描述；</p>
<p>活动图关注控制流和对象流，序列图关注消息流</p>
</blockquote>
</li>
</ol>
<h1 id="第九章、构件与构件图"><a href="#第九章、构件与构件图" class="headerlink" title="第九章、构件与构件图"></a>第九章、构件与构件图</h1><ol>
<li><p>构件是什么，是如何定义、如何实现、如何使用的？</p>
<blockquote>
<p>概念：构件是一种特殊的结构化类，是一种模块单位</p>
<p>定义：构建是基于<strong>接口定义</strong>的，需要确定供口的需口</p>
<p>实现：其内部实现是<strong>自包含</strong>的，封装一组类元的状态和行为，实现细节被隐藏</p>
<p>使用：其使用是<strong>可替换</strong>的，在运行过程中也是如此</p>
<blockquote>
<p>因此，构件也具有封装性、继承性和多态性，额外的，构建强调重用性，其重用性由上述性质定义</p>
</blockquote>
</blockquote>
</li>
<li><p>构件的视图有哪些，分别表示什么？</p>
<blockquote>
<p>外部视图（黑盒视图）：主要观察其公共性质的操作</p>
<p>内部视图（白盒视图）：主要观察期内部私有性质和实现类元</p>
</blockquote>
</li>
<li><p>构件之间具有什么关系？</p>
<blockquote>
<p>构件具有类之间的所有关系，且主要有<u>包含、依赖</u>两种关系</p>
</blockquote>
</li>
<li><p>连接器的种类、内涵及其连接成分？</p>
<blockquote>
<p>委托连接器：将构件的外部约定连接到内部行为实现，表示信号的转接，表示委托的语义，在供口、端口和供口，需口、端口和需口之间连接</p>
<p>装配连接器：连接服务和服务的请求，在供口和需口之间连接</p>
</blockquote>
</li>
</ol>
<h1 id="第十章、制品、结点和部署图"><a href="#第十章、制品、结点和部署图" class="headerlink" title="第十章、制品、结点和部署图"></a>第十章、制品、结点和部署图</h1><ol>
<li><p>制品的概念及建模对象？</p>
<blockquote>
<p>制品反映了类、构件等逻辑元素的物理存在形式，表示具体的物理性元素，对文件进行建模</p>
<blockquote>
<p>一个构件可能承载多个制品</p>
</blockquote>
</blockquote>
</li>
<li><p>制品的常见种类（构造型）？</p>
<blockquote>
<p>&lt;&lt;file&gt;&gt;：系统的一般性文件</p>
<p>&lt;&lt;document&gt;&gt;：一般性文档</p>
<p>&lt;&lt;source&gt;&gt;：源文件，经编译可变成可执行文件</p>
<p>&lt;&lt;executable&gt;&gt;：可执行文件</p>
<p>&lt;&lt;library&gt;&gt;：静态或动态的库文件</p>
<p>&lt;&lt;script&gt;&gt;：脚本文件</p>
</blockquote>
</li>
<li><p>制品与承载元素之间的关系？制品与制品的关系？</p>
<blockquote>
<p>制品与承载元素：承载关系，引制品向元素的虚线实心箭头，标注&lt;&lt;manifest&gt;&gt;依赖</p>
<p>制品与制品：泛化、依赖、关联，重定义等，主要是包含和依赖关系</p>
</blockquote>
</li>
<li><p>结点的概念和表示？</p>
<blockquote>
<p>概念：结点表示计算资源，可部署运行软件制品，定义网络结构</p>
<p>表示：一个立方体</p>
</blockquote>
</li>
<li><p>结点之间的关系？</p>
<blockquote>
<p>结点是特殊的结构化类，所以类之间的关系结点都具有，主要是关联关系</p>
</blockquote>
</li>
<li><p>结点的常见具体形式？</p>
<blockquote>
<p>设备：物理性的计算资源，使用设备构造型表示</p>
<p>执行环境：为特定种类的构建提供运行环境，使用执行环境构造型表示，可表示于设备内部</p>
</blockquote>
</li>
<li><p>部署关系的概念，连接对象及其表示？</p>
<blockquote>
<p>概念：表示一件制品或制品实例被定位到一个部署目标上</p>
<p>对象：制品及部署目标，通常是结点</p>
<p>表示：使用部署构造型，从构件指向结点，也可以直接将制品放在结点内，或在结点上标注制品名</p>
</blockquote>
</li>
<li><p>部署规范的概念的用途？</p>
<blockquote>
<p>概念：一种具有确定部署在特定结点上特定制品执行参量性质的特殊制品</p>
<p>用途：配置制品的执行环境，提供通用的参量化机制</p>
</blockquote>
</li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ol>
<li><p>常见构造型有哪些？（不全）</p>
<blockquote>
<p>&lt;&lt;interface&gt;&gt;：接口</p>
<p>&lt;&lt;primitive&gt;&gt;：基本类型</p>
<p>&lt;&lt;enumeration&gt;&gt;：枚举类型</p>
<p>&lt;&lt;stereotype&gt;&gt;：构造型</p>
<p>&lt;&lt;centralBuffer&gt;&gt;：中心缓冲结点</p>
<p>&lt;&lt;datastore&gt;&gt;：数据存储结点</p>
<p>&lt;&lt;selection&gt;&gt;：选择行为</p>
<p>&lt;&lt;transformation&gt;&gt;：转换行为</p>
<p>&lt;&lt;multicast&gt;&gt;：多点传送</p>
<p>&lt;&lt;multireceive&gt;&gt;：多点接收</p>
<p>&lt;&lt;structured&gt;&gt;：结构化结点</p>
<p>&lt;&lt;component&gt;&gt;：构件</p>
<p>&lt;&lt;device&gt;&gt;：设备</p>
<p>&lt;&lt;executionEnvironment&gt;&gt;：执行环境</p>
<p>&lt;&lt;deploy&gt;&gt;：部署</p>
<p>&lt;&lt;deployment spec&gt;&gt;：部署规范</p>
</blockquote>
</li>
<li><p>常见的类元有哪些？（不全）</p>
<blockquote>
<p>类、接口、用例、参与者、关联、制品、结点</p>
</blockquote>
</li>
<li><p>各图的建模对象？</p>
<blockquote>
<p>用例图描述系统的功能需求，对需求进行建模</p>
<p>对象图描述业务对象和实例场景</p>
<p>类图描述类、接口及期间关系，可概念、协作、数据库模式建模</p>
<p>交互图（序列图、通信图、计时图、交互纵览图）描述系统的行为，主要对系统对象间的交互进行建模</p>
<p>状态图描述各种状态，主要对对象的状态进行建模</p>
<p>活动图描述活动和动作间的流，关系序列和条件，不关心行为分属的类，主要对控制流和对象流建模</p>
<p>构件图描述一组构件及相互的关系</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>软件建模</tag>
      </tags>
  </entry>
  <entry>
    <title>组成原理</title>
    <url>/2021/09/18/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h1><span id="more"></span>

<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><h2 id="定点除法"><a href="#定点除法" class="headerlink" title="定点除法"></a>定点除法</h2><p>对定点小数要求： |被除数|＜|除数|</p>
<p>对定点整数要求： |被除数|＞|除数|</p>
<h3 id="原码恢复余数法"><a href="#原码恢复余数法" class="headerlink" title="原码恢复余数法"></a>原码恢复余数法</h3><p>①判溢出，要求|被除数|＜|除数|；</p>
<p>②符号位单独按两数符号的模2相加求得（异或）</p>
<p>③被除数减去除数；</p>
<p><strong>④若所得余数为正，表示够减，相应位上商为1， 余数左移一位(相当于除数右移)减去除数；若所 得余数为负，表示不够减，相应位上商为0，余 数加上除数(恢复余数)，再左移一位减去除数；</strong></p>
<p>⑤重复第④步，直到求得所要求的商的各位为止</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><a href="https://imgtu.com/i/41T5uV"><img src="https://z3.ax1x.com/2021/09/19/41T5uV.png" alt="41T5uV.png"></a></p>
<p><a href="https://imgtu.com/i/41ToHU"><img src="https://z3.ax1x.com/2021/09/19/41ToHU.png" alt="41ToHU.png"></a><img src="C:\Users\daili\AppData\Roaming\Typora\typora-user-images\image-20210919081328258.png" alt="image-20210919081328258"></p>
<h3 id="原码不恢复余数法（加减交替法）"><a href="#原码不恢复余数法（加减交替法）" class="headerlink" title="原码不恢复余数法（加减交替法）"></a>原码不恢复余数法（加减交替法）</h3><p>① 判溢出，比较被除数和除数。若在定点小数运 算时，|被除数|＞|除数|，则除法将发生溢出， 不能进行除法运算。</p>
<p>② 符号位单独处理，商的符号由被除数和除数符 号的异或运算求得。</p>
<p>③ 用被除数和除数的数值部分进行运算，被除数 减去除数。</p>
<p><strong>④ 若所得余数为正，表示够减，相应位上商为1， 将余数左移一位后，减去除数； 若所得余数为负，表示不够减，相应位上商为0， 将余数左移一位后，加上除数。</strong></p>
<p>⑤ 重复第④步，直到求得所要求的商的各位 为止。如果最后一次所得余数仍为负，则需再 做一次加除数的操作，以得到正确的余数。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><a href="https://imgtu.com/i/417JK0"><img src="https://z3.ax1x.com/2021/09/19/417JK0.png" alt="417JK0.png"></a></p>
<p><a href="https://imgtu.com/i/417aaF"><img src="https://z3.ax1x.com/2021/09/19/417aaF.png" alt="417aaF.png"></a></p>
<p><a href="https://imgtu.com/i/4170PJ"><img src="https://z3.ax1x.com/2021/09/19/4170PJ.png" alt="4170PJ.png"></a></p>
<hr>
<h3 id="原码不恢复余数法（整数）"><a href="#原码不恢复余数法（整数）" class="headerlink" title="原码不恢复余数法（整数）"></a>原码不恢复余数法（整数）</h3><p>因为2n位被除数除以n位除数，可以得到n位的商。 在整数除法中，为了得到n位整数商，被除数位 数的长度应该是除数位数长度的两倍，并且为了 使商不超过n位，要求被除数的<strong>高n位比除数（n 位）小</strong>，否则商将超过n位，即运算结果<strong>溢出</strong>。</p>
<p>如果被除数和除数的位数都为n位，则应在被除 数前面加上n个0，使被除数的长度扩展为2n后再 进行运算。</p>
<p>在小数除法中，也可以使被除数位数的长度为除 数位数长度的两倍。 </p>
<p>在字长为n的计算机中，称被除数采用双字长、 除数采用单字长的除法为<strong>双精度除法</strong>。相应地称 被除数和除数均采用单字长的除法为<strong>单精度除法。</strong></p>
<p><a href="https://imgtu.com/i/417hPH"><img src="https://z3.ax1x.com/2021/09/19/417hPH.png" alt="417hPH.png"></a></p>
<p><a href="https://imgtu.com/i/417qZ8"><img src="https://z3.ax1x.com/2021/09/19/417qZ8.png" alt="417qZ8.png"></a></p>
<p><a href="https://imgtu.com/i/417jiQ"><img src="https://z3.ax1x.com/2021/09/19/417jiQ.png" alt="417jiQ.png"></a></p>
<p><img src="C:\Users\daili\AppData\Roaming\Typora\typora-user-images\image-20210919083757579.png" alt="image-20210919083757579"></p>
<p>A寄存器：存放被除数和余数，最终结果是余数。</p>
<p>B寄存器：存放除数。</p>
<p>C寄存器：存放被除数和商，最终结果是商。</p>
<p>运算过程中寄存器A、C联合左移。  商的符号Cf：Cf＝Af⊕Bf </p>
<p>运算过程中用Ff控制上商。</p>
<p>Ff＝0，说明余数r≥0，商1，作－B操作， 即 B＋1。 </p>
<p>Ff＝1，说明余数r＜0，商0，作＋B操作。</p>
<p> 在实现定点小数和定点整数除法时，寄存器的分配使用略有不同。</p>
<h2 id="补码除法运算"><a href="#补码除法运算" class="headerlink" title="补码除法运算"></a>补码除法运算</h2><p>在补码除法运算中，参加运算的数均为补 码数，所得商也是补码形式，符号位参加 运算。</p>
<h3 id="补码不恢复余数除法"><a href="#补码不恢复余数除法" class="headerlink" title="补码不恢复余数除法"></a>补码不恢复余数除法</h3><p>进行补码除法运算应考虑的几个问题。</p>
<p>比较规则 —— 如何判别是否够减 </p>
<p>由于上商是根据比较被除数(或余数)与除 数的绝对值的大小确定的，所以需要解决 如何比较两个补码数的绝对值的大小，也 就是如何判别是否够减的问题。</p>
<h4 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h4><p>当x与y同号时，作[x]补－[y]补进行比较</p>
<p>若所得余数与除数同号，表示够减</p>
<p>若所得余数与除数异号，表示不够减</p>
<h4 id="上商算法"><a href="#上商算法" class="headerlink" title="上商算法"></a>上商算法</h4><p>由于是补码运算，所以：</p>
<p>当x与y同号时，商为正，够减时上商为1，不够减时上商为0</p>
<p>当x与y异号时，商为负，够减时上商为0，不够减时上商为1 </p>
<p> • 上商算法</p>
<p> • 每次加减所得的余数与除数同号时，上商为1</p>
<p> • 每次加减所得的余数与除数异号时，上商为0</p>
<h4 id="商的符号"><a href="#商的符号" class="headerlink" title="商的符号"></a>商的符号</h4><p>若x与y同号，商为正。</p>
<p> 第一次运算时作 [x]补－[y]补，因为除法要求 |x|＜|y|，所以所得余数R0必不够减，即R0与 [y]补异号，应上商为0，就是正商的符号“0” 。 </p>
<p>若x与y异号，商为负。</p>
<p>第一次运算时作 [x]补＋[y]补，因为除法要求 |x|＜|y|，所以所得余数R0必不够减，即R0与 [y]补同号，应上商为1，就是负商的符号“1” 。</p>
<p>① 当被除数[x]补与除数[y]补<strong>同号</strong>时，如果余数[r]补与[y]补<strong>同号</strong>，且上商为“<strong>1</strong>” ，则表示商溢出。 </p>
<p>② 当被除数[x]补与除数[y]补<strong>异号</strong>时，如果余数[r]补与[y]补<strong>异号</strong>，且上商为“<strong>0</strong>” ，则表示商溢出。</p>
<h4 id="求新余数算法"><a href="#求新余数算法" class="headerlink" title="求新余数算法"></a>求新余数算法</h4><p>每次加减所得的余数与除数同号时，将余数左 移一位，减去除数。</p>
<p>每次加减所得的余数与除数异号时，将余数左 移一位，加上除数。</p>
<h4 id="商的校正"><a href="#商的校正" class="headerlink" title="商的校正"></a>商的校正</h4><h5 id="末尾恒置1"><a href="#末尾恒置1" class="headerlink" title="末尾恒置1"></a>末尾恒置1</h5><h5 id="校正法"><a href="#校正法" class="headerlink" title="校正法"></a>校正法</h5><p>① 若在所要求的位数内<strong>能够除尽</strong>，则除数<strong>y</strong>为正时，商不必校正；y为负时，商加$2^{-n}$校正。</p>
<p>② 若在所要求的位数内<strong>不能除尽</strong>，则<strong>商</strong>为正时，不必校正；商为负时，则商加$2^{-n}$校正。</p>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p><a href="https://imgtu.com/i/41LFdf"><img src="https://z3.ax1x.com/2021/09/19/41LFdf.png" alt="41LFdf.png"></a></p>
<p><a href="https://imgtu.com/i/41LVJg"><img src="https://z3.ax1x.com/2021/09/19/41LVJg.png" alt="41LVJg.png"></a></p>
<p><a href="https://imgtu.com/i/4yNO9H"><img src="https://z3.ax1x.com/2021/09/26/4yNO9H.png" alt="4yNO9H.png"></a></p>
<h3 id="布斯除法"><a href="#布斯除法" class="headerlink" title="布斯除法"></a>布斯除法</h3><p>① 余数(初始为被除数)与除数同号，上商为1， 余数左移一位，减去除数；</p>
<p>​    余数(初始为被除数)与除数异号，上商为0， 余数左移一位，加上除数；</p>
<p>② 重复上述步骤，直到求得所需位数为止；</p>
<p>③ 将<strong>商符变反</strong>，若采用校正法，则对商校正。</p>
<p><a href="https://imgtu.com/i/4yUPUS"><img src="https://z3.ax1x.com/2021/09/26/4yUPUS.png" alt="4yUPUS.png"></a></p>
<p><a href="https://imgtu.com/i/4yUkCQ"><img src="https://z3.ax1x.com/2021/09/26/4yUkCQ.png" alt="4yUkCQ.png"></a></p>
<p><a href="https://imgtu.com/i/4yUVvn"><img src="https://z3.ax1x.com/2021/09/26/4yUVvn.png" alt="4yUVvn.png"></a></p>
<h2 id="浮点数四则运算"><a href="#浮点数四则运算" class="headerlink" title="浮点数四则运算"></a>浮点数四则运算</h2><h2 id="两个浮点数加减运算的步骤"><a href="#两个浮点数加减运算的步骤" class="headerlink" title="两个浮点数加减运算的步骤"></a>两个浮点数加减运算的步骤</h2><h3 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h3><p>把两数的小数点对齐，称为对阶。</p>
<p>两个浮点数的加减运算，首先必须对阶。 对阶的标志是使两数阶码相等。</p>
<p>对阶时，首先应求出两数阶码之差，即：</p>
<p>对阶的基本方法是：<strong>小阶向大阶看齐。</strong></p>
<h3 id="尾数求和"><a href="#尾数求和" class="headerlink" title="尾数求和"></a>尾数求和</h3><p>若求和，则将两数尾数直接相加。</p>
<p>若求差，则将对阶后的减数的尾数变补与被减 数的尾数相加。</p>
<h3 id="结果规格化"><a href="#结果规格化" class="headerlink" title="结果规格化"></a>结果规格化</h3><p>向左破坏规格化：尾数发生溢出。</p>
<p>向右破坏规格化：尾数未溢出，但不满足规格化 条件。</p>
<p>设浮点数尾数[S]原＝Sf.S1S2…Sn</p>
<p>如果尾数发生溢出，则为向左破坏规格化；</p>
<p>如果尾数未溢出，但S1＝0，则为向右破坏规格化。</p>
<p>设浮点数尾数[S]补＝Sf.S1S2…Sn</p>
<p>如果尾数发生溢出，则称为向左破坏规格化；</p>
<p>如尾数未溢出，但Sf⊕S1＝0，即Sf与S1相同，则为向右破坏规格化。</p>
<p><strong>在浮点运算中，通过规格化处理，溢出将不会 影响正确的运算。</strong></p>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>为减少对阶和向右规格化时，因尾数右移而造 成的误差，可进行舍入处理（即找到可以表示 的最接近的值）。</p>
<p>舍入的原则：<br>⑴ 误差不超过所允许的范围，一般要求不超 过最低位的1。<br>⑵ 误差应有正有负，不会产生积累误差。</p>
<h4 id="截断法"><a href="#截断法" class="headerlink" title="截断法"></a>截断法</h4><p>将丢掉的部分一律舍去，保留的部分不作任何 改变。<br>这种方法简单，但精度较低。<br>趋近0</p>
<h4 id="0舍1入法"><a href="#0舍1入法" class="headerlink" title="0舍1入法"></a>0舍1入法</h4><p>若右移时被丢掉数位的最高位为0，则舍去；<br>若右移时被丢掉数位的最高位为1，则将1加到 尾数的最低位。<br>这种方法精度较高，但在加1时，会产生进位， 使运算速度减慢。而且可能造成尾数溢出，需要再次右规。<br>趋近+∞ 或−∞  </p>
<h4 id="末位恒置1"><a href="#末位恒置1" class="headerlink" title="末位恒置1"></a>末位恒置1</h4><p>末位恒置1法也称冯·诺依曼舍入法。<br>尾数右移时，无论被丢掉的数位的最高位为0  还是为1，都将保留的尾数的最低位恒置为1。<br>优点：舍入处理不用做加法运算，方法简单、 速度快且不会有再次右规的可能，并且没有积 累误差，是常用的舍入方法。<br>趋近于+∞ 或−∞<br>缺点：可能会有较大的积累误差。因为从绝对 值来看，每次舍入都可能是增加的 </p>
<h4 id="查表舍入法"><a href="#查表舍入法" class="headerlink" title="查表舍入法"></a>查表舍入法</h4><p>根据尾数的低K位的代码值及被丢掉数位的最 高位值，按一定舍入规则，编制成舍入表，并 存入只读存储器。<br>当需要舍入操作时，以尾数低K位及被丢掉数 位的最高位作为ROM地址，通过查舍入表，得 到舍入后尾数低K位值。<br>实现一种舍入函数</p>
<h3 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h3><p><strong>浮点数溢出与否是由阶码的符号决定的</strong></p>
<p>为便于判断移码加/减运算的溢出情况，可采 用双符号位进行运算。<br>设移码的双符号位为sf1sf2，并规定初始时，  移码的一个符号位sf1恒为0，并参加运算</p>
<p>若运算结果的sf1为1，表示溢出。<br> sf1sf2＝10，结果上溢<br> sf1sf2＝11，结果下溢<br>若运算结果的sf1为0，表示无溢出。<br> sf1sf2＝00，结果为负<br> sf1sf2＝01，结果为正</p>
<h2 id="尾数运算"><a href="#尾数运算" class="headerlink" title="尾数运算"></a>尾数运算</h2><h3 id="浮点乘法尾数运算"><a href="#浮点乘法尾数运算" class="headerlink" title="浮点乘法尾数运算"></a>浮点乘法尾数运算</h3><p>在浮点乘法运算中，乘积的尾数是相乘的两个 浮点数的尾数之积，并按定点小数的乘法规则 进行运算。<br>浮点乘法尾数运算的运算步骤：</p>
<h4 id="检测被乘数和乘数的尾数是否为0"><a href="#检测被乘数和乘数的尾数是否为0" class="headerlink" title="检测被乘数和乘数的尾数是否为0"></a>检测被乘数和乘数的尾数是否为0</h4><p>若有一 个为0，则乘积必然为0，不需再进行计算。只 有当两数皆不为0时，方可进行运算。 </p>
<h4 id="被乘数和乘数的尾数相乘"><a href="#被乘数和乘数的尾数相乘" class="headerlink" title="被乘数和乘数的尾数相乘"></a>被乘数和乘数的尾数相乘</h4><p>根据尾数采用的是原码表示还是补码表示，可采用任意一种相应的定点小数乘法完成运算。</p>
<h4 id="运算结果规格化"><a href="#运算结果规格化" class="headerlink" title="运算结果规格化"></a>运算结果规格化</h4><p>如果尾数采用补码表示，由于－1是规格化数，  而当两尾数均为－1时，由于(－1)×(－1)＝1， 因此需要对运算结果进行一次右规，如果在右规调整阶码时，出现阶码上溢，则表示浮点数上溢， 应转入溢出中断处理。 </p>
<h4 id="舍入处理"><a href="#舍入处理" class="headerlink" title="舍入处理"></a>舍入处理</h4><p>两个n位（除符号位外）尾数相乘，乘积为2n位。 如果只需要取乘积的高n位，则需要对乘法运算  结果进行舍入处理。</p>
<h3 id="浮点除法尾数运算"><a href="#浮点除法尾数运算" class="headerlink" title="浮点除法尾数运算"></a>浮点除法尾数运算</h3><h4 id="检测被除数和除数的尾数是否为0"><a href="#检测被除数和除数的尾数是否为0" class="headerlink" title="检测被除数和除数的尾数是否为0"></a>检测被除数和除数的尾数是否为0</h4><p>若被除 数为0，商必然为0，不需再进行计算；若除数 为0，则商为无穷大，转入除数0中断处理。只 有当两数皆不为0时，方可进行运算。（IEEE754标准可以处理这种情况）  </p>
<h4 id="被除数和除数的尾数相除"><a href="#被除数和除数的尾数相除" class="headerlink" title="被除数和除数的尾数相除"></a>被除数和除数的尾数相除</h4><p>根据尾数采用 的是原码表示还是补码表示，可采用任意一种 相应的定点小数除法完成运算。</p>
<h4 id="运算结果规格化-1"><a href="#运算结果规格化-1" class="headerlink" title="运算结果规格化"></a>运算结果规格化</h4><p>如果商的绝对值小于1/2， 则需对运算结果进行左规。如果在左规调整阶 码时，出现阶码下溢，则应将运算结果作机器 零处理。</p>
<h1 id="控制系统与CPU"><a href="#控制系统与CPU" class="headerlink" title="控制系统与CPU"></a>控制系统与CPU</h1><p>控制器是计算机的指挥和控制中心，由它把计算机的运算器、存储器、I/O设备等联系成一个有机的系统，并根据各部件具体要求，适时地发出各种控制命令，控制计算机各部件自动、协调地进行工作。</p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><h3 id="指令执行基本步骤"><a href="#指令执行基本步骤" class="headerlink" title="指令执行基本步骤"></a>指令执行基本步骤</h3><ol>
<li><p>取指令<br> 根据指令地址（由PC提供），从存储器中取出所要执行的指令。</p>
</li>
<li><p>分析指令</p>
</li>
</ol>
<p>  ① 对取出的指令进行译码分析。确定指令应完成的操作，产生相应操作的控制电位，参与形成该指令功能所需要的<strong>全部控制命令</strong>（<strong>微操作控制信号</strong>）。<br>  ② 根据寻址方式的分析和指令功能要求，形成<strong>操作数的有效地址</strong>，并按此地址取出操作数据（运算型指令）或形成转移地址(转移类指令)，以实现程序转移。</p>
<ol start="3">
<li><p>执行指令</p>
<p>根据指令分析所产生的操作控制信号和形成的有效地址，按一定的算法形成指令<strong>操作控制序列</strong>，控制有关部件完成指令规定的功能。<br>一条指令执行结束，若没有异常情况和特殊请求，则按程序顺序，再去取出并执行下一条指令。</p>
</li>
</ol>
<h3 id="控制器的任务"><a href="#控制器的任务" class="headerlink" title="控制器的任务"></a>控制器的任务</h3><p>按<strong>取指令、分析指令、执行指令</strong>这样的步骤进行周而复始的控制过程，直到完成程序所规定的任务并停机为止。</p>
<h3 id="控制器的基本功能"><a href="#控制器的基本功能" class="headerlink" title="控制器的基本功能"></a>控制器的基本功能</h3><h4 id="控制指令正确执行"><a href="#控制指令正确执行" class="headerlink" title="控制指令正确执行"></a>控制指令正确执行</h4><h5 id="指令流出控制"><a href="#指令流出控制" class="headerlink" title="指令流出控制"></a>指令流出控制</h5><p>(PC)-&gt;MAR,Read</p>
<p>(MDR)-&gt;IR</p>
<p>(PC)+1-&gt;PC</p>
<h5 id="分析指令和执行指令的控制"><a href="#分析指令和执行指令的控制" class="headerlink" title="分析指令和执行指令的控制"></a>分析指令和执行指令的控制</h5><p>IR中的指令经<strong>指令译码器（ID）</strong>译码分析，确定操作性质，判明寻址方式并形成操作数的有效地址。</p>
<p>控制器根据分析结果和形成的有效地址产生相应的<strong>操作控制信号序列</strong>。</p>
<h5 id="指令流向控制"><a href="#指令流向控制" class="headerlink" title="指令流向控制"></a>指令流向控制</h5><p>指令流向控制即下条指令地址的形成控制</p>
<p>① 按指令序列顺序执行时，通过PC自动增量形成下条指令的地址。<br>② 当需要改变指令流向时，需改变程序计数器PC中的内容。</p>
<p>转移指令的执行：把形成的转向地址送入PC；<br>转子指令的执行：把子程序入口地址送入PC；<br>中断处理：将中断服务程序入口地址送入PC。<br>为了正确返回，转子和中断还需保留PC被改变之前的内容(即返回地址)。</p>
<h4 id="控制程序和数据的输入及结果的输出"><a href="#控制程序和数据的输入及结果的输出" class="headerlink" title="控制程序和数据的输入及结果的输出"></a>控制程序和数据的输入及结果的输出</h4><p>为完成某项任务而编制的程序及所需数据，必须通过某些输入设备预先存放在存储器中，运算结果要用输出设备输出。所以<strong>必须由控制器统一指挥</strong>，完成程序和数据的输入及结果的输出。</p>
<h4 id="异常情况和特殊请求处理"><a href="#异常情况和特殊请求处理" class="headerlink" title="异常情况和特殊请求处理"></a>异常情况和特殊请求处理</h4><p>控制器必须具有检测和处理这些异常情况和特殊请求的功能。</p>
<h4 id="指令部件"><a href="#指令部件" class="headerlink" title="指令部件"></a>指令部件</h4><p>PC：</p>
<p><strong>由于PC可以指向主存中任一单元的地址，因此它的位数应能表示主存的最大容量并与主存地址寄存器MAR的位数相同。</strong></p>
<p>IR：</p>
<p>指令寄存器用于存放当前正在执行的指令。<br>当指令从主存取出后，经MDR传送到指令寄存器中，以便实现对一条指令执行的全部过程的控制</p>
<p>ID：</p>
<p>对指令寄存器中的指令<strong>操作码进行译码分析</strong>，产生相应操作的控制电位，提供给微操作控制信号形成部件。<strong>对寻址方式字段进行译码分析</strong></p>
<p>地址形成部件：</p>
<p>根据机器所规定的各种寻址方式，形成操作数有效地址。</p>
<h4 id="时序控制部件"><a href="#时序控制部件" class="headerlink" title="时序控制部件"></a>时序控制部件</h4><p>用于产生一系列时序信号，为各个微操作定时，以保证各个微操作的执行顺序。</p>
<p>微操作：机器最简单的基本操作</p>
<h4 id="微操作控制信号形成部件"><a href="#微操作控制信号形成部件" class="headerlink" title="微操作控制信号形成部件"></a>微操作控制信号形成部件</h4><p>微操作控制信号形成部件：根据指令部件提供的操作控制电位、时序部件所提供的各种时序信号以及有关的状态条件，产生机器所需要的各种微操作控制信号。</p>
<h4 id="中断机构"><a href="#中断机构" class="headerlink" title="中断机构"></a>中断机构</h4><h4 id="程序状态寄存器PSR"><a href="#程序状态寄存器PSR" class="headerlink" title="程序状态寄存器PSR"></a>程序状态寄存器PSR</h4><p>它所存放的内容称为PSW</p>
<h4 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h4><p>实现人机之间的通信联系</p>
<h3 id="控制器的组成方式"><a href="#控制器的组成方式" class="headerlink" title="控制器的组成方式"></a>控制器的组成方式</h3><p>控制器的组成方式主要是指<strong>微操作控制信号形成部件采用何种组成方式产生微操作控制信号</strong></p>
<p>组合、存储、结合（PLA）</p>
<h2 id="控制器的控制方式与时序系统"><a href="#控制器的控制方式与时序系统" class="headerlink" title="控制器的控制方式与时序系统"></a>控制器的控制方式与时序系统</h2><p><strong>如何在时间上对各种微操作信号加以控制</strong>。</p>
<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p>任何指令的运行或指令中各个微操作的执行，均由确定的<strong>具有统一基准时标的时序信号所控制</strong>。</p>
<p>典型的同步控制方式：<br><strong>以微操作序列最长的指令和执行时间最长的微操作为标准</strong>，</p>
<h4 id="1-采用中央控制与局部控制相结合的方法"><a href="#1-采用中央控制与局部控制相结合的方法" class="headerlink" title="(1) 采用中央控制与局部控制相结合的方法"></a>(1) 采用中央控制与局部控制相结合的方法</h4><p><strong>中央控制</strong>：统一节拍的控制<br>根据大多数指令的微操作序列的情况，设置一个统一的节拍数，使之大多数指令均能在统一的节拍内完成。</p>
<p><strong>局部控制</strong>：在延长节拍内的控制<br>对于少数在统一节拍内不能完成的指令，采用延长节拍或增加节拍数，使之在延长节拍内完成，执行完毕再返回中央控制。</p>
<h4 id="2-采用不同的机器周期和延长节拍的方法"><a href="#2-采用不同的机器周期和延长节拍的方法" class="headerlink" title="(2) 采用不同的机器周期和延长节拍的方法"></a>(2) 采用不同的机器周期和延长节拍的方法</h4><p><strong>把一条指令执行过程划分为若干机器周期</strong>，如取指、取数、执行等周期。根据所执行指令的不同需要，选取不同的机器周期数。在节拍安排上，<strong>每个周期划分为固定的节拍，每个节拍都可根据需要延长一个节拍</strong>。</p>
<h4 id="3-采用分散节拍的方法"><a href="#3-采用分散节拍的方法" class="headerlink" title="(3) 采用分散节拍的方法"></a>(3) 采用分散节拍的方法</h4><p><strong>分散节拍：运行不同指令时，需要多少节拍，时序部件就发生多少节拍。</strong><br>这种方法可完全避免节拍轮空，是提高指令运行速度的有效方法，但这种方法使时序部件复杂化。同时还不能解决节拍内那些简单的微操作因等待所浪费的时间。</p>
<h3 id="异步控制"><a href="#异步控制" class="headerlink" title="异步控制"></a>异步控制</h3><p>没有统一的同步信号，<strong>采用问答方式进行时序协调</strong>，将前一操作的回答信号作为下一操作的启动信号。<br>异步控制方式不仅要区分不同指令对应的微操作序列的长短，而且要区分其中每个微操作的繁简，每条指令、每个微操作需要多少时间就占用多少时间。</p>
<p><a href="https://imgtu.com/i/ooUfL6"><img src="https://s1.ax1x.com/2021/12/10/ooUfL6.png" alt="ooUfL6.png"></a></p>
<h3 id="联合控制"><a href="#联合控制" class="headerlink" title="联合控制"></a>联合控制</h3><p>联合控制是将同步控制和异步控制相结合。</p>
<p>在功能部件内部采用同步方式或以同步方式为主的控制方式<br>在功能部件之间采用异步方式<br>通常对可以统一的微操作采用同步控制，对难以统一的微操作采用异步控制。</p>
<h3 id="同步异步时序的衔接关系"><a href="#同步异步时序的衔接关系" class="headerlink" title="同步异步时序的衔接关系"></a>同步异步时序的衔接关系</h3><p>当CPU要访问主存时，在发读信号READ同时发<strong>“等待”信号</strong>，等待信号使时序由同步转异步操作，并<strong>冻结同步时序</strong>，使节拍间的相位关系不再发生变化，直到存储器按自己速度操作结束，并向CPU发回答信号MOC才<strong>解除对同步时序的冻结</strong>，机器回到同步时序按原时序关系继续运行。</p>
<h2 id="时序系统"><a href="#时序系统" class="headerlink" title="时序系统"></a>时序系统</h2><p>时序系统是控制器的心脏，由它为指令的执行提供各种定时信号。通常，<strong>设计时序系统主要是针对同步控制方式的。</strong></p>
<h3 id="指令周期与机器周期"><a href="#指令周期与机器周期" class="headerlink" title="指令周期与机器周期"></a>指令周期与机器周期</h3><p><strong>指令周期</strong>：从取指令、分析指令到执行完一条指令所需的全部时间。</p>
<p><strong>机器周期（CPU周期）</strong>：指令周期中的某一工作阶段所需的时间。在指令执行过程中，各机器周期相对独立。</p>
<p><strong>一般机器的CPU周期有取指周期、取数周期、执行周期，中断周期等。</strong></p>
<p><strong>节拍</strong></p>
<p>把<strong>一个机器周期等分成若干个时间区间</strong>，每一时间区间称为一个节拍。<br>一个节拍对应一个电位信号，<strong>控制一个或几个微操作的执行</strong>。</p>
<p><strong>一个节拍电位信号的宽度取决于CPU完成一个基本操作的时间。</strong> </p>
<p><strong>脉冲：一个节拍内设置的一个或几个工作脉冲。</strong></p>
<p>常见的设计是在<strong>每个节拍的末尾发一次工作脉冲</strong>，<strong>脉冲前沿可用来打入运算结果（或传送），脉冲后沿则实现周期的切换。</strong></p>
<p>外频：超频超的就是这个，主板上石英晶体振荡器，基准时钟频率<br>内存频率：依赖于外频，DDR，DDR2<br>前端总线FSB：CPU与北桥之间的传输速度，QDR（Quad Date Rate）技术（4倍并发）<br>双通道内存：在北桥芯片有两个内存控制器<br>主频：外频*倍频<br>倍频：一般主板锁定<br>南桥芯片和北桥芯片：前者接口，如声卡等；后者内存、显卡等</p>
<h2 id="CPU总体结构"><a href="#CPU总体结构" class="headerlink" title="CPU总体结构"></a>CPU总体结构</h2><p>CPU即中央处理器，它包含运算器和控制器两个部分。其功能为：<br>⑴ <strong>程序控制</strong>：标准程序按所要求的次序正确执行。<br>⑵ <strong>操作控制</strong>：管理何产生每条指令所需的操作信号，送往有关部件，控制完成指令规定的操作。<br>⑶ <strong>时序控制</strong>：对各种操作实施时间上的定时，使计算机有条不紊地工作。<br>⑷ <strong>数据加工</strong>：对数据进行算逻运算处理。</p>
<h3 id="寄存器的设置"><a href="#寄存器的设置" class="headerlink" title="寄存器的设置"></a>寄存器的设置</h3><p>不同计算机的CPU结构存在差别，但在CPU中一般都设置下列寄存器：<br>(1)指令寄存器 IR<br>(2)程序计数器 PC<br>(3)累加寄存器 AC<br>(4)程序状态寄存器 PSR<br>(5)地址寄存器 MAR<br>(6)数据缓冲寄存器 MDR(或MBR)</p>
<h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><p>在CPU内部，数据通路通常是指运算器与寄存器之间的信息传输通道。（总线）</p>
<p>单总线</p>
<p><a href="https://imgtu.com/i/oofTDU"><img src="https://s1.ax1x.com/2021/12/11/oofTDU.png" alt="oofTDU.png"></a></p>
<p>双总线</p>
<p><a href="https://imgtu.com/i/oof4g0"><img src="https://s1.ax1x.com/2021/12/11/oof4g0.png" alt="oof4g0.png"></a></p>
<h3 id="指令流程分析"><a href="#指令流程分析" class="headerlink" title="指令流程分析"></a>指令流程分析</h3><p>指令流程：指令的操作过程。</p>
<p>影响指令流程的因素：<br><strong>指令功能</strong><br><strong>寻址方式</strong><br><strong>数据通路</strong><br><strong>ALU的功能</strong><br><strong>指令执行的基本步骤等。</strong></p>
<p>例：指令</p>
<p>ADD (R1),R0</p>
<p>(PC)-&gt;MAR,Read,(PC)+1-&gt;Z</p>
<p>(Z)-&gt;PC</p>
<p>(M-&gt;MDR)-&gt;IR</p>
<p>(R1)-&gt;MAR,Read</p>
<p>(M-&gt;MDR)-&gt;Y</p>
<p>(Y)+(R0)-&gt;Z</p>
<p>(Z)-&gt;R0</p>
<h2 id="模型机的总体结构"><a href="#模型机的总体结构" class="headerlink" title="模型机的总体结构"></a>模型机的总体结构</h2><p><a href="https://imgtu.com/i/oTnDDs"><img src="https://s1.ax1x.com/2021/12/11/oTnDDs.png" alt="oTnDDs.png"></a></p>
<h3 id="模型机数据通路结构"><a href="#模型机数据通路结构" class="headerlink" title="模型机数据通路结构"></a>模型机数据通路结构</h3><p>字长：16位<br>① 内部总线：双总线结构<br>BUS1：输入总线， BUS2：输出总线<br>○：输出控制门信号，如MDR→BUS1<br>CP：输入控制信号，如CPY<br>② 系统总线：<br>地址总线：ABUS，数据总线：DBUS<br>I/O与主存共享总线，用 MREQ 控制访存；用IOREQ 控制访问I/O，<br>R/W=1，读， R/W=0，写</p>
<h3 id="模型机的ALU的功能"><a href="#模型机的ALU的功能" class="headerlink" title="模型机的ALU的功能"></a>模型机的ALU的功能</h3><p>由SN74181构成，在控制信号S3～S0及M、C0的控制下，可完成16种逻辑运算和16种算术运算。<br>M＝0：算术运算  M＝1：逻辑运算 </p>
<p><a href="https://imgtu.com/i/oTK9OJ"><img src="https://s1.ax1x.com/2021/12/11/oTK9OJ.png" alt="oTK9OJ.png"></a></p>
<h2 id="微程序控制器原理"><a href="#微程序控制器原理" class="headerlink" title="微程序控制器原理"></a>微程序控制器原理</h2><p>微程序设计的实质<br>用程序设计的思想方法来组织操作控制逻辑，用规整的存储逻辑代替繁杂的组合逻辑。 </p>
<p><strong>相容</strong><br>指在同时或同一个CPU时钟单位（周期）内并行执行的微操作。<br><strong>不相容</strong>（互斥）<br>指不能同时或不能在同一个CPU时钟周期内并行执行的微操作。</p>
<h3 id="常用的微指令编译方法"><a href="#常用的微指令编译方法" class="headerlink" title="常用的微指令编译方法"></a>常用的微指令编译方法</h3><p><strong>直接控制法</strong>（不译法）<br>微指令操作控制字段的每一位都直接表示一个微命令，该位为“1”，表示执行这个微命令，为“0”表示不执行该微命令。由于这种方法不需译码，所以也称不译法。</p>
<p><strong>字段直接编码法</strong></p>
<p>将微指令操作控制字段划分为若干个子字段，每个子字段的所有微命令进行统一编码。因此在这种方法中，不同的子字段的不同编码，表示不同的微命令。</p>
<p><strong>子字段的划分原则</strong></p>
<p>① <strong>把互斥的微命令（即不允许同时出现的微命令）划分在同一字段内</strong>，相容的微命令（即允许同时出现的微命令）划分在不同字段内。<br>例：各Ri→BUS1是互斥的，可以划分在同一字段；RS→BUS1和CPRS是相容的，应划分在不同字段。<br>② 字段的划分应<strong>与数据通路结构相适应</strong>。<br>③ 一般每个子字段应<strong>留出一个状态</strong>，表示本字段不发任何微命令。<br>④ 每个子字段所定义的微命令数不宜太多，否则将使微命令译码复杂。</p>
<p><a href="https://imgtu.com/i/oHARvd"><img src="https://s4.ax1x.com/2021/12/11/oHARvd.png" alt="oHARvd.png"></a></p>
<p><a href="https://imgtu.com/i/oHAHPS"><img src="https://s4.ax1x.com/2021/12/11/oHAHPS.png" alt="oHAHPS.png"></a></p>
<h3 id="微程序的顺序控制方式"><a href="#微程序的顺序控制方式" class="headerlink" title="微程序的顺序控制方式"></a>微程序的顺序控制方式</h3><p>微程序的初始微地址（微程序的入口地址）：指令所对应微程序的第一条微指令所在控制存储器单元的地址。<br>现行微指令：执行微程序过程中，当前正在执行的微指令。<br>现行微地址：现行微指令所在控制存储器单元的地址。<br>后继微指令：现行微指令执行完毕后，下一条要执行的微指令。<br>后继微地址：后继微指令所在控存单元的地址。</p>
<p>1．初始微地址的形成</p>
<p>“取指令”微程序（通常由一条或几条微指令组成）是公用的，一般安排在从0号控存单元或其它特定的控存单元开始。</p>
<p>(1) 一级功能转移</p>
<p>根据指令操作码，直接转移到相应微程序的入口，即指令操作码直接参与形成微程序的入口地址。</p>
<p>(2) 二级功能转移</p>
<p>先按指令类型标志转移，以区分出是哪一类指令。规定每类指令中位置和位数是固定的，在第二级按操作码区分出具体是哪条指令，转移到相应微程序入口。</p>
<p>2．后继微地址的形成</p>
<p>找到初始微地址后，开始执行相应的微程序。每条微指令执行完毕，都要根据要求形成后继微地址，以保证微程序的正常执行。<br>后继微地址的形成方法对微程序编制的灵活性影响很大。<br>后继微地址的形成方法主要有两种基本类型：<strong>增量方式</strong>和<strong>断定方式</strong>。</p>
<p>(1) 增量方式</p>
<p>增量方式：当微程序按地址递增顺序一条条地执行微指令时，后继微地址是现行微地址加上一个增量（通常为1）。</p>
<p> (2)断定方式</p>
<p>断定方式：后继微地址可由设计者指定或由设计者指定的测试判定字段控制产生。</p>
<p><a href="https://imgtu.com/i/oHQBSP"><img src="https://s4.ax1x.com/2021/12/11/oHQBSP.png" alt="oHQBSP.png"></a></p>
<p><a href="https://imgtu.com/i/oHQWYn"><img src="https://s4.ax1x.com/2021/12/11/oHQWYn.png" alt="oHQWYn.png"></a></p>
<h2 id="MIPS数据通路"><a href="#MIPS数据通路" class="headerlink" title="MIPS数据通路"></a>MIPS数据通路</h2><h3 id="单周期"><a href="#单周期" class="headerlink" title="单周期"></a>单周期</h3><p><a href="https://imgtu.com/i/oLs2id"><img src="https://s4.ax1x.com/2021/12/13/oLs2id.png" alt="oLs2id.png"></a></p>
<h3 id="多周期"><a href="#多周期" class="headerlink" title="多周期"></a>多周期</h3><p><a href="https://imgtu.com/i/oLsqij"><img src="https://s4.ax1x.com/2021/12/13/oLsqij.png" alt="oLsqij.png"></a></p>
<h2 id="RISC-V数据通路"><a href="#RISC-V数据通路" class="headerlink" title="RISC-V数据通路"></a>RISC-V数据通路</h2><h3 id="单周期-1"><a href="#单周期-1" class="headerlink" title="单周期"></a>单周期</h3><p><a href="https://imgtu.com/i/oL6FHS"><img src="https://s4.ax1x.com/2021/12/13/oL6FHS.png" alt="oL6FHS.png"></a></p>
<h3 id="多周期-1"><a href="#多周期-1" class="headerlink" title="多周期"></a>多周期</h3><p><a href="https://imgtu.com/i/oL6Vhj"><img src="https://s4.ax1x.com/2021/12/13/oL6Vhj.png" alt="oL6Vhj.png"></a></p>
<h2 id="流水线处理技术"><a href="#流水线处理技术" class="headerlink" title="流水线处理技术"></a>流水线处理技术</h2><h3 id="指令的执行方式"><a href="#指令的执行方式" class="headerlink" title="指令的执行方式"></a>指令的执行方式</h3><p>前面所述的控制器同步、异步和联合控制三种控制方式是<strong>根据微操作序列的时序来划分的。</strong><br>根据各条<strong>指令之间的衔接关系</strong>指令的执行又可分为顺序、重叠、流水三种方式。<br>$$<br>T=\sum_{i=1}^{n}(t_{IF}+t_{ID}+t_{EX})<br>$$</p>
<h3 id="重叠方式"><a href="#重叠方式" class="headerlink" title="重叠方式"></a>重叠方式</h3><p>一次重叠：<br>$$<br>T=t_{IF}+nt_{ID}+(n-1)max(t_{IF},t_{EX})+t_{EX}<br>$$<br>二次重叠：<br>$$<br>T=t_{IF}+max(t_{IF},t_{ID})+(n-2)max(t_{IF},t_{ID},t_{EX})+max(t_{ID},t_{EX})+t_{EX}<br>$$<br>就是重叠的地方max</p>
<h2 id="流水方式"><a href="#流水方式" class="headerlink" title="流水方式"></a>流水方式</h2><p>在采用五段流水线对指令解释执行时，在一个时钟周期内，同时有五条指令分别在不同的功能部件上被解释。<br>流水线稳定工作后，<strong>每个时钟周期都有一条指令的执行结果从流水线流出</strong>。</p>
<p>流水线吞吐率：<br>$$<br>\frac {1}{\Delta t} (\Delta t是流水线时钟周期)<br>$$</p>
<h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><p>处理级别：操作部件级，指令级，处理机间</p>
<p>按功能：单功能，多功能</p>
<p>工作方式：静态，动态（允许在同一时间将不同的功能段组合成具有多功能的流水子集</p>
<p>结构：线性，非线性</p>
<h3 id="流水线的性能"><a href="#流水线的性能" class="headerlink" title="流水线的性能"></a>流水线的性能</h3><p><a href="https://imgtu.com/i/oLTN28"><img src="https://s4.ax1x.com/2021/12/13/oLTN28.png" alt="oLTN28.png"></a></p>
<h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>单位时间内流水线能完成的指令数<br>$$<br>T_P = \frac {n}{m\Delta t + (n-1)\Delta t}<br>$$</p>
<h4 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h4><p>串行用时：流水线用时<br>$$<br>S_P = \frac {T_S} {T_C} = \frac {nm\Delta t}{m\Delta t+(n-1)\Delta t}<br>$$</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>任务时空区：总时空区<br>$$<br>\eta = \frac {nm\Delta t}{m(m+n-1)\Delta t}<br>$$</p>
<h3 id="标准流水线"><a href="#标准流水线" class="headerlink" title="标准流水线"></a>标准流水线</h3><p>流水线性能重要元素：流水线中功能段数量</p>
<h3 id="高级流水线"><a href="#高级流水线" class="headerlink" title="高级流水线"></a>高级流水线</h3><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p>将流水线细分，增加流水线的段数，减少每段的延迟时间</p>
<h4 id="超长指令字技术"><a href="#超长指令字技术" class="headerlink" title="超长指令字技术"></a>超长指令字技术</h4><p>经过编译优化，将多条能够并行执行的指令合并成一条具有多个操作码的超长指令</p>
<h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p>用多套相同的指令流水</p>
<h3 id="流水线的相关问题"><a href="#流水线的相关问题" class="headerlink" title="流水线的相关问题"></a>流水线的相关问题</h3><p>如果一段程序的相近指令之间存在某种依赖关系，称为指令之间存在相关关系（冒险）</p>
<p><strong>使流水断流的相关问题</strong></p>
<p>局部相关：资源冲突，数据相关</p>
<p>全局相关：控制转移相关，如转移指令、中断处理</p>
<h4 id="资源相关（结构冒险）"><a href="#资源相关（结构冒险）" class="headerlink" title="资源相关（结构冒险）"></a>资源相关（结构冒险）</h4><p>争用同一个部件</p>
<p>解决办法：插气泡</p>
<p>增加缓冲部件，存储冲突还可以设置两个不同的存储器</p>
<h4 id="数据相关（数据冒险）"><a href="#数据相关（数据冒险）" class="headerlink" title="数据相关（数据冒险）"></a>数据相关（数据冒险）</h4><p>多条指令进入流水线之后，指令的操作重叠</p>
<p>解决办法：</p>
<p>（1）使后续相关的指令延迟进入流水线（推后法）。<br>（2）增加快速直接通道（零延迟量法、定向技术-设置专用旁路）。</p>
<h4 id="控制转移相关（控制冒险）"><a href="#控制转移相关（控制冒险）" class="headerlink" title="控制转移相关（控制冒险）"></a>控制转移相关（控制冒险）</h4><p>控制相关是指有分支指令、转子指令和中断等引起的相关冲突。</p>
<p>解决办法：</p>
<p>加快和提及前形成条件码</p>
<p>预取转移成功分支序列的指令</p>
<p>延迟转移</p>
<p>动态转移预测（根据历史预测转移方向）</p>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="机器指令格式"><a href="#机器指令格式" class="headerlink" title="机器指令格式"></a>机器指令格式</h2><p>指令字（指令代码）：表示一条指令的一串二进制代码。</p>
<p><strong>一条指令中应包含的信息：</strong><br>① <strong>操作码</strong>：表示指令的操作特性和功能。<br>② <strong>操作数的地址</strong>：指示操作数或操作数所在的地址。<br>③ <strong>存放操作结果的地址。</strong><br>④ <strong>下一条指令的地址。</strong><br>指令的基本格式：</p>
<p>OP + A</p>
<p>各字段的指定方法：<br>显式指定：在指令字中明显地指定。<br>隐含指定：由设计者用约定的方法指定。<br>指令操作码均采用显式指定。<br>下一条指令的地址多采用隐含指定。<br>信息的存储结构不同，指定的地址也不一样，地址的结构也不同。</p>
<h2 id="指令字的长度"><a href="#指令字的长度" class="headerlink" title="指令字的长度"></a>指令字的长度</h2><p>指令字长度：一个指令字所包含的二进制信息的位数。<br>定长指令字：机器的指令系统中各种指令字的长度均为固定的。<br>可变长指令字：机器的指令系统中各种指令字的长度随指令的功能而异。 </p>
<p><strong>单字长指令</strong>：指令长度等于<strong>机器字长</strong>。<br>双字长指令：指令长度等于两个机器字长。</p>
<p>指令基本格式：操作码（OP），地址码（A）</p>
<p>显式指令：指令字中明显地指定</p>
<p>隐含指定：由设计者用约定的方法指定</p>
<h2 id="指令地址码"><a href="#指令地址码" class="headerlink" title="指令地址码"></a>指令地址码</h2><p>CPU可直接访问的存储结构：</p>
<p>主存储器：访问时给出存储单元地址</p>
<p>CPU寄存器：包括通用寄存器和专用寄存器</p>
<p>I/O接口寄存器：包括数据寄存器和状态寄存器</p>
<p>堆栈</p>
<p><strong>例</strong>：设机器指令字长为16位，指令中地址字段的长度为4位，共有11条三地址指令，72条二地址指令，64条零地址指令。问最多还能规定多少条一地址指令？<br>解：三地址指令的地址字段共需12位，所以可有4位操作码，可规定16条三地址指令。现有11条三地址指令，所以还有 16－11＝5 个编码用于二地址指令。<br>二地址指令的地址字段共需8位，可有8位操作码，去掉三地址指令用掉的操作码，可规定5×16＝80 条二地址指令。现有72条二地址指令，所以还有80－72＝8 个编码用于一地址指令。</p>
<p>一地址指令的地址字段共需4位，可有12位操作码，去掉二、三地址指令用掉的操作码，可规定 8×16＝128 条单地址指令。<br>由于要求有64条零地址指令，而4位操作码只能提供16条指令，所以需要由单地址指令提供64/16＝4个操作码编码，因此还能规定 128－4＝124 条单地址指令。</p>
<h2 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h2><p>顺序方式：采用PC增量的方式形成下一条指令地址。 </p>
<p>跳越方式：当程序发生转移时，修改PC的内容。</p>
<h2 id="操作数的寻址方式"><a href="#操作数的寻址方式" class="headerlink" title="操作数的寻址方式"></a>操作数的寻址方式</h2><p>常用寻址方式：</p>
<p>OP+MOD+A</p>
<p><strong>立即寻址</strong>：</p>
<p>立即寻址方式是指指令的地址码部分给出的不是操作数的地址而是操作数本身。即指令所需的操作数由指令的形式地址直接给出。</p>
<p><strong>直接寻址</strong>：</p>
<p>直接寻址方式是指操作数的有效地址在指令字中直接给出，指令的地址码部分给出的形式地址A就是操作数的有效地址EA。 </p>
<p><a href="https://imgtu.com/i/oDTZDK"><img src="https://s4.ax1x.com/2021/12/05/oDTZDK.png" alt="oDTZDK.png"></a></p>
<p><strong>间接寻址</strong>：</p>
<p>间接寻址方式是指指令的地址码部分给出的是操作数的有效地址EA所在的存储单元的地址或是指示操作数地址的地址指示字。即有效地址EA是由形式地址A间接提供的。<br>间接寻址分为一级间接寻址和多级间接寻址。</p>
<p><a href="https://imgtu.com/i/oDTC4J"><img src="https://s4.ax1x.com/2021/12/05/oDTC4J.png" alt="oDTC4J.png"></a></p>
<p><strong>寄存器直接寻址</strong>：</p>
<p>寄存器直接寻址也称寄存器寻址。寄存器直接寻址是指在指令地址码中给出的是某一通用寄存器的编号（也称寄存器地址），该寄存器的内容即为指令所需的操作数。采用寄存器寻址方式时，有效地址EA是寄存器的编号。</p>
<p><a href="https://imgtu.com/i/oDTpEF"><img src="https://s4.ax1x.com/2021/12/05/oDTpEF.png" alt="oDTpEF.png"></a></p>
<p><strong>寄存器间接寻址</strong>：</p>
<p>寄存器间接寻址方式是指指令中地址码部分所指定的寄存器中的内容是操作数的有效地址。 </p>
<p><a href="https://imgtu.com/i/oDozHU"><img src="https://s4.ax1x.com/2021/12/05/oDozHU.png" alt="oDozHU.png"></a></p>
<p><strong>变址寻址</strong>：</p>
<p>变址寻址方式是指操作数的有效地址是由指令中指定的变址寄存器的内容与指令字中的形式地址相加形成的。<br>变址寄存器Rx可以是专用寄存器，也可以是通用寄存器中的某一个。 </p>
<p><strong>相对寻址</strong>：</p>
<p>相对寻址方式是将程序计数器 PC 的当前内容与指令中给出的形式地址相加形成操作数的有效地址。</p>
<p><a href="https://imgtu.com/i/oDovuV"><img src="https://s4.ax1x.com/2021/12/05/oDovuV.png" alt="oDovuV.png"></a></p>
<p><strong>基址寻址</strong>：</p>
<ul>
<li><strong>基址寻址主要用于为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序运行过程中，值是不可变的，而指令字中的地址码是可变的。</strong></li>
<li><strong>变址寻址中，变址寄存器的内容是用户自己设定的，在程序运行过程中是可变的，而指令字中的地址码是不可变的。编制寻址主要用于处理数组等问题，并且特别适合编制循环程序。</strong></li>
</ul>
<p><a href="https://imgtu.com/i/oDoD0O"><img src="https://s4.ax1x.com/2021/12/05/oDoD0O.png" alt="oDoD0O.png"></a> </p>
<p><strong>基址加变址寻址</strong>：</p>
<p><a href="https://imgtu.com/i/oDo1mT"><img src="https://s4.ax1x.com/2021/12/05/oDo1mT.png" alt="oDo1mT.png"></a></p>
<p><strong>堆栈寻址</strong>：</p>
<p><strong>寄存器堆栈：</strong></p>
<p>计算机在CPU中设置一组专门用于堆栈的寄存器，每个寄存器按照机器字长可以保存一个字的数据，相邻的寄存器具有位对位的移位功能，CPU可以通过进栈指令和出栈指令，控制将数据压入和弹出堆栈。<br>寄存器堆栈由于栈顶位置固定，所以不必设置堆栈的栈顶指针。</p>
<p><a href="https://imgtu.com/i/oDbkgs"><img src="https://s4.ax1x.com/2021/12/05/oDbkgs.png" alt="oDbkgs.png"></a></p>
<p><strong>存储器堆栈</strong>：</p>
<p>存储器堆栈就是一组连续的存储器单元的有序集合。<br>堆栈通常位于主存的一个特定区域，它既可以是固定的区域，也可以是浮动的区域，可以用软件加以定义，而且需要时可以定义多个存储器堆栈。<br>为了表示栈顶的位置，通常用一个寄存器或存储器单元指出栈顶的地址，这个寄存器或存储器单元称为堆栈指针SP，SP的内容永远指向堆栈当前的栈顶。<br>由于堆栈遵循先进后出原则进行信息的存取，堆栈的压入和弹出操作总是按地址自动增量和自动减量方式在栈顶进行。  </p>
<p><strong>堆栈寻址</strong>：</p>
<p>堆栈寻址方式就是按照堆栈指示器SP的内容确定操作数的访存地址。<br>例如在堆栈支持的运算型零地址指令中，操作数隐含指定在堆栈，当CPU执行这种指令时，自动地按当前SP值从堆栈的栈顶和次栈顶弹出数据，进行操作码指示的操作，然后再将所得结果自动压入堆栈。<br>堆栈除了可为零地址指令提供操作数外，还有很多用途。如在子程序的调用中，用堆栈存放返回地址，可以实现子程序的嵌套和递归调用；在程序中断的处理中，用堆栈存放多级中断的有关信息，可以实现多级中断的嵌套等。  </p>
<h2 id="指令类型及功能"><a href="#指令类型及功能" class="headerlink" title="指令类型及功能"></a>指令类型及功能</h2><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ol>
<li>完备性<br> 任何运算都可以用指令编程实现。即要求指令系统的指令丰富、功能齐全、使用方便，应具有所有基本指令。</li>
<li>有效性<br> 用指令系统中的指令编写的程序能高效率运行，占用空间小、执行速度快。</li>
<li>规整性<br> 指令系统具有对称性、匀齐性，指令与数据格式的一致性。</li>
<li>对称性：所有寄存器和存储单元均同等对待，所有指令可以使用所有寻址方式，减少特殊操作和例外情况。</li>
<li>匀齐性：一种操作可支持各种数据类型。如算术指令可支持字节、字、双字、十进制数、浮点单精度数、浮点双精度数等。</li>
<li>指令与数据格式的一致性：指令长度与数据长度有一定的关系，以便于存取和处理。</li>
<li>兼容性：系列机的各机种之间有基本相同的指令集。至少作到向后兼容，即先推出的机器上的程序可以在后推出的机器上运行。</li>
</ol>
<h1 id="I-O系统组织"><a href="#I-O系统组织" class="headerlink" title="I/O系统组织"></a>I/O系统组织</h1><h2 id="I-O系统的功能"><a href="#I-O系统的功能" class="headerlink" title="I/O系统的功能"></a>I/O系统的功能</h2><p>I/O系统的基本功能</p>
<p>为数据传输操作选择I/O设备</p>
<p>控制被选的I/O设备与主机之间的信息交换</p>
<p>关键问题：解决主机与外部设备间的信息通讯问题，提供主机与外设间的信息通路，使外围设备与主机能够协调一致地工作。</p>
<p>I/O系统主要用于解决主机与外部设备间的数据交换的问题，使外设与主机能够协调一致地工作。<br> （1） 使处理机与外设在数据处理的<strong>速度上能够相互匹配</strong>。解决方法：缓冲技术<br>（2） 使处理机与外设<strong>能够并行工作</strong>，以提高整个计算机系统的工作效率。解决方法：减少处理机对外设的直接控制，甚至处理机不再干预对外设的控制，而交由专门的硬件装置去实现对外部设备的管理与监督。</p>
<p>典型计算机系统中I/O系统的组成：<br><strong>系统总线</strong>、<strong>I/O设备接口控制器</strong>、<strong>I/O设备</strong>、<strong>相关控制软件</strong>。 </p>
<p>现代计算机系统中I/O系统的组成：<br><strong>扩展总线</strong>、<strong>I/O设备接口控制器</strong>、I/O设备、相关控制软件。 </p>
<p>主机与外围设备的连接方式大致可分为：</p>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p><strong>总线方式，通道方式，I/O处理机方式（IOP）</strong></p>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>有些种类的I/O接口控制器可以控制多台I/O设备，如多用户卡。这种方式称之为现代星型I/O设备的连接方式</p>
<h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>通道控制器是专门负责I/O操作的控制器，它执行由专门的通道指令编制并存放在<strong>内存之中的通道程序</strong>实现对外设的控制。<br>通道控制连接方式下，由通道控制器控制实现<strong>主存与外设之间的直接数据交换</strong>， <strong>CPU不再负责具体的I/O控制</strong>，实现了处理机与通道控制器和外设的并行工作。</p>
<h4 id="IOP"><a href="#IOP" class="headerlink" title="IOP"></a>IOP</h4><p>I/O处理机(IOP)<br><strong>一种具有比I/O通道更强独立性的专用CPU。</strong><br>IOP有自己的指令系统，可编程控制，适应性强、通用性好。其程序的执行可与CPU并行，可使CPU彻底摆脱对I/O的控制处理。</p>
<h3 id="I-O信息传送的控制方式"><a href="#I-O信息传送的控制方式" class="headerlink" title="I/O信息传送的控制方式"></a>I/O信息传送的控制方式</h3><p>I/O数据传送控制方式也称I/O信息交换方式。</p>
<p><a href="https://imgtu.com/i/ordZyq"><img src="https://s4.ax1x.com/2021/12/06/ordZyq.png" alt="ordZyq.png"></a></p>
<h4 id="由程序控制的数据传送"><a href="#由程序控制的数据传送" class="headerlink" title="由程序控制的数据传送"></a>由程序控制的数据传送</h4><p>这种控制方式是指在主机和设备之间的I/O数据传送，<strong>需要通过处理机执行具体的I/O指令来完成</strong>。即由处理机执行所谓的I/O程序，实现对整个I/O数据传送过程的<strong>全程监督与管理</strong>。<br>程序控制方式一般在<strong>总线型连接方式中采用</strong>。<br>由程序控制的数据传送可进一步分为直接程序控制方式和程序中断传送方式。 </p>
<h3 id="由专有硬件控制的数据传输"><a href="#由专有硬件控制的数据传输" class="headerlink" title="由专有硬件控制的数据传输"></a>由专有硬件控制的数据传输</h3><p>这种控制方式需要在系统中设置<strong>专门用于控制I/O数据传输的硬件装置</strong>，处理机只要启动这些装置，就会在它们的控制下完成I/O数据传输，因此具体的I/O数据传输过程无需处理机的控制。</p>
<h2 id="接口的功能"><a href="#接口的功能" class="headerlink" title="接口的功能"></a>接口的功能</h2><p>接口：通常指设备(硬件)之间的界面。</p>
<p>I/O接口：主机(系统总线)与外设或其它外部系统之间的接口逻辑。</p>
<p>当主机与外设相连时，必须要有相应的接口逻辑部件来解决两者之间的<strong>操作同步与协调</strong>、<strong>工作速度的匹配</strong>以及<strong>数据格式的转换</strong>等问题。</p>
<h3 id="I-O接口基本功能："><a href="#I-O接口基本功能：" class="headerlink" title="I/O接口基本功能："></a>I/O接口基本功能：</h3><p>⑴ 实现<strong>数据的传送</strong>、缓冲、隔离和锁存。<br>⑵ 实现信号形式和数<strong>据格式转换</strong>。<br>⑶ 控制主机与外设之间的通信联络，实现控制命令和状态信息的交换，保证<strong>时序协调</strong>。<br>⑷ 寻址，即<strong>识别设备地址</strong>，选择指定的设备和I/O端口。</p>
<h3 id="CPU和外设之间传送的信息"><a href="#CPU和外设之间传送的信息" class="headerlink" title="CPU和外设之间传送的信息"></a>CPU和外设之间传送的信息</h3><h4 id="数据信息"><a href="#数据信息" class="headerlink" title="数据信息"></a>数据信息</h4><p>①  数字量<br>数字量是指用二进制码形式提供的信息，如用二进制形式表示的数据、以ASCII码形式表示的字符等。通常有8位、16位和32位数据。<br>②  模拟量<br>模拟量是指连续变化的物理量，如温度、湿度、位移、压力、流量等。</p>
<p>③ 开关量<br>开关量有两个状态：“0”和“1”，可以用1位二进制数表示。具有两种状态的量</p>
<h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>状态信息就是反映当前<strong>外设所处的工作状态的信息</strong>。<br>在与外设进行数据信息的交换时，CPU需要通过状态信息了解外设的<strong>工作状态</strong>。通常外设用准备好（READY）信号来表明是否准备就绪；用忙（BUSY）信号表示是否处于空闲状态。</p>
<h4 id="控制命令信息"><a href="#控制命令信息" class="headerlink" title="控制命令信息"></a>控制命令信息</h4><p>在外设的工作过程中，CPU需要<strong>通过控制信息控制外设的工作</strong>，如对外设的启动和停止等。不同外设所需的控制信息各不相同，因此CPU需要<strong>通过接口将控制信息传送给外设</strong>。 </p>
<h4 id="同步信号"><a href="#同步信号" class="headerlink" title="同步信号"></a>同步信号</h4><p>当主机或外设将数据发送到接口后，接口需要<strong>给出数据已经“就绪”的信号</strong>通知对方可以取走数据进行处理，即需要有同步信号实现同步控制。</p>
<h4 id="设备选择信号"><a href="#设备选择信号" class="headerlink" title="设备选择信号"></a>设备选择信号</h4><p>设备选择信号<strong>用于指示选中的设备</strong>。<br>它通常作为数据选通信号被送到三态门电路的控制端上使三态门电路脱离高阻状态，以便选中的设备可以参与数据交换。因此，每个设备接口中都有一个专门的设备选择电路。</p>
<h4 id="中断及DMA控制逻辑"><a href="#中断及DMA控制逻辑" class="headerlink" title="中断及DMA控制逻辑"></a>中断及DMA控制逻辑</h4><p>如果系统中采用中断方式控制主机与外设之间的信息交换，接口中则应有中断控制逻辑。</p>
<p>如果系统中采用的DMA方式控制主机与外设之间的信息交换，则接口中就应有DMA控制逻辑。</p>
<h3 id="I-O信息的传送"><a href="#I-O信息的传送" class="headerlink" title="I/O信息的传送"></a>I/O信息的传送</h3><p>数据信息、状态信息和控制信息各不相同，应该分别传送。<br>为了便于处理，将状态信息、控制信息也<strong>广义地看成数据信息</strong>，通过数据总线来传送。为了区别这三种信息，在接口线路中将它们分别送入不同的寄存器。<br>CPU同外设之间的信息传送<strong>实质上是对相应的寄存器进行“读”或“写”操作。</strong><br><strong>端口</strong>（Port或I/O端口）：接口中可以由<strong>CPU进行读或写</strong>的<strong>寄存器</strong>。</p>
<h3 id="I-O端口寻址方式"><a href="#I-O端口寻址方式" class="headerlink" title="I/O端口寻址方式"></a>I/O端口寻址方式</h3><h4 id="与主存统一编址"><a href="#与主存统一编址" class="headerlink" title="与主存统一编址"></a>与主存统一编址</h4><p>将一个I/O端口作为存储器中的一个单元对待，每一个I/O端口占用一个存储器单元地址。编址时将I/O端口与存储器单元一起进行编址。<br>又称为存储器对应的输入输出方式或存储器映象编址方式。</p>
<h4 id="I-O端口独立编址"><a href="#I-O端口独立编址" class="headerlink" title="I/O端口独立编址"></a>I/O端口独立编址</h4><p>将I/O端口与存储器单元分别独立进行编址，CPU访问外设时，需使用<strong>专门的I/O指令</strong>，并需要有与接口电路联系的单独的控制信号。<br>也称为I/O端口寻址输入输出方式。</p>
<h3 id="I-O接口的分类"><a href="#I-O接口的分类" class="headerlink" title="I/O接口的分类"></a>I/O接口的分类</h3><h4 id="按数据传送格式分"><a href="#按数据传送格式分" class="headerlink" title="按数据传送格式分"></a>按数据传送格式分</h4><p><a href="https://imgtu.com/i/orsI9U"><img src="https://s4.ax1x.com/2021/12/06/orsI9U.png" alt="orsI9U.png"></a></p>
<h4 id="按时序的控制方式分"><a href="#按时序的控制方式分" class="headerlink" title="按时序的控制方式分"></a>按时序的控制方式分</h4><p>同步接口：一般与同步总线相连，<strong>接口与总线采用统一时钟信号</strong>，无论CPU与I/O设备，还是存储器与I/O设备交换信息，都与总线同步时钟脉冲同步。<br>异步接口：与异步总线相连，接口与系统总线之间采用异步应答方式。</p>
<h4 id="按信息传送交换的控制方式分"><a href="#按信息传送交换的控制方式分" class="headerlink" title="按信息传送交换的控制方式分"></a>按信息传送交换的控制方式分</h4><p>直接程序控制接口：采用直接程序控制方式进行信息交换的接口。<br>程序中断接口：主机与外设以程序中断方式进行信息交换控制的接口。<br>直接存储器存取接口：以直接存储器存取(DMA)方式控制信息传送的接口。</p>
<h3 id="接口基本组成"><a href="#接口基本组成" class="headerlink" title="接口基本组成"></a>接口基本组成</h3><p><a href="https://imgtu.com/i/oryG5V"><img src="https://s4.ax1x.com/2021/12/06/oryG5V.png" alt="oryG5V.png"></a></p>
<p>⑴  <strong>设备选择电路</strong><br>用于接收总线传来的地址信息，经译码后，决定选择哪个设备或I/O接口内部的部件。<br>⑵ <strong>数据缓冲寄存器</strong>（数据端口）<br>用于存放主机与外设之间要传递的数据信息。<br>⑶ <strong>命令寄存器</strong>（控制端口）<br>用于存放主机向外设发送的控制命令。<br>⑷ <strong>状态寄存器</strong>（状态端口）<br>用于存放外设或接口的工作状态。<br>⑸ <strong>其它有关部件</strong><br>如中断控制逻辑、DMA控制逻辑以及各类特殊部件。</p>
<h2 id="程序控制方式"><a href="#程序控制方式" class="headerlink" title="程序控制方式"></a>程序控制方式</h2><p>程序控制方式的特点：<br><strong>数据传输操作通过在处理机上执行的I/O指令来实现。</strong><br>程序控制方式下数据传输的过程：</p>
<p>⑴ <strong>输入数据</strong><br>① CPU执行<strong>I/O输入指令</strong>，启动输入操作总线周期，将I/O接口<strong>数据缓冲寄存器</strong>中的数据取到<strong>CPU中的累加器中</strong>。<br>② CPU执行写存储器指令，<strong>启动写存储器总线周期</strong>，<strong>将累加器中存放的输入数据写到内存某个单元中</strong>。</p>
<p>⑵ <strong>输出数据</strong><br>① CPU执行<strong>读存储器指令</strong>，启动读存储器总线周期，将内存某个单元中存放的待输出数据取到<strong>CPU的累加器</strong>中。<br>② CPU执行I/O输出指令，启动输出操作总线周期，将累加器中存放的待输出数据写到设备接口的数据缓冲寄存器中。<br>★在程序控制方式下，<strong>内存与外设交换一个数据需要使用两次总线</strong>，即需要执行一个访问存储单元的总线周期和一个访问I/O的总线周期。 </p>
<h3 id="直接程序控制方式"><a href="#直接程序控制方式" class="headerlink" title="直接程序控制方式"></a>直接程序控制方式</h3><p>直接程序控制方式完全通过程序来控制主机与外设之间信息传送。<br>通常是在用户程序中安排一段由I/O指令和其它指令组成的I/O程序，通过执行I/O程序实现对外设的直接控制。  </p>
<p><a href="https://imgtu.com/i/or6yes"><img src="https://s4.ax1x.com/2021/12/06/or6yes.png" alt="or6yes.png"></a></p>
<h4 id="程序中断传送方式"><a href="#程序中断传送方式" class="headerlink" title="程序中断传送方式"></a>程序中断传送方式</h4><p>中断是指处理机<strong>暂时中止执行现行程序而转去执行处理更加紧迫事件的服务程序</strong>，待处理完毕后，再自动返回执行原来的程序的过程。</p>
<p>相对于在CPU上运行的程序，<strong>中断具有随机性</strong>（不可预测性）、<strong>异步性</strong>和<strong>不可再现性</strong>。</p>
<h4 id="中断机构的建立"><a href="#中断机构的建立" class="headerlink" title="中断机构的建立"></a>中断机构的建立</h4><p>中断机构是指在一个计算机系统中，为解决中断问题而制定的一整套软/硬机制、策略和方法。<br>设计、实现中断机构的主要要素：<br>(1) 中断源的设置。定义当系统中出现了<strong>哪些情形将会引发中断</strong>；<br>(2) <strong>中断的分类与分级</strong>。决定如何对中断源分类，以及对各类中断应该赋予什么级别的优先级；<br>(3) 中断信号的建立与传送。即<strong>如何记录中断请求</strong>以及<strong>如何将中断请求发送给CPU</strong>；</p>
<p>(4) 实现<strong>优先级比较</strong>的方式方法；<br>(5) CPU响应中断的<strong>条件和时机</strong>，以及CPU在响应中断时要做的工作；<br>(6) CPU<strong>识别各个中断的方法</strong>，以及如何找到处理相应中断的中断处理程序；<br>(7) 是否允许正在执行的中断处理程序被其他高级别的中断请求打断，即系统<strong>是否允许中断嵌套</strong>。</p>
<h3 id="中断源设置"><a href="#中断源设置" class="headerlink" title="中断源设置"></a>中断源设置</h3><p>中断源是指能引起<strong>中断事件的原因</strong>。</p>
<p>① 在硬件装置上，如I/O设备接口控制器。此时中断由在硬件装置上发生的事件所引起。<br>② 隐藏在指令中，如自陷指令或中断指令。<br>③  CPU内部某个状态寄存器，如浮点数计算溢出标志寄存器。<br>②③两类中断源所引发的中断，都是在CPU执行某条指令时由某种特殊情况而引起的，此时中断产生在<strong>CPU内部</strong>，而不像<strong>设备中断</strong>那样产生于<strong>CPU外部</strong>。</p>
<p>中断源在CPU外部，如设备中断、存储器故障中断、电源故障中断等等。<br>设备中断具有随机性（不可预测性）、异步性和不可再现性。<br>故障中断具有可再现性，比如两次分别对内存故障单元的访问都会引发存储器故障中断。</p>
<h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>中断请求</p>
<p>中断判优</p>
<p>保护现场</p>
<p>中断服务</p>
<p>恢复现场</p>
<p>中断返回</p>
<h3 id="中断请求信号的建立与传送"><a href="#中断请求信号的建立与传送" class="headerlink" title="中断请求信号的建立与传送"></a>中断请求信号的建立与传送</h3><p><a href="https://imgtu.com/i/orTtTU"><img src="https://s4.ax1x.com/2021/12/06/orTtTU.png" alt="orTtTU.png"></a></p>
<h4 id="外设发出请求中断信号的条件"><a href="#外设发出请求中断信号的条件" class="headerlink" title="外设发出请求中断信号的条件"></a>外设发出请求中断信号的条件</h4><p>外设准备就绪</p>
<p>外设的中断请求没有被屏蔽</p>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><p>中断请求信号是否能够传送给CPU，要看当时占有CPU执行程序的优先级。<br>如程序的优先级高于或等于当前中断请求的优先级，则不应将中断请求信号传给CPU，即需进行中断屏蔽。<br>如占有CPU进程的优先级低于请求中断的优先级，则不应屏蔽这个中断，而使CPU能够响应这个中断。</p>
<ol>
<li>先屏蔽：在中断请求触发器IRQ的D端进行屏蔽</li>
<li>后屏蔽：在IRQ的输出端进行屏蔽</li>
<li>集中屏蔽：在公共接口逻辑中设置一个中断控制器</li>
</ol>
<h4 id="中断判优"><a href="#中断判优" class="headerlink" title="中断判优"></a>中断判优</h4><p>内部优于外部</p>
<p>故障由于设备请求</p>
<p>非屏蔽由于屏蔽</p>
<p>输入由于输出</p>
<p>数据有效时间短又于时间长的</p>
<h5 id="CPU现行程序于中断请求间的判优"><a href="#CPU现行程序于中断请求间的判优" class="headerlink" title="CPU现行程序于中断请求间的判优"></a>CPU现行程序于中断请求间的判优</h5><p><strong>通过设置CPU内部的“中断允许”状态进行判优</strong></p>
<p>在CPU内部设置“允许中断”触发器IEN，指令系统提供开中断和关中断的功能</p>
<p>如果CUP处于关中断状态，则所有外部中断都没有现行程序的任务重要</p>
<p><strong>在现行程序的程序状态字PSW中设置现行程序的优先级</strong></p>
<p>若中断请求的优先级高于现行程序的优先级，则予以响应</p>
<h5 id="中断请求之间的排队与判优"><a href="#中断请求之间的排队与判优" class="headerlink" title="中断请求之间的排队与判优"></a>中断请求之间的排队与判优</h5><p>软件查询：响应中断请求后，先转入中断查询程序，按优先顺序依次询问各中断源是否提出请求。</p>
<p>多用于公共请求线方式，但是设备多时响应速度太慢</p>
<p><strong>并行优先排队逻辑</strong></p>
<p>采用硬件并行优先排队逻辑对独立中断请求线的中断请求进行判优</p>
<p><strong>链式排队</strong></p>
<p><strong>二维优先排队</strong></p>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><h5 id="中断响应过程中应该完成的操作"><a href="#中断响应过程中应该完成的操作" class="headerlink" title="中断响应过程中应该完成的操作"></a>中断响应过程中应该完成的操作</h5><p>关中断：不允许新的中断请求</p>
<p>保存断电和程序状态字</p>
<p>转入中断服务程序入口</p>
<h4 id="中断服务程序入口地址的获取方式"><a href="#中断服务程序入口地址的获取方式" class="headerlink" title="中断服务程序入口地址的获取方式"></a>中断服务程序入口地址的获取方式</h4><ol>
<li><p>非向量中断：CPU在响应中断时只产生一个固定的地址，该地址时中断查询程序的入口地址。</p>
<ol>
<li>软件查询方法：CPU响应中断请求后，先转入中断查询程序。</li>
<li>通过硬件排队与编码电路获得优先级最高的中断源的设备码</li>
</ol>
</li>
<li><p>向量中断：</p>
<ol>
<li>中断向量：所有中断源对应的中断服务程序的入口地址及其程序状态字PSW的有序集合</li>
<li>中断向量表：存放中断向量的表。所有中断服务程序入口地址组织成的一个一维表</li>
<li>中断向量地址：访问中断向量表的地址码，即读取中断向量所需的地址，也成为中断指针。</li>
</ol>
<p>向量中断：将各个中断服务程序的入口地址组织成中断向量表；响应中断时，由硬件直接产生对应于中断源的向量地址；据此访问中断向量表，从中读取服务程序入口地址，由此转向中断服务程序。</p>
<p>向量中断的响应工作一般在中断周期中由硬件直接实现。</p>
<p>特点：<strong>能够根据中断请求信号快速/直接的转向应对中断服务程序</strong></p>
<p>⑴ 中断源提出中断请求。<br>⑵ 若CPU允许中断，则发出中断回答信号。<br>⑶ 优先级编码电路形成优先级最高的中断请求的中断向量地址存入中断向量地址寄存器VAR。<br>⑷ 保护断点和现场，PC、PSW入栈。<br>⑸ 根据中断向量地址，将对应的中断服务程序入口地址和PSW送入PC和PSR。<br>⑹ 转入中断服务程序，进行中断服务。<br>⑺ 中断返回，将保存的PC和PSW弹回PC和PSR。</p>
</li>
</ol>
<h4 id="中断服务"><a href="#中断服务" class="headerlink" title="中断服务"></a>中断服务</h4><p>取得中断服务程序的入口地址之后，CPU开始执行中断服务程序</p>
<h5 id="起始"><a href="#起始" class="headerlink" title="起始"></a>起始</h5><p>判断中断原因，识别中断源</p>
<p>设置屏蔽字</p>
<p>保护中断现场</p>
<p>开中断：以便在本次中断处理过程中，允许响应更高级的中断请求</p>
<h5 id="主体部分"><a href="#主体部分" class="headerlink" title="主体部分"></a>主体部分</h5><p>执行具体的中断源服务程序</p>
<h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><p>关中断</p>
<p>恢复中断现场</p>
<p>清中断请求信号</p>
<p>清屏蔽字</p>
<p>开中断</p>
<p>恢复PSW,PC</p>
<p>总的说，就是：关，保护，开，处理，关，恢复，开，返回</p>
<h4 id="中断响应的及时性"><a href="#中断响应的及时性" class="headerlink" title="中断响应的及时性"></a>中断响应的及时性</h4><p>中断源提出中断申请后到中断处理程序的第一条指令开始执行之间的时间</p>
<p><strong>程序中断对流水线的影响</strong></p>
<p>不精确断点法</p>
<p>不论在哪一条指令中的哪个流水功能段上发生中断请求，都不再允许未流入流水线的后继指令进入流水线。但已经在流水线中的所有指令，允许它们继续流动到执行完毕。</p>
<p>精确断点法</p>
<p>流水线都停下来，用大量寄存器保存现场</p>
<h2 id="DMA的基本概念"><a href="#DMA的基本概念" class="headerlink" title="DMA的基本概念"></a>DMA的基本概念</h2><p><strong>程序直接控制方式</strong>受“踏步”现象的限制，效率低下，不适合高速设备和主机间的数据传送。<br><strong>中断控制方式</strong>虽比程序直接控制方式有效，CPU和外设有一定的并行度，但由于下列原因也不适合高速设备和主机间的数据传送。</p>
<p>DMA方式：<br>      <strong>以主存为中心</strong>，采用硬件手段在主存与I/O设备之间建立直接的数据传送通路，<strong>由DMA控制器（DMAC）取得总线控制权</strong>，控制主存与I/O设备之间的数据传送，在传送过程中不需要CPU的程序干预的数据传送控制方式。</p>
<h3 id="DMA方式的特点与应用场合"><a href="#DMA方式的特点与应用场合" class="headerlink" title="DMA方式的特点与应用场合"></a>DMA方式的特点与应用场合</h3><ol>
<li>DMA方式的特点<br> ⑴ 以响应随机请求的方式，实现主存与I/O设备间的快速数据传送。<br> ⑵ 采用DMA方式控制数据传送时，仅需占用系统总线，不切换程序，不存在保存断点、保护现场、恢复现场、恢复断点等操作。因此DMA传送的插入不影响CPU的程序执行状态，除了访问主存的冲突外，CPU可以继续执行自己的程序，提高了CPU的利用率。<br> ⑶ DMA方式只能处理简单的数据传送，难以识别与处理复杂的情况。  </li>
<li>DMA方式的应用<br> DMA方式一般应用于主存与高速I/O设备间的简单数据传送(高速I/O设备如磁盘、磁带、光盘等外存储器)，以及其它带有局部存储器的外围设备、通信设备等。如：<br> ⑴ 磁盘与主存的成块数据传送<br> ⑵ 通信设备的批量数据传送<br> ⑶ 动态存储器的刷新<br> ⑷ 大批量数据采集系统</li>
</ol>
<h3 id="DMA的传送方式"><a href="#DMA的传送方式" class="headerlink" title="DMA的传送方式"></a>DMA的传送方式</h3><p>周期挪用（周期窃取）方式</p>
<p>当I/O设备无DMA传送请求时，CPU正常访问主存。当I/O设备需要使用总线传送数据时，产生DMA请求，DMAC把总线请求发给CPU。<br>① 若CPU本身无使用总线的要求，CPU就把总线交给DMAC，由DMAC控制I/O设备使用总线<br>② 如果此时CPU也要使用总线，则CPU自身进入一个或几个“空闲总线周期”状态，<strong>即CPU让出一个或几个总线周期给DMAC</strong>（也称DMAC“挪用”一个总线周期），DMAC利用此总线周期控制传送一个数据字后，再把总线交还给CPU，以便CPU可以继续执行总线操作。 </p>
<p>采用周期挪用方式时，外设要求DMA传送的三种情况：<br>⑴ 外设要求DMA传送时，CPU不需访问主存(如CPU正在执行乘法指令，由于乘法指令执行时间较长，此时CPU不需访问主存)，故外设访存与CPU不发生冲突。<br>⑵ 外设要求DMA传送时，CPU正在访存，此时必须<strong>等CPU存取周期结束后</strong>，CPU才能让出总线控制权。<br>⑶ 外设要求访存时，CPU也要求访存，这就出现了访存冲突。此时要求外设访存优先于CPU访存。因为外设不立即访存就可能丢失数据，这时D<strong>MAC要窃取</strong>一、二个存取周期，使CPU延缓一、二个存取周期再访存。</p>
<p><strong>缺点</strong></p>
<p>每传送一个数据，DMA都要产生访问请求，待到CPU响应后才能传送，因此判优操作及总线切换操作非常频繁，其花费的时间开销较大。往往在传输一个数据块时，需要DMA控制器多次申请使用总线，这影响了DMA的数据传输速度。</p>
<p>周期挪用方式适用于I/O设备接口控制器中<strong>数据缓冲器容量不大</strong>的场合，例如在接口控制器中仅设置一个数据寄存器的情形，对具有较大容量数据缓冲存储器的高速外设来说是不合适的。 </p>
<h3 id="DMA的硬件组织"><a href="#DMA的硬件组织" class="headerlink" title="DMA的硬件组织"></a>DMA的硬件组织</h3><p>在目前的计算机系统中，通常专门设置了DMA控制器，并且较多采取DMA控制器与DMA接口相分离的方式。 </p>
<ol>
<li>DMA控制器（DMAC）<br> DMAC负责申请、接管总线的控制权、发送地址和操作命令以及控制DMA传送过程的起始与终止。<br> DMA控制器独立于具体I/O设备，可以为各个设备通用。 </li>
</ol>
<p>  (1) 主存地址寄存器MAR<br>  用于存放主存中需要交换数据的地址。<br>  在DMA传送前，须通过程序将数据在主存中的首地址送到主存地址寄存器。在DMA传送过程中，每交换一次数据，将地址寄存器内容加/减1，指向下一单元，直到一批数据传送完毕为止。</p>
<p>  (2) 传输量计数器 WC<br>  用于记录传送数据的总字数。<br>  传输量计数器一般采用相反数的补码（变补）表示要传送的数据量。在DMA传送过程中，每传送一个字（或字节）,计数器自动加1，当WC内容溢出时，表示数据已全部传送完毕，DMAC发出DMA传送结束信号。</p>
<p>  (3) 数据缓冲寄存器DBR<br>  用于暂存每次传送的数据。<br>  通常DMA接口与主存之间采用字传送，而DMA与设备之间可能是字节或位传送。因此DMA接口中还可能包括有<strong>装配或拆卸字信息</strong>的硬件逻辑，如数据移位缓冲寄存器、字节计数器等。有的系统采用外设控制器上的数据缓冲器与内存单元之间通过数据总线直传的方法，这样就可以不用数据缓冲寄存器。 </p>
<p>  (4) 设备地址寄存器DAR<br>  存放I/O设备的设备码或表示设备信息存储区的寻址信息。如磁盘数据所在的区号、盘面号和柱面号。具体内容取决于设备的数据格式和地址的编址方式</p>
<ol start="2">
<li><p>接口类型</p>
<p>选择型（只可以接一个设备），多路型（允许接多个设备）</p>
</li>
</ol>
<h3 id="DMA控制方式下的数据传送过程"><a href="#DMA控制方式下的数据传送过程" class="headerlink" title="DMA控制方式下的数据传送过程"></a>DMA控制方式下的数据传送过程</h3><p>DMA预处理</p>
<p>在DMAC开始工作之前，CPU必须给它预置的信息：</p>
<p>控制寄存器写入DMA操作命令，给DMA控制逻辑指明数据床送方向是输入还是输出。</p>
<p>向DMA设备地址寄存器送入设备号</p>
<p>向DMA主存地址寄存器送入交换数据的主存起始地址</p>
<p>向传输量计数器送入交换数据的个数</p>
<p><strong>预处理工作由CPU执行几条输入输出指令完成</strong>，称为初始化工作。初始化工作完成后，CPU继续执行原来的程序。</p>
<p>DMAC获得总线后，即可按规定的传送方式，进行数据的输入或输出操作，<strong>直到将所有数据传输完毕</strong>，DMAC将总线交还给CPU。需要时还向CPU发出中断请求</p>
<p><strong>CPU响应中断后</strong>，为DMA传送作结束处理工作。<br>① 校验送入主存的数据是否正确<br>② 决定是否继续用DMA方式传送，还是结束传送<br>③ 测试在传送过程中是否发生了错误<br>④ 判断传送工作是否正常结束</p>
<h1 id="总线-1"><a href="#总线-1" class="headerlink" title="总线"></a>总线</h1><h2 id="总线性能"><a href="#总线性能" class="headerlink" title="总线性能"></a>总线性能</h2><p>总线带宽＝总线时钟频率×(总线宽度/8)</p>
<p><del>虽然这是错的</del></p>
<h2 id="总线组成"><a href="#总线组成" class="headerlink" title="总线组成"></a>总线组成</h2><p>数据，地址，控制</p>
<p>只有数据总线使双向，数目一般和字长一样，采用三态能力的电路</p>
<h2 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h2><p>注意：源设备不一定就是主设备，目的设备也不一定就是从设备。</p>
<h2 id="总线仲裁的方法"><a href="#总线仲裁的方法" class="headerlink" title="总线仲裁的方法"></a>总线仲裁的方法</h2><p><strong>集中仲裁</strong><br>在系统中设置一个仲裁电路集中处理连接到总线上的各个设备所提出的使用总线的请求信号，集中对它们的优先级进行比较，由此确定总线的主控设备。<br><strong>分布仲裁</strong><br>系统中每一个总线设备中都有较为复杂的总线访问请求控制逻辑，优先级比较电路也是分布在各个总线设备中，由各个已连接到总线上的并且目前有总线请求的设备共同来决定下面应该由哪个设备成为总线的主控设备。 </p>
<p><strong>并行仲裁</strong><br>连接到总线上的每个设备与总线仲裁电路之间都有独立的总线请求线和总线允许信号线。<br><strong>串行仲裁</strong><br>连接到总线上的设备共用一条总线请求信号线或（和）一条总线允许信号线。</p>
<p><strong>固定优先级</strong><br>总线上的各个设备的优先级一经指定后就不再改变。<br><strong>动态优先级</strong><br>设备使用总线的优先级可以随时间变化。 </p>
<p><strong>集中式总线控制</strong></p>
<p>链式：由近到远的问</p>
<p>计数器：老大自己数，挨个来</p>
<p>独立请求：排队，可以设置优先级</p>
<h2 id="定时"><a href="#定时" class="headerlink" title="定时"></a>定时</h2><p>同步，异步</p>
<p><a href="https://imgtu.com/i/oOCLSe"><img src="https://s4.ax1x.com/2021/12/13/oOCLSe.png" alt="oOCLSe.png"></a></p>
<p><a href="https://imgtu.com/i/oOCXyd"><img src="https://s4.ax1x.com/2021/12/13/oOCXyd.png" alt="oOCXyd.png"></a></p>
<h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><p>冯·诺依曼思想的基本要点：<br>(1)计算机由输入设备、输出设备、运算器、存储器和控制器五大部件组成。<br> CPU：运算器和控制器的统称。<br>计算机主机：CPU与主存储器(内存)的统称。<br>I/O设备：输入设备、输出设备、外存储器的统称为计算机的外部设备，简称为I/O设备。</p>
<p>存储程序方式：在用计算机解题之前，事先编制好程序，并连同所需的数据预先存入主存储器中。</p>
<p>计算机系统分为多级层次结构目的：分清各级层次结构彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。</p>
<p>虚机器：是指用软件技术构成的机器。</p>
<p>总线：一组可为多个功能部件共享的公共信息传送线路。</p>
<p>CPI：执行每条指令所需的平均时钟周期数。</p>
<p>R：R进制的基数，表示数列中各位数字xi（－m≤i≤n－1）的取值范围是0～R－1，并且计数规则是“逢R进一”。<br>Ri：位权值，xiRi表示xi在数列中所代表的实际数值。</p>
<p>机器零：小于机器数最小正数，大于机器数最大负数的数。<br>正溢出：大于机器数最大正数的数。<br>负溢出：小于机器数最小负数的数。<br>因为正溢出和负溢出都表示数的绝对值超出了机器数所能表示的最大绝对值，所以称这类数处于上溢区。<br>因为属于机器零的数均小于机器数所能表示的最小绝对值，所以称这类数处于下溢区。</p>
<p>若[S]原＝Sf.S1S2…Sn，则满足$\frac 1 2 \le |S| \lt 1$的数为规格化数。</p>
<p>若[S]补＝Sf.S1S2…Sn，则满足$\frac 1 2 \le S \lt 1$和$-1 \le S \lt -\frac 1 2$的数为规格化数。</p>
<p>浮点数的机器零：<br>⑴ 如果一个浮点数的尾数为全0，则不论其阶码为何值；<br>⑵ 如果一个浮点数的阶码小于它所能表示的最小数，则不论其尾数为何值；</p>
<p>注意：非规格化数和正、负零的尾数隐含值不是“1”而是“0”。</p>
<p>编码的距离：通常把一组编码中任何两个编码之间代码不同的位数称为这两个编码的距离，也称为海明距离。</p>
<p>码距：在一组编码中任何两个编码之间最小的距离称为这组编码的码距，记作d。</p>
<p>任何一个有效（合法）编码要修改为另一个有效（合法）编码，至少要修改d个数据位</p>
<p>向左破坏规格化：尾数发生溢出。<br>向右破坏规格化：尾数未溢出，但不满足规格化条件。</p>
<p>算术逻辑运算单元（简称ALU）就是一种以加法器为基础的多功能组合逻辑电路。</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算</title>
    <url>/2021/08/24/%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="分布式系统模型和关键技术"><a href="#分布式系统模型和关键技术" class="headerlink" title="分布式系统模型和关键技术"></a>分布式系统模型和关键技术</h1><h2 id="互联网之上的可扩展计算"><a href="#互联网之上的可扩展计算" class="headerlink" title="互联网之上的可扩展计算"></a>互联网之上的可扩展计算</h2><span id="more"></span>

<p>一个并行的、分布式的计算系统使用大量的计算机解决<strong>互联网上的大规模计算</strong>问题。分布式计算的缺点是<strong>数据敏感</strong>和<strong>网络中心化</strong>。 </p>
<h3 id="计算范式间的区别"><a href="#计算范式间的区别" class="headerlink" title="计算范式间的区别"></a>计算范式间的区别</h3><p><strong>集中式</strong>计算:这种计算范式是将所有计算资源集中在一个物理系统之内。所有资源（处理器、内存、存储器）是<strong>全部共享</strong>的，并且紧耦合在一个集成式的操作系统中。</p>
<p><strong>并行</strong>计算：在并行计算中，所有处理器或是<strong>紧耦合于中心共享内存</strong>或是<strong>松耦合于分布式内存</strong>。</p>
<p><strong>分布式</strong>计算：一个分布式系统由众多自治的计算机组成，<strong>各自拥有其私有内存</strong>，通过计算机网络通信。分布式系统中的信息交换通过消息传递的方式完成。</p>
<p><strong>云</strong>计算：一个互联网云的资源可以是集中式的也可以是分布式的。<strong>云</strong>采用<strong>分布式计算或并行计算</strong>，或两者兼有。云可以在集中的或分布式的大规模数据中心之上，由物理的或虚拟的计算资源构建。</p>
<p>普适计算是指在任何地点和时间通过有线或者无线<strong>网络</strong>使用<strong>普遍的设备</strong>进行计算。</p>
<p>物联网是一个日常生活对象（包括计算机、传感器、人等）网络化的连接。物联网通过互联网云实现任何对象在任何地点和时间的普适计算。</p>
<p>互联网计算这一术语几乎涵盖了所有和互联网相关的计算范式。</p>
<h3 id="HPC和HTC系统需要遵从的设计原则"><a href="#HPC和HTC系统需要遵从的设计原则" class="headerlink" title="HPC和HTC系统需要遵从的设计原则"></a>HPC和HTC系统需要遵从的设计原则</h3><p>效率:在HPC系统中开发大规模并行计算时，度量执行模型内资源的利用率。对于HTC系统，效率更依赖于系统的任务吞吐量、数据访问、存储、节能。</p>
<p>可信：度量从芯片到系统到应用级别的可靠性和自管理能力。<strong>目的是提供有服务质量（QoS）</strong>保证的<strong>高吞吐量服务</strong>，即使是失效的情况下。</p>
<p>编程模型适应性：度量在海量数据集和虚拟云资源上各种负载和服务模型下支持数十亿任务请求的能力。</p>
<p>应用部署的灵活性：度量分布式系统能够同时很好地运行在HPC（科学和工程）和HTC（商业）应用上的能力。</p>
<h3 id="可扩展性计算趋势和新的范式"><a href="#可扩展性计算趋势和新的范式" class="headerlink" title="可扩展性计算趋势和新的范式"></a>可扩展性计算趋势和新的范式</h3><p>位级并行（Bit Level Parallelism，BLP）</p>
<p>指令级并行（Instruction Level Parallelism，ILP）。通过指令流水线、超标量计算、VLIW体系结构、多线程实践了ILP。ILP需要分支预测、动态规划、投机预测、提高运行效率的编译支持。</p>
<p>数据级并行（Data Level Parallelism，DLP）的流行源于SIMD和使用向量与数组指令类型的向量机</p>
<p>任务级并行（Task Level Parallelism，TLP）</p>
<p>作业级并行（Job Level Parallelism ，JLP）</p>
<h3 id="物联网和CPS"><a href="#物联网和CPS" class="headerlink" title="物联网和CPS"></a>物联网和CPS</h3><p>物联网是指日常生活中对象、工具、设备或计算机间存在网络互连。物联网为互联了所有我们生活中的对象的无线传感器网络。</p>
<p>CPS是计算过程和物理世界之间交互的结果。<strong>CPS集成了“计算节点”（同构，异构）和“物理”（并发和信息密集的）对象</strong>。CPS在物理世界和信息世界之间将“3C”技术（计算、通信、控制）融合到了一个智能闭环反馈系统中。</p>
<p>物联网强调物理对象之间的多样化连接，而CPS强调物理世界中虚拟现实应用的开发和研究。</p>
<h2 id="并行与分布式相关技术"><a href="#并行与分布式相关技术" class="headerlink" title="并行与分布式相关技术"></a>并行与分布式相关技术</h2><h3 id="多核CPU和多线程技术"><a href="#多核CPU和多线程技术" class="headerlink" title="多核CPU和多线程技术"></a>多核CPU和多线程技术</h3><p><a href="https://imgtu.com/i/4jqrIe"><img src="https://z3.ax1x.com/2021/10/05/4jqrIe.png" alt="4jqrIe.png"></a></p>
<p>现代CPU处理器的5种微体系结构，通过多核和多线程技术支持<strong>ILP</strong>和<strong>TLP</strong></p>
<h4 id="大规模和超大规模GPU计算"><a href="#大规模和超大规模GPU计算" class="headerlink" title="大规模和超大规模GPU计算"></a>大规模和超大规模GPU计算</h4><p>数百或数千处理核心的海量并行处理中协同CPU的GPU使用</p>
<h3 id="系统区域互连"><a href="#系统区域互连" class="headerlink" title="系统区域互连"></a>系统区域互连</h3><p><a href="https://imgtu.com/i/4jL2Y4"><img src="https://z3.ax1x.com/2021/10/05/4jL2Y4.png" alt="4jL2Y4.png"></a></p>
<p>分布式和云计算系统都建立于<strong>大量自治的计算机节点</strong>之上。这些节点通过<strong>SAN、LAN或WAN以层次方式</strong>互连。</p>
<h3 id="虚拟机和虚拟化中间件"><a href="#虚拟机和虚拟化中间件" class="headerlink" title="虚拟机和虚拟化中间件"></a>虚拟机和虚拟化中间件</h3><p>建立大规模集群、网格和云，我们需要以虚拟的方式访问大量的计算、存储和网络化资源。我们需要集群化这些资源，并希望提供一个<strong>单独的系统镜像</strong>。 </p>
<p>分布式计算环境中的虚拟机<strong>复用、挂起、供应和迁移</strong></p>
<h2 id="分布式和云计算系统模型"><a href="#分布式和云计算系统模型" class="headerlink" title="分布式和云计算系统模型"></a>分布式和云计算系统模型</h2><p>分布式和云计算系统都建立于<strong>大量自治的计算机节点</strong>之上。这些节点通过SAN、LAN或WAN以层次方式互连。</p>
<p>大系统被认为高可扩展，并能在物理上或逻辑上达到<strong>Web规模互连</strong>。</p>
<p>大系统被划分为四组：集群、P2P网络、计算网格、大数据中心之上的互联网云。</p>
<p>集群应该<strong>合并多个系统镜像到一个单系统镜像</strong>（SSI）。集群设计者期待一个集群操作系统或者一些中间件<strong>在各个级别支持SSI</strong>。</p>
<h3 id="网格计算"><a href="#网格计算" class="headerlink" title="网格计算"></a>网格计算</h3><p>在过去30年，用户经历了一个从互联网到Web和网格计算服务的自然发展。互联网服务（如Telnet命令）使本地计算机可以连接到一台远程计算机。一个Web服务（如HTTP）使远程访问Web页面成为可能。网格计算被预想用于同时在多台远距离计算机上运行的应用间进行近距离交互。</p>
<p>网格呈现为<strong>集成的计算资源</strong>。它们也可以被视为支持虚拟组织的虚拟平台。</p>
<h3 id="对等网络（P2P）"><a href="#对等网络（P2P）" class="headerlink" title="对等网络（P2P）"></a>对等网络（P2P）</h3><p>客户端服务器体系结构。客户机（PC和工作站）被连接到一个中央服务器，用来进行计算、电子邮件、文件访问和数据库应用。P2P体系结构提供了一个分布式的网络化系统模型。</p>
<p>在一个P2P系统中，每个节点既是客户端又是服务器，提供部分系统资源。</p>
<p>节点机器都是简单的接入互联网的客户机。所有客户机自治、自由地加入和退出系统。不存在主从关系。</p>
<p>无需中心协作或中心数据库。系统是分布式控制下自组织的。</p>
<p>P2P计算在硬件、软件和网络需求上面临三类异构问题。有太多的<strong>硬件模型和体系结构</strong>而无法选择；<strong>软件和操作系统</strong>间不相容；不同的<strong>网络连接和协议</strong>使其过于复杂而较难应用于真实应用。</p>
<h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a><strong>云计算</strong></h3><p>云是虚拟计算机资源池。云可以处理各种不同的负载，包括批处理式后端作业和交互式用户界面应用。</p>
<p>云通过迅速提供虚拟机或物理机允许负载被快速配置和划分。云支持冗余、自恢复、高可扩展编程模型，以允许负载从许多不可避免的硬件/软件错误中恢复。最终，云计算系统可以通过实时监视资源来确保分配在需要时平衡。</p>
<p>基础设施即服务（IaaS）：这个模型将用户需要的基础设施（即<strong>服务器、存储、网络</strong>和数据中心构造）组合在一起。用户可以在使用客户机操作系统的多个虚拟机上配置和运行指定应用。</p>
<p>平台即服务（PaaS）：这个模型使用户能够在一个虚拟的云平台上<strong>配置用户定制的应用</strong>。PaaS包括<strong>中间件、数据库、开发工具</strong>和一些运行时支持（如Web 2.0和Java）。</p>
<p>软件即服务（SaaS）:这是指面向数千付费云用户的初始浏览器的应用软件。<strong>SaaS模型应用于业务流程、工业应用、客户关系管理、企业资源计划、人力资源和合作应用。</strong></p>
<h2 id="分布式系统和云计算软件环境"><a href="#分布式系统和云计算软件环境" class="headerlink" title="分布式系统和云计算软件环境"></a><strong>分布式系统和云计算软件环境</strong></h2><h3 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h3><p><a href="https://imgtu.com/i/4jvtun"><img src="https://z3.ax1x.com/2021/10/05/4jvtun.png" alt="4jvtun.png"></a></p>
<h3 id="已有并行和分布式编程模型"><a href="#已有并行和分布式编程模型" class="headerlink" title="已有并行和分布式编程模型"></a>已有并行和分布式编程模型</h3><p><a href="https://imgtu.com/i/4jvgD1"><img src="https://z3.ax1x.com/2021/10/05/4jvgD1.png" alt="4jvgD1.png"></a></p>
<h3 id="面向服务的体系结构（SOA）"><a href="#面向服务的体系结构（SOA）" class="headerlink" title="面向服务的体系结构（SOA）"></a>面向服务的体系结构（SOA）</h3><p>网格与云服务</p>
<p>网格和云之间的界限近年来变得越来越模糊。对于Web服务，工作流技术用于协调或编排具有指定规范的服务，其中这些规范用于定义关键业务流程模型，如两阶段事务。</p>
<p>网格系统使用<strong>静态资源</strong>，而云强调<strong>弹性资源</strong>。</p>
<p>网格和云之间的不同<strong>仅限于基于虚拟化和自治计算的动态资源管理</strong>。可以通过多个云建立网格。这种网格比一个单纯的云能更好的工作，因为它能<strong>明确支持协议资源分配</strong>。从而可以建立系统的系统，如云之云、云网格、网格云，或互联云作为一个基本SOA体系结构。</p>
<h3 id="分布式和云计算的可扩展性"><a href="#分布式和云计算的可扩展性" class="headerlink" title="分布式和云计算的可扩展性:"></a>分布式和云计算的可扩展性:</h3><p>规模可扩展性：指通过增加机器数量来获取更高的性能和更多的功能。</p>
<p>软件可扩展性：指升级操作系统或编译器，增加数学和工程库，移植新的应用软件，安装更多的用户友好的编程环境。</p>
<p>应用可扩展性：指问题的规模扩展与机器的大小扩展相匹配。</p>
<p>技术可扩展性：指系统可以适应构建技术的变化</p>
<h1 id="虚拟机和集群与数据中心虚拟化"><a href="#虚拟机和集群与数据中心虚拟化" class="headerlink" title="虚拟机和集群与数据中心虚拟化"></a>虚拟机和集群与数据中心虚拟化</h1><h2 id="虚拟化的实现层次"><a href="#虚拟化的实现层次" class="headerlink" title="虚拟化的实现层次"></a>虚拟化的实现层次</h2><p>虚拟化技术通过在同一个硬件主机上<strong>多路复用虚拟机</strong>的方式来共享昂贵的硬件资源，虚拟化的基本思想是分离软硬件以产生更好的系统性能 </p>
<p>  引入虚拟化后，不同用户应用程序由自身的操作系统（即客户操作系统）管理，并且那些客户操作系统可以独立于主机操作系统同时运行在同一个硬件上，这通常是通过新添加一个称为<strong>虚拟化层</strong>的软件来完成，该虚拟化层称为<strong>hypervisor</strong>或虚拟机监视器（Virtual Machine Monitor，<strong>VMM</strong>） </p>
<p><a href="https://imgtu.com/i/5pQyLQ"><img src="https://z3.ax1x.com/2021/10/07/5pQyLQ.md.png" alt="5pQyLQ.md.png"></a></p>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p><a href="https://imgtu.com/i/5pQbw9"><img src="https://z3.ax1x.com/2021/10/07/5pQbw9.png" alt="5pQbw9.png"></a></p>
<h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p><a href="https://imgtu.com/i/5plSyD"><img src="https://z3.ax1x.com/2021/10/07/5plSyD.png" alt="5plSyD.png"></a></p>
<h3 id="供应（恢复）"><a href="#供应（恢复）" class="headerlink" title="供应（恢复）"></a>供应（恢复）</h3><p><a href="https://imgtu.com/i/5plCeH"><img src="https://z3.ax1x.com/2021/10/07/5plCeH.png" alt="5plCeH.png"></a></p>
<h3 id="动态迁移"><a href="#动态迁移" class="headerlink" title="动态迁移"></a>动态迁移</h3><p><a href="https://imgtu.com/i/5pliTA"><img src="https://z3.ax1x.com/2021/10/07/5pliTA.png" alt="5pliTA.png"></a></p>
<h3 id="虚拟化的层级"><a href="#虚拟化的层级" class="headerlink" title="虚拟化的层级"></a>虚拟化的层级</h3><p>指令集体系结构级：代码解释和动态二进制翻译</p>
<p>硬件抽象级：虚拟化一个计算机硬件资源</p>
<p>操作系统级：在单一物理服务器上创建隔离的容器和操作系统实例</p>
<p>库支持级：库接口的虚拟化</p>
<p>应用程序级：进程级虚拟化、高级语言（High Level Language，HLL）虚拟机</p>
<p><a href="https://imgtu.com/i/5plf7d"><img src="https://z3.ax1x.com/2021/10/07/5plf7d.png" alt="5plf7d.png"></a></p>
<h2 id="硬件级虚拟化"><a href="#硬件级虚拟化" class="headerlink" title="硬件级虚拟化"></a>硬件级虚拟化</h2><h3 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h3><p>硬件级虚拟化在真实硬件和传统操作系统之间插入一层软件，该层软件通常称为虚拟机监视器（VMM）</p>
<p>对VMM有三个需求。第一，VMM应该为程序提供与原始硬件机器基本一致的<strong>环境</strong>；第二，运行在该环境中的程序的性能<strong>损失应较低</strong>；第三，<strong>系统资源</strong>应处于VMM的<strong>完全控制</strong>之中。</p>
<p>由VMM完全控制这些资源包括以下方面：(1) VMM负责为<strong>应用程序分配硬件资源</strong>；(2) 程序<strong>不能访问</strong>任何未分配给它的资源；(3) 在某些情况下，VMM可以获得对<strong>已分配资源</strong>的控制权。 </p>
<h3 id="硬件级虚拟化-1"><a href="#硬件级虚拟化-1" class="headerlink" title="硬件级虚拟化"></a>硬件级虚拟化</h3><p>Xen是一个由剑桥大学开发的开源hypervisor程序。Xen属于微内核hypervisor</p>
<p>提供了一种客户操作系统可以直接访问物理设备的机制</p>
<p>Xen提供了一个处于硬件和操作系统之间的虚拟环境</p>
<p>Xen系统的核心组件是hypervisor、内核和应用程序</p>
<p>具有控制特权的客户操作系统称为Domain 0，其他客户操作系统则称为Domain U</p>
<p>Domain 0被首先启动。Domain 0可以直接访问硬件和管理设备。因此，Domain 0的一个任务是为所有Domain U分配和映射硬件资源</p>
<h4 id="硬件虚拟化的两种方式"><a href="#硬件虚拟化的两种方式" class="headerlink" title="硬件虚拟化的两种方式"></a>硬件虚拟化的两种方式</h4><p>全虚拟化</p>
<p>基于主机的虚拟化</p>
<h4 id="全虚拟化的二进制翻译"><a href="#全虚拟化的二进制翻译" class="headerlink" title="全虚拟化的二进制翻译"></a>全虚拟化的二进制翻译</h4><p>客户操作系统和它们的应用由非临界和临界指令构成。</p>
<p>全虚拟化不需要修改主机操作系统。它依赖于<strong>二进制翻译来陷入和虚拟化一些敏感、不可虚拟化的指令的执行。</strong></p>
<h2 id="操作系统级的虚拟化"><a href="#操作系统级的虚拟化" class="headerlink" title="操作系统级的虚拟化"></a>操作系统级的虚拟化</h2><p><strong>操作系统级虚拟化</strong>在一个<strong>操作系统</strong>中插入一个<strong>虚拟化层来划分机器的物理资源。</strong>它使得在一个操作系统内核中可以同时运行多个隔离的虚拟机。这种虚拟机也称为VE（Virtual Execution Environment）、VPS（Virtual Private System，虚拟专用系统）或容器。</p>
<p>从用户的视角来看，VE就像真实服务器。VE有自己的进程、文件系统、用户账号、带有IP地址的网络接口、路由表、防火墙规则及其他个人设置。</p>
<p>尽管VE可为不同用户分别定制，但它们仍共享同一个操作系统内核。因此，操作系统级虚拟化也称为<strong>单操作系统镜像虚拟化</strong>。 </p>
<p>在基于主机的系统虚拟化中，主机操作系统和客户操作系统同时存在，虚拟化软件层处于两者之间。 该主机操作系统仍旧负责管理硬件。客户操作系统安装并运行在虚拟化层之上。特定的应用可运行在虚拟机中。</p>
<h2 id="CPU、内存和I-O设备的虚拟化方法"><a href="#CPU、内存和I-O设备的虚拟化方法" class="headerlink" title="CPU、内存和I/O设备的虚拟化方法"></a>CPU、内存和I/O设备的虚拟化方法</h2><p>为支持虚拟化，处理器利用硬件辅助虚拟化，引入一种特殊的运行模式和指令，使得 VMM和客户操作系统可运行在不同模式中，客户操作系统及其应用程序的所有敏感指令会陷入到VMM中。</p>
<p>虚拟化的硬件支持</p>
<p>现代操作系统和处理器允许多个进程同时运行。如果处理器中没有保护机制，那么不同进程的所有指令都可以直接访问硬件，很容易导致系统崩溃。因此，所有处理器都至少需要两种模式（<strong>用户模式和管理模式</strong>）来确保对<strong>临界区硬件</strong>的<strong>受控访问</strong>。运行在<strong>管理模式</strong>的指令称为<strong>特权指令</strong>，其他指令为<strong>非特权指令</strong>。 </p>
<h4 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h4><p>虚拟机的非特权指令直接在物理主机中运行</p>
<p>关键指令可以分为三类：<strong>特权指令、控制敏感指令和行为敏感指令</strong>。特权指令需要在特权模式中执行，当在特权模式之外执行特权指令时会发生陷入。控制敏感指令尝试改变使用资源的配置。行为敏感指令根据资源的配置情况会有不同的行为，包括在虚拟内存中进行的负载和存储操作。</p>
<p>VMM运行在管理模式时，CPU支持在用户模式运行虚拟机的特权指令和非特权指令，则该CPU体系结构是可虚拟化的。</p>
<p>RISC的所有<strong>控制敏感指令</strong>和<strong>行为敏感指令</strong>都是<strong>特权指令</strong>，因此，RISC的CPU体系结构是天然可虚拟化的。</p>
<h4 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h4><p>客户操作系统和VMM分别维护从虚拟内存到物理内存的映射和从物理内存到机器内存的映射，共两级映射。客户操作系统仍旧负责从虚拟地址到虚拟机的物理内存地址的映射，VMM负责将客户物理内存映射到实际的机器内存上 </p>
<h4 id="多核处理器的虚拟化"><a href="#多核处理器的虚拟化" class="headerlink" title="多核处理器的虚拟化"></a>多核处理器的虚拟化</h4><p>主要有两个困难：一是应用程序编程者必须完全<strong>并行地使用所有处理器核</strong>，二是软件必须明确地<strong>为处理器核分配任务</strong>。</p>
<h2 id="虚拟集群和资源管理"><a href="#虚拟集群和资源管理" class="headerlink" title="虚拟集群和资源管理"></a>虚拟集群和资源管理</h2><h3 id="物理集群与虚拟集群"><a href="#物理集群与虚拟集群" class="headerlink" title="物理集群与虚拟集群"></a>物理集群与虚拟集群</h3><p>虚拟集群由多个客户虚拟机构成，这些客户虚拟机安装在由一个或多个物理集群构成的分布式服务器上。在逻辑上，处于一个虚拟集群的客户虚拟机通过一个跨越了多个物理网络的虚拟网络互连在一起。 </p>
<p>虚拟集群节点可以是<strong>物理机器或虚拟机器</strong></p>
<p><strong>主机操作系统管理物理机器的资源，虚拟机运行其上，并且可以运行与主机相异的操作系统。</strong></p>
<p>使用虚拟机的目的是合并同一台物理服务器的多个功能。</p>
<p>虚拟机可以在多个物理服务器上备份，以提高分布式并行度、容错性，加快灾难恢复速度。</p>
<p>虚拟集群的节点数可以动态增减，与P2P网络中覆盖网络的规模变化类似。</p>
<p>物理节点的失效会使得运行在其上的虚拟机也失效，但是虚拟机的失效不会影响主机系统。</p>
<h3 id="快速部署和有效调度"><a href="#快速部署和有效调度" class="headerlink" title="快速部署和有效调度:"></a>快速部署和有效调度:</h3><p>系统应具备快速部署的能力。快速部署要求如下两点：一是在集群内的<strong>物理节点上尽快构建和发布软件栈</strong>（包括操作系统、库、应用程序）；二是运行时环境可以从一个用户虚拟集群<strong>快速切换</strong>至另一个用户虚拟集群。</p>
<p>虚拟化的另一个优点是在虚拟集群中应用程序的负载均衡。负载均衡可以通过使用负载指数和用户登录频率等指标来完成，虚拟集群的自动伸缩机制可以基于该模型实现。</p>
<h3 id="高性能虚拟存储"><a href="#高性能虚拟存储" class="headerlink" title="高性能虚拟存储"></a>高性能虚拟存储</h3><p>存储体系结构设计可以用于减少虚拟集群分布式文件系统中的复制块</p>
<h3 id="在线迁移虚拟机的步骤与性能影响"><a href="#在线迁移虚拟机的步骤与性能影响" class="headerlink" title="在线迁移虚拟机的步骤与性能影响"></a>在线迁移虚拟机的步骤与性能影响</h3><p>在虚拟集群中，虚拟机客户系统与主机系统并存，并且虚拟机运行在物理主机之上。当一个虚拟机失效时，其角色可被其他节点上的虚拟机替代，只要两个虚拟机运行相同的客户操作系统即可。</p>
<p>一个物理节点可以故障转移至另一个主机的虚拟机上。 </p>
<h3 id="管理虚拟集群共有四种方式"><a href="#管理虚拟集群共有四种方式" class="headerlink" title="管理虚拟集群共有四种方式:"></a>管理虚拟集群共有四种方式:</h3><p>第一种方式是基于<strong>客户的管理器</strong>，其中集群管理器处于客户系统中。在这种管理方式中，多个虚拟机形成一个虚拟集群。</p>
<p>第二种方式是基于<strong>主机的集群管理器</strong>。监督客户系统且能在另一个物理机器上重启客户系统。</p>
<p>第三种方式是在<strong>主机系统和客户系统中使用相互独立的集群管理器</strong>来管理虚拟集群。然而，这会使基础设施管理变得更为复杂。</p>
<p>第四种方式是在<strong>主机系统和客户系统中使用集成的集群</strong>。这表示管理器能区分虚拟资源和物理资源。 </p>
<p>  虚拟机可以从一台物理机器在线迁移至另一台物理机器。发生失效时，一个虚拟机可被另一个虚拟机替代。</p>
<p>虚拟集群可以应用在计算网格、云平台和高性能计算系统中。虚拟集群化的主要吸引力在于它可根据用户需求或节点失效后快速提供动态资源。尤其是，虚拟集群化在云计算中发挥着重要作用。当虚拟机运行在线服务时，在线虚拟机迁移方案的设计目标是最小化如下三个指标：<strong>微小的停机时间、最低的网络带宽消耗及合理的总迁移时间。</strong> </p>
<p>一台虚拟机可能处于如下四种状态之一：<strong>非活跃状态、活跃状态、中止状态、挂起状态。</strong></p>
<p>在线迁移虚拟机包括如下6个步骤 : </p>
<p><a href="https://imgtu.com/i/59nPsJ"><img src="https://z3.ax1x.com/2021/10/07/59nPsJ.png" alt="59nPsJ.png"></a></p>
<h3 id="内存、文件与网络资源的迁移"><a href="#内存、文件与网络资源的迁移" class="headerlink" title="内存、文件与网络资源的迁移"></a>内存、文件与网络资源的迁移</h3><p><strong>内存迁移</strong>：将虚拟机的内存实例从一个物理节点迁移至另一个物理节点</p>
<p><strong>文件系统迁移</strong>：为每个虚拟机提供一个一致的、位置无关的、在所有物理主机上都可访问的文件系统</p>
<p><strong>网络迁移</strong>：迁移虚拟机时应维持所有开放的网络连接，不应依赖原始主机转发或者依赖移动性或重定向机制的支持。</p>
<p>在线迁移机制主要使用预复制的方法，首先传输所有的内存页，然后迭代地只传输上次传输过程中被修改的内存页。 </p>
<h3 id="容器集群的动态部署"><a href="#容器集群的动态部署" class="headerlink" title="容器集群的动态部署"></a>容器集群的动态部署</h3><p><strong>处理速率排队模型和线性模型相结合的反馈控制方法来弹性供应容器，通过自动学习不同到达速率的参考模型并映射输出误差来提高输出误差的准确性。</strong></p>
<p>绝了，老师今年发的顶会，根本不会。。。</p>
<h2 id="数据中心的自动化与虚拟化"><a href="#数据中心的自动化与虚拟化" class="headerlink" title="数据中心的自动化与虚拟化"></a>数据中心的自动化与虚拟化</h2><h3 id="数据中心服务器合并"><a href="#数据中心服务器合并" class="headerlink" title="数据中心服务器合并"></a>数据中心服务器合并</h3><p><strong>服务器合并</strong>采用减少物理服务器数目的方法，是改进硬件资源低利用效率的有效途径。在许多服务器合并技术（如集中合并和物理合并）中，<strong>基于虚拟化的服务器</strong>合并是最有效的合并方式。</p>
<p>数据中心需要优化其资源管理，但是这些服务器合并技术在服务器整机级别进行，很难使资源管理得到有效优化。</p>
<p>合并增强了<strong>硬件利用效率</strong></p>
<p>使资源得到更<strong>灵活的配置和调度</strong></p>
<p>总体拥有<strong>成本得到降低</strong>。</p>
<p>可以改进<strong>可用性和业务连续性</strong> </p>
<h3 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h3><p>在系统虚拟化中，虚拟存储包括由VMM和客户操作系统管理的存储。</p>
<p>存储在该环境中的数据可被分为两类：<strong>虚拟机镜像</strong>和<strong>应用程序数据。</strong></p>
<p>系统虚拟化最重要的方面是<strong>封装和隔离</strong>。传统操作系统和运行其上的<strong>应用程序</strong>可被封装到<strong>虚拟机之中</strong>。在一个虚拟机中仅运行一个操作系统，而该操作系统中则可运行许多应用程序。<strong>系统虚拟化</strong>允许多虚拟机同时运行在一个物理机器上并且<strong>虚拟机之间完全隔离</strong>。</p>
<h3 id="虚拟化数据中心的可信管理"><a href="#虚拟化数据中心的可信管理" class="headerlink" title="虚拟化数据中心的可信管理"></a>虚拟化数据中心的可信管理</h3><p>VMM的出现改变了计算机体系结构。它在<strong>操作系统和系统硬件</strong>之间插入一层软件，可以在一个物理硬件平台上创建一个或多个虚拟机。虚拟机具有良好的<strong>封装性</strong>，运行在虚拟机中的客户操作系统的状态可以被完全封装起来。被封装的机器状态可以复制，也可以在网络上共享，或像文件一样移除，这对虚拟机的安全性提出了挑战。</p>
<p>VMM可提供<strong>安全隔离性</strong>，虚拟机访问任何硬件资源时都需要通过VMM的审核，因此VMM是一个虚拟系统的安全基础。 </p>
<h1 id="云平台、面向服务的体系结构和云编程"><a href="#云平台、面向服务的体系结构和云编程" class="headerlink" title="云平台、面向服务的体系结构和云编程"></a>云平台、面向服务的体系结构和云编程</h1><h2 id="服务模型和目标"><a href="#服务模型和目标" class="headerlink" title="服务模型和目标"></a>服务模型和目标</h2><h3 id="云计算服务模型"><a href="#云计算服务模型" class="headerlink" title="云计算服务模型"></a>云计算服务模型</h3><p>用户可以在全球任意位置以极具竞争力的成本访问和部署云应用。<br>虚拟化的云平台常常构建在<strong>大规模数据中心之上</strong>。<br>云致力于通过自动化的硬件、数据库、用户接口和应用程序环境把它们<strong>结构化为虚拟资源</strong>，来驱动下一代的数据中心。<br>云渴望通过<strong>自动化的资源配置构建更好的数据中心</strong>。</p>
<h3 id="云计算平台的特点"><a href="#云计算平台的特点" class="headerlink" title="云计算平台的特点"></a>云计算平台的特点</h3><p>云计算会大大降低小型用户及大型企业的成本。<br>无需预先购买昂贵计算机而节约的成本在很大程度上减轻了创业型公司的经济负担。<br>云用户只需支付操作费用、无需投入固定设备的事实吸引了大量的小型用户<br>对大部分企业和繁重的计算机用户来讲极具吸引力。<br>任何IT用户，若其资本支出压力大于操作费用，都应考虑将他们超出负荷的工作交给效用计算或云服务提供商。 </p>
<h3 id="云计算平台的设计目标"><a href="#云计算平台的设计目标" class="headerlink" title="云计算平台的设计目标"></a>云计算平台的设计目标</h3><p>将计算<strong>从桌面移向数据中心</strong>  计算处理、存储与软件发布<strong>从桌面和本地服务器移向互联网数据中心。</strong><br><strong>服务配置和云效益</strong>  提供商供应云服务时必须与消费者和终端用户<strong>签署服务等级协议</strong>（SLA）。<br><strong>性能可扩展性</strong>  云平台、软件和基础设施服务必须能够根据用户数的增长而相应扩容。<br><strong>数据隐私保护</strong>  能否信任数据中心处理个人数据和记录呢？云要成为可信服务必须妥善解决该问题。<br><strong>高质量的云服务</strong>  云计算的<strong>服务质量必须标准化</strong>，这才能使得云可以在多个提供商之间进行互操作。<br><strong>新标准和接口</strong>  主要解决与数据中心或云提供商相关的数据锁定问题。</p>
<h2 id="公有云、私有云和混合云"><a href="#公有云、私有云和混合云" class="headerlink" title="公有云、私有云和混合云"></a>公有云、私有云和混合云</h2><p>云计算的概念从<strong>集群</strong>、<strong>网格</strong>和<strong>效用计算</strong>发展而来。<br><strong>集群和网格计算并行使用大量计算机可以解决任何规模的问题。效用计算和SaaS（Software as a Service）将计算资源作为服务进行按需付费。云计算利用动态资源为终端用户传递大量服务。</strong><br>云计算是一种高吞吐量计算范式，它通过大的数据中心或服务器群提供服务。云计算模型使得用户可以随时随地通过他们的互连设备访问共享资源。</p>
<p>云应用的所有计算任务被分配到<strong>数据中心的服务器上</strong>。这些服务器主要是虚拟集群的虚拟机，由数据中心资源产生出来。<br>云平台是通过<strong>虚拟化分布的系统</strong>。<br>公有云和私有云都是<strong>在互联网上开发</strong>的。<br>公有云构建在互联网之上，任何已付费的用户都可以访问。公有云属于服务提供商，用户通过订阅即可访问。<br>私有云构建在局域网内部，属于一个独立的组织。由客户管理，而且其可访问范围限制在所属客户及其合作者之中。<br>混合云由公有云和私有云共同构成 </p>
<p><strong>公有云促进了标准化</strong>，节约了资金投入，为应用程序提供了很好的灵活性；私有云尝试进行定制化，可以提供更高的有效性、弹性、安全性和隐私性；混合云则处于两者中间，在资源共享方面进行了折中。<br><strong>云的核心是服务器集群</strong>（或虚拟机集群）。集群节点用作计算节点，少量的控制节点用于管理和监视云活动。用户作业的调度需要为用户创建的虚拟集群分配任务。 </p>
<h2 id="基础设施即服务-IaaS"><a href="#基础设施即服务-IaaS" class="headerlink" title="基础设施即服务(IaaS)"></a>基础设施即服务(IaaS)</h2><p>云计算将基础设施、平台和软件作为服务发布，使得用户能够以即用即付的模式使用基于定阅的服务。<br>在云上提供的服务通常可以分为三个不同的服务模型，即IaaS、PaaS（平台即服务）和SaaS（软件即服务）。<br>SaaS由用户或客户使用特殊的接口，用在应用程序端；在PaaS层，云平台必须进行计费服务，处理作业队列，启动和监视服务；底层是IaaS服务，需要配置数据库、计算实例、文件系统和存储以满足用户需求。<br>IaaS模型包括<strong>存储即服务、计算实例即服务和通信即服务</strong>。</p>
<h2 id="平台即服务-PaaS"><a href="#平台即服务-PaaS" class="headerlink" title="平台即服务 (PaaS)"></a>平台即服务 (PaaS)</h2><p>平台云是一个由硬件和软件基础设施构成的集成的计算机系统，可以在这个虚拟化的云平台上使用提供商（如Java、Python、NET）支持的一些编程语言和软件工具<strong>开发用户应用程序</strong>。<br>用户不需要管理底层的云基础设施。云提供商支持用户在一个定义良好的服务平台上进行应用程序的开发和测试。<br>该PaaS模型使得来自世界不同角落的用户<strong>可以在一个统一的软件开发平台上协同工作</strong>。该模型也鼓励第三方组织提供软件管理、集成和服务监视解决方案。</p>
<h2 id="软件即服务-SaaS"><a href="#软件即服务-SaaS" class="headerlink" title="软件即服务 (SaaS)"></a>软件即服务 (SaaS)</h2><p>软件即服务是指上千的云客户通过浏览器访问的应用程序软件。<br>PaaS提供的服务和工具 用于构建应用程序和管理它们所部署的由IaaS提供的资源。<br>SaaS模型<strong>将软件应用程序作为服务进行提供</strong>。对客户来讲，无需为服务器或软件预先投资；对提供商来讲，与传统的用户应用程序托管相比成本很低。<br>为支持PaaS和IaaS，客户数据存储在云中，云或者是专门的提供商，或者是公开地托管。 </p>
<h2 id="公有云平台：GAE、AWS和Azure"><a href="#公有云平台：GAE、AWS和Azure" class="headerlink" title="公有云平台：GAE、AWS和Azure"></a>公有云平台：GAE、AWS和Azure</h2><p>云的5个使用层次。<strong>在顶层，个人用户和组织用户请求的服务非常不同。SaaS层的应用程序提供商主要服务个人用户。大部分商业组织由IaaS和PaaS提供服务。</strong>IaaS为应用程序和组织用户提供计算、存储和通信资源。云环境由PaaS或平台提供商定义。<br>云服务依赖于机器虚拟化、SOA、网格基础设施管理和节能方面的新进展。客户购买如前所述的IaaS、PaaS或SaaS服务。<br>提供商提供的服务费用通常远低于用户频繁更换废弃的服务器的成本。 </p>
<h3 id="谷歌应用引擎（GAE）"><a href="#谷歌应用引擎（GAE）" class="headerlink" title="谷歌应用引擎（GAE）"></a>谷歌应用引擎（GAE）</h3><p>谷歌有世界上最大的搜索引擎设备。公司在大规模数据处理方面具有丰富的经验，这使得其在数据中心设计中视点新颖，且其提出的新的编程模型可适应的规模令人吃惊。<br>谷歌平台基于它的搜素引擎专家，如前所述的MapReduce，该基础设施也适用于许多其他领域。谷歌有上百个数据中心，在全世界安装了460 000多台服务器。<br>数据项存储在文本、图像和视频中，并且出于容错和故障考虑而进行了备份处理。这里我们讨论谷歌的应用程序引擎（GAE），它提供了一个支持不同的云和Web应用的PaaS平台。 </p>
<p>谷歌的云计算应用程序的构成要素包括存储大量数据的GFS、为应用程序开发者提供的MapReduce编程框架、用于分布式应用程序锁服务的Chubby和为访问结构化或半结构化数据的BigTable存储服务。<br>GAE可以看做是许多软件组件的集合。前端是应用程序框架，类似于其他Web应用框架，如ASP、J2EE和JSP。目前，GAE可以支持Python和Java编程环境。应用程序可以像Web应用程序容器一样运行。前端可以用做动态Web服务基础设施，可以提供对公共技术的完整支持。 </p>
<h3 id="微软的Windows-Azure"><a href="#微软的Windows-Azure" class="headerlink" title="微软的Windows Azure"></a>微软的Windows Azure</h3><p>在2008年，微软发布了一个Windows Azure平台来应对云计算所遇到的挑战。该平台构建在微软的数据中心之上。<br>该平台可以分为三个主要的组件平台。Windows Azure提供了一个构建在Windows操作系统之上并基于微软虚拟化技术的云平台。<br>应用程序安装在部署在数据中心服务器上的虚拟机之上。Azure管理数据中心中所有的服务器、存储器和网络资源。在这些基础设施之上是构建不同云应用的各种服务。 </p>
<p>Live服务：用户可以访问微软Live应用，并跨越多台机器并行地使用所包括的数据。<br>.NET服务：支持应用程序在本地主机上开发、在云机器上执行。<br>SQL Azure：更易于用户访问和使用与云中SQL服务器相关的关系型数据库。<br>SharePoint服务：为用户提供了一个可伸缩和可管理的平台，可以在更新的Web服务上开发他们自己特定的商业应用。<br>动态CRM服务：为软件开发者提供了一个商业平台，可以在金融、市场、销售和促销方面管理CRM应用。</p>
<h2 id="云平台管理"><a href="#云平台管理" class="headerlink" title="云平台管理"></a>云平台管理</h2><h3 id="扩展的云计算服务"><a href="#扩展的云计算服务" class="headerlink" title="扩展的云计算服务"></a>扩展的云计算服务</h3><p>6层的云服务，范围从<strong>硬件、网络和配置</strong>到基础设施、平台和软件应用。我们已经分别介绍了SaaS、PaaS和IaaS上面这三个服务层。<br>云计算平台提供的PaaS位于IaaS的基础设施顶端。顶层提供SaaS 。这些都必须所提供的云平台上实现。<br>虽然三个基本模型用法不同，<strong>但它们是逐层建立的</strong>。言外之意是，没有云平台，就没有SaaS应用。如果计算和存储基础设施不存在，就不能构建云平台。</p>
<h3 id="云成员类型"><a href="#云成员类型" class="headerlink" title="云成员类型"></a>云成员类型</h3><p>云成员可以分为三大类： （1）云服务提供商和IT管理员，（2）软件开发商或供应商， （3）终端用户或企业用户。在IaaS、PaaS和SaaS模式下，这些云成员作用不同。</p>
<p>  从软件厂商的角度来看，一个给定的云平台的<strong>应用性能</strong>是最重要的。从供应商的角度来看，云计算基础<strong>设施性能</strong>最重要。从终端用户的角度来看，<strong>服务质量</strong>（包括安全性）是最重要的。 </p>
<h3 id="运行时支持服务"><a href="#运行时支持服务" class="headerlink" title="运行时支持服务"></a>运行时支持服务</h3><p>在集群环境中，也有一些云计算环境下的运行时支持服务。<strong>集群监控用于收集整个集群的运行时状态</strong>。<br><strong>根据节点的可用性，调度器将提交给整个集群的任务排序，并将任务分配给处理节点，云应用的分布式调度器具有支持云应用程序的特性，如调度用MapReduce风格编写的程序。运行时支持系统使云集群以高效率正常运作。</strong><br>成千上万的云客户使用用浏览器启动的应用程序，运行这种应用程序时，软件需要运行时支持。 SaaS模式是让用户租用软件应用程序，而不是购买软件。 </p>
<h3 id="资源调度方法"><a href="#资源调度方法" class="headerlink" title="资源调度方法"></a>资源调度方法</h3><p>资源调度的三种方法：（1）<strong>需求驱动方法提供静态资源</strong>；（2）<strong>事件驱动方法基于不同时期预测的工作负载而定</strong>；（3）<strong>人气驱动方法基于互联网流量监测。</strong> </p>
<h4 id="基于负载预测的资源分配方法"><a href="#基于负载预测的资源分配方法" class="headerlink" title="基于负载预测的资源分配方法"></a>基于负载预测的资源分配方法</h4><p>这种方法用于添加或删除基于特定时间事件的机器实例。该方案对季节性事件或预测事件（如在西方的圣诞节和东方的农历新年）效果更好。在这些特殊事件发生期间，用户数的增长与减少是可以预测的。这种方法预测事件发生前的流量高峰。如果事件的预测正确，这种方法会导致最少量的服务质量损失；否则，由于不遵循一种固定模式的事件，浪费的资源可能更大。主要采用的方法包括：<strong>基于时间序列分析、机器学习和深度学习的负载预测方法</strong> </p>
<h4 id="基于阈值的资源分配方法"><a href="#基于阈值的资源分配方法" class="headerlink" title="基于阈值的资源分配方法"></a>基于阈值的资源分配方法</h4><p>这种方法<strong>基于已分配资源的利用水平来添加或移除资源配置量</strong>。当用户使用一个Xeon处理器超过持续期时间的60%时，需求驱动方法自动为用户的应用程序分配两个Xeon处理器。一般情况下，当资源已超过某一时间阈值时，该方案将根据需求增加资源。当资源低于某一时间阈值时，资源也可相应减少。亚马逊在其 EC2 平台实现了这种自动缩放功能。这种方法比较容易实现。<strong>如果工作负载突然改变，本方法无法实现。</strong></p>
<h4 id="基于排队模型的资源分配方法"><a href="#基于排队模型的资源分配方法" class="headerlink" title="基于排队模型的资源分配方法"></a>基于排队模型的资源分配方法</h4><p><strong>假设任务到达间隔符合一定分布，例如负指数分布</strong><br><strong>服务时间长度也符合一定的分布，例如负指数分布</strong></p>
<h4 id="基于反馈控制的资源分配方法"><a href="#基于反馈控制的资源分配方法" class="headerlink" title="基于反馈控制的资源分配方法"></a>基于反馈控制的资源分配方法</h4><p><strong>排队模型不准确性</strong><br><strong>建立反馈控制系统</strong></p>
<h3 id="分布式存储资源"><a href="#分布式存储资源" class="headerlink" title="分布式存储资源"></a>分布式存储资源</h3><p><strong>数据存储层构建在物理服务器或虚拟服务器的顶部</strong>。由于云计算应用程序通常为用户提供服务，因此不可避免地要将数据存储在云提供商的集群中。该服务可以在世界任何地方被访问。电子邮件系统就是一个例子。另一个例子是Web搜索应用。在存储技术方面，未来可能用固态驱动器增强硬盘驱动器。这将提供可靠的和高性能的数据存储。</p>
<h4 id="虚拟机模板"><a href="#虚拟机模板" class="headerlink" title="虚拟机模板"></a>虚拟机模板</h4><p>包含虚拟机的如下信息：<br>要分配给虚拟机的核或处理器的数目。<br>虚拟机要求的内存量。<br>用于启动虚拟机的操作系统内核。<br>包含虚拟机文件系统的磁盘镜像。<br>每小时使用虚拟机的价格。</p>
<h4 id="分布式虚拟机管理"><a href="#分布式虚拟机管理" class="headerlink" title="分布式虚拟机管理"></a>分布式虚拟机管理</h4><p>分布式虚拟机管理器向虚拟机发出请求并查询它们的状态。这个管理器借助用户应用程序从网关请求虚拟机。管理器从网关获取被请求的虚拟机的列表。此列表包含为每个带有安全 Shell (SSH) 隧道的虚拟机分配的公用 IP/专用 IP 地址。<br>本地网关会尝试从底层 VIE 获取资源。当一个网关安排虚拟机时，它将访问信息发送给请求者网关。最后，<strong>管理器配置虚拟机、 设置 SSH 通道，并在虚拟机上执行任务。根据对等的政策，每个网关调度器使用保守的回填来安排请求。当调度器不能立即使用本地资源启动请求时，将启动重定向算法。</strong> </p>
<h2 id="云安全与信任管理"><a href="#云安全与信任管理" class="headerlink" title="云安全与信任管理"></a>云安全与信任管理</h2><p>需要的三个基本的云安全强制策略分别为：</p>
<p><strong>数据中心的设施安全要求全年的在线安全</strong>，为此通常会部署生物扫描器、CCTV（闭路电视）、移动探测；<br><strong>网络安全要求容错外部防火墙、入侵检测系统和第三方漏洞评定</strong>；<br><strong>平台安全要求SSL和数据解密、严格的密码策略和系统信任认证。</strong></p>
<h3 id="虚拟机的安全挑战"><a href="#虚拟机的安全挑战" class="headerlink" title="虚拟机的安全挑战"></a>虚拟机的安全挑战</h3><pre><code>安全感知的云体系结构必须具备安全措施。基于恶意软件的攻击（如网络蠕虫、病毒和DDoS攻击）利用系统漏洞，损害了系统功能或为侵入者提供了对敏感信息的非授权访问。
这里是一些需要特殊安全保护的云组件：
</code></pre>
<p>保护服务器免受蠕虫、病毒等恶意软件的攻击。<br>保护虚拟机hypervisor免受基于软件的攻击和漏洞问题。<br>保护虚拟机和监视器免受服务中断和拒绝服务攻击。<br>保护数据和信息免受失窃、损坏和自然灾害等意外。<br>提供对关键数据和服务的认证和授权访问。</p>
<h3 id="分布式入侵-异常检测"><a href="#分布式入侵-异常检测" class="headerlink" title="分布式入侵/异常检测"></a>分布式入侵/异常检测</h3><p><strong>在所有云模型中，数据安全是弱链。</strong>使用公共API工具处理<strong>数据互锁问题和网络攻击</strong>或弊病需要新的云安全标准。<br>安全威胁可能主要针对运行在云之上的虚拟机、客户操作系统和软件。<strong>入侵检测系统则尝试阻止攻击发挥作用。签名匹配和异常检测系统可以在用于建造入侵检测系统的虚拟机上实现</strong>。签名匹配的入侵检测技术更为成熟，但需要频繁更新签名数据库。网络异常检测则根据正常流量模式检测不正常的交通模式，例如一段未授权的TCP连接序列。分布式入侵检测系统需要防止这两类入侵。</p>
<h1 id="面向服务的分布式体系结构"><a href="#面向服务的分布式体系结构" class="headerlink" title="面向服务的分布式体系结构"></a>面向服务的分布式体系结构</h1><h2 id="面向服务的体系结构（SOA）-1"><a href="#面向服务的体系结构（SOA）-1" class="headerlink" title="面向服务的体系结构（SOA）"></a>面向服务的体系结构（SOA）</h2><p>SOA是关于如何设计<strong>一套使用服务的软件系统</strong>，<strong>使其通过已发布或可发现的接口使用新的或已有的应用</strong>。这些应用程序通常发布在网络上。<br>SOA还旨在使得服务的互操作性变得可扩展和有效。它提示支持这一目标的体系结构风格，如松耦合、发布的接口和标准的通信模型。<br>万维网联盟（World Wide Web Consortium，W3C）定义SOA为一种分布式系统体系结构</p>
<p><strong>SOA具有以下典型属性：</strong></p>
<p><strong>逻辑视图</strong>：<strong>SOA是实际程序、数据库、商业流程等的抽象逻辑视图</strong>，定义了它所做的事情，通常执行企业级的操作。服务是依据提供商代理和请求者代理之间交换的消息来形式化定义。<br><strong>基于消息</strong>：<strong>提供商和请求者的内部结构包括实现语言、进程结构和数据库结构</strong>。这些特征在SOA中都经过精心抽象化：使用SOA的架构，一个人不必也不需要知道实现服务的代理是如何构造的。可以将任何软件组件或应用程序“包装”在消息处理代码中，并使它完全符合形式化的服务定义。</p>
<p><strong>基于描述</strong>： <strong>服务由机器可执行的元数据来描述</strong>。这个描述支持SOA的公开本质：描述中只包括那些公开可访问的并对于服务应用来说很重要的细节。服务语义应通过其描述直接或间接地文档化。</p>
<p><strong>粒度</strong>： 服务倾向于使用较<strong>少数量的操作</strong>，<strong>使用大而复杂的消息</strong>。<br><strong>网络方向</strong> ：服务往往是在<strong>网络上沿着使用的方向</strong>，尽管这不是一个必需的要求。<br><strong>平台中立性</strong>：消息按照平台中立性、标准化的格式通过接口发送。<strong>XML</strong>是满足这个约束条件的最显然格式。</p>
<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><p>在SOA范式中，软件能力以基于消息的通信模型通过松耦合、可重用、粗粒度、可发现和自我包含的服务来传递和使用。<br> <strong>Web已经成为一种利用应用程序来连接远程客户端的媒介</strong>。<br>术语“Web服务”经常指那些<strong>自我包含的、自我描述的、模块化的应用程序，它们被设计来供网络上的其他软件程序使用或访问</strong>。一旦部署了一个Web服务，其他的应用和Web服务就可以发现并激活已经部署的服务<br><strong>Web服务是SOA实现的最常见实例之一</strong>。W3C工作组将Web服务定义为一个<strong>软件系统，支持网络上机器到机器的互操作交互</strong>。 </p>
<h3 id="组成目前Web服务核心的技术"><a href="#组成目前Web服务核心的技术" class="headerlink" title="组成目前Web服务核心的技术"></a>组成目前Web服务核心的技术</h3><p><strong>简单对象访问协议（SOAP）提供了一个标准的封装结构，用来在各种不同的互联网协议（如SMTP、HTTP和FTP）上传输XML文档。</strong>通过使用这样的标准消息格式，异构的中间件系统可以实现互操作。<br><strong>Web服务描述语言（WSDL）描述了接口，即Web服务支持的一系列标准格式的操作。</strong>它标准化了操作的输入和输出参数的表示以及服务的协议绑定，消息在线传输的方式。使用WSDL，不同的客户端可以自动理解如何与Web服务交互。<br><strong>通用描述、发现和集成（UDDI）</strong> universal description discover integrate<strong>提供了一种通过搜索名称、标识符、类别或Web服务实现的规范来广告和发现Web服务的全局注册表。</strong></p>
<p>UDDI（统一描述发现和集成）规范通过创建一个平台无关的开放框架定义了一种描述、发布和发现关于Web服务信息的方法。UDDI提供了名字服务和目录服务来通过名字或<strong>特定的属性查找服务描述</strong>。版本3.0成为OASIS的公共服务注册表标准。<br><strong>UDDI规范集中在一批服务的定义</strong>，它们支持以下内容的描述和发现：商业、组织和其他Web服务提供商；它们提供的Web服务；以及用来访问那些服务的技术接口。<br>注册表主要有两类：<strong>公共注册表</strong>，这是一个逻辑的集中式分布服务，彼此之间在一个约定的基础上复制数据；<strong>私有注册表</strong>，仅仅在单个的组织内部访问，或被一群有特定目的的商业伙伴所共享。 </p>
<h3 id="WS-I协议栈"><a href="#WS-I协议栈" class="headerlink" title="WS-I协议栈"></a>WS-I协议栈</h3><p><a href="https://imgtu.com/i/5lZhw9"><img src="https://z3.ax1x.com/2021/10/14/5lZhw9.png" alt="5lZhw9.png"></a></p>
<p><a href="https://imgtu.com/i/5lett1"><img src="https://z3.ax1x.com/2021/10/14/5lett1.png" alt="5lett1.png"></a></p>
<p><strong>SOAP消息包含应用程序使用的一个信封，里面封装了需要发送的消息。</strong>信封包括头和体模块。编码风格元素指的是XML模式的URI地址，用于对消息元素进行编码。<br><strong>SOAP消息中的每个元素可以采用不同的编码方式</strong>，但是除非特别指定，整个消息的编码方式定义在根元素的XML模式中。头部是SOAP消息的可选部分，它包含了上面提到的辅助信息，在这个例子中没有包含头部。<br><strong>SOAP请求-响应消息的体部分包含了会话的主要信息，它是由一个或多个XML模块来组成的。</strong> </p>
<h2 id="企业多层体系结构"><a href="#企业多层体系结构" class="headerlink" title="企业多层体系结构"></a>企业多层体系结构</h2><p><strong>企业应用程序通常使用多层体系结构来封装和集成各种功能。</strong><br>多层体系结构是一种<strong>客户端/服务器体系结构</strong>，<strong>其中表述、应用处理和数据管理是逻辑分离的过程</strong>。已知最简单的多层体系结构是两层，也就是客户端/服务器系统。传统的两层客户端/服务器模型需要集群化和灾难恢复来保证可靠性。虽然在企业中使用较少的节点会简化可管理性，但是改变管理仍然很困难，因为在修理、升级和部署新应用时，都需要服务器下线。而且在胖客户端环境下，新应用和增强的部署非常复杂和消耗时间，从而降低了可用性。 </p>
<p>一个三层的信息系统包含以下的层次：</p>
<p><strong>表述层</strong>  向外部实体描述信息，并且允许它们通过提交操作和获得响应来与系统进行交互。<br><strong>商业/应用逻辑层或中间件</strong>  通过表述层完成客户端请求的实际操作的程序。中间层也可以控制用户的认证、访问资源，以及完成一些客户端查询处理，这样可以减少数据库服务器的一些负载。<br><strong>资源管理层也称为数据层</strong>  处理和实现信息系统的不同数据源。</p>
<p><a href="https://imgtu.com/i/5l3M1s"><img src="https://z3.ax1x.com/2021/10/14/5l3M1s.md.png" alt="5l3M1s.md.png"></a></p>
<h2 id="网格服务和OGSA"><a href="#网格服务和OGSA" class="headerlink" title="网格服务和OGSA"></a>网格服务和OGSA</h2><p><strong>开放网格服务体系结构</strong>（OGSA）旨在为基于网格的应用定义一个通用的、标准的和开放的体系结构。可以成为基于服务的网格。OGSA的意图在于：<br><strong>便于在分布式的异构环境上使用和管理资源。</strong><br>提供无缝的服务质量。<br>为了<strong>提供不同资源之间的互操作性，定义开放的发布接口。</strong><br>采用工业标准的集成技术。<br>开发实现互操作性的标准。<br>在分布式的异构环境中集成、虚拟化和管理各种服务与资源。<br>提供松耦合的可交互服务，并且满足工业可接受的Web服务标准。</p>
<h3 id="OGSA体系结构服务："><a href="#OGSA体系结构服务：" class="headerlink" title="OGSA体系结构服务："></a>OGSA体系结构服务：</h3><p><strong>基础设施服务</strong>  指一系列的公共功能。<br><strong>运行管理服务</strong>  与启动和管理任务这些问题有关。<br><strong>数据管理服务</strong>  用来移动数据到需要它的地方、维护复制的副本、运行查询和更新，以及转换数据到新的格式。<br><strong>资源管理服务</strong>  为网格资源提供管理功能。<br><strong>安全服务</strong>  便于一个（虚拟的）组织内有关安全的策略得以强制执行，支持安全的资源共享。<br><strong>信息服务</strong>  提供关于网格及其构成资源信息的有效产生和访问。<br><strong>自我管理服务</strong>  支持对于一系列服务(或者资源)的服务级实现，并且要尽可能的自动化。</p>
<h3 id="Web服务资源框架（WSRF）"><a href="#Web服务资源框架（WSRF）" class="headerlink" title="Web服务资源框架（WSRF）"></a>Web服务资源框架（WSRF）</h3><p>Web Services Resources Framework</p>
<p>为了实现有状态的Web服务而提出的一个标准：Web服务的状态保存在资源中，web服务和资源的映射由WS-resource管理。资源的寻址由WS-Adressing规范实现。</p>
<p><a href="https://imgtu.com/i/5lN8BR"><img src="https://z3.ax1x.com/2021/10/14/5lN8BR.png" alt="5lN8BR.png"></a></p>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST是应用于分布式系统的软件体系结构风格，尤其是像万维网这样的分布式超媒体系统。 </p>
<p>REST体系结构风格基于以下四项原则：<br><strong>通过URI的资源标识</strong>：REST的Web服务公开了一组资源，标识了与其客户端进行交互的目标。REST中信息的关键抽象是资源。<br><strong>统一的受限接口</strong>：通过客户端/服务器可缓存的协议HTTP标准来完成与REST风格的Web服务进行交互。<br><strong>自我描述的消息</strong>：REST消息包含足够的信息来描述如何处理消息。这使得中介机构不需要解析消息内容就可以对消息进行更多的操作。<br><strong>无状态的交互</strong>： REST的交互是“无状态的”，意味着消息的含义不依赖于会话状态。 </p>
<p><a href="https://imgtu.com/i/5lgDWd"><img src="https://z3.ax1x.com/2021/10/14/5lgDWd.png" alt="5lgDWd.png"></a></p>
<h2 id="语义Web"><a href="#语义Web" class="headerlink" title="语义Web"></a>语义Web</h2><p><strong>语义Web是关于自动化发现和集成的</strong>：给数据增加机器可处理的语义，这样计算机可以理解这些信息并代表终端用户处理它，从而基于为Web页面附加丰富元数据而使Web搜索和链接更加智能。<br>语义Web旨在提供一个环境，在里面软件代理能够动态地发现、询问和互操作资源并代替人执行复杂的任务 </p>
<p>为了达到这一目的，已经进行了很多工作来保证在公共数据模型——资源描述框架（RDF）中Web资源的含义，RDF使用以公共语言（如OWL Web本体语言）表示的一致本体论，这样我们可以共享元数据，并且增加到背景知识中。<br>从这个基础上，我们应该可以<strong>查询、过滤、集成和聚集元数据</strong>，并应用规则和策略在它的上面推理出更多的元数据。<br><strong>RDF是为语义Web开发的第一个语言</strong>，使用XML来表示Web上资源的信息（包括元数据）。RDF使用Web标识符（URI），并且从简单的属性和属性值方面来描述资源。OWL是拓展了RDF模式的一个描述性本体语言。</p>
<h2 id="面向服务的体系结构中的工作流"><a href="#面向服务的体系结构中的工作流" class="headerlink" title="面向服务的体系结构中的工作流"></a>面向服务的体系结构中的工作流</h2><h3 id="工作流的基本概念"><a href="#工作流的基本概念" class="headerlink" title="工作流的基本概念"></a>工作流的基本概念</h3><p>工作流是“对服务之间交互进行编程”的方法。同称呼工作流描述了“为Web或网格编程”一样，我们也可以使用诸如“软件协调”、“服务编排”、“服务或过程协调”、“服务会话”、“Web或网格脚本”、“应用集成”或“软件总线”之类的名字。</p>
<p>必须注意工作流意味着分布式系统的两层编程模型。基本服务采用传统语言（C、C++、Fortran、Java、Python）进行编程，<strong>工作流描述了服务之间彼此交互的粗粒度编程</strong>。每一个服务使用传统的语言进行编程，而它们之间的交互用工作流描述。</p>
<h3 id="工作流体系结构和规范"><a href="#工作流体系结构和规范" class="headerlink" title="工作流体系结构和规范"></a>工作流体系结构和规范</h3><p>大多数工作流系统都有两个关键组件<br>工作流描述规范<br>工作流运行引擎</p>
<p>一般的工作流结构<strong>是有向无环图</strong>，它是顶点和有向边的集合，每一条边从一个节点连到另一个，这样里面没有环。也就是说，从某一个顶点V开始，沿着一系列的边，最终不可能再回到顶点V。<br>除了复杂的专业工作流系统外，可能使用传统语言和工具集的脚本是构建工作流的主要技术。通常这可以使用任何分布式计算（互联网）支持的环境以非正式的方式实现<br>最复杂的工作流系统支持层次化规范，即工作流的节点可以是服务或服务集（子工作流）。这和网格的网格概念一致。 </p>
<h1 id="云编程-MapReduce"><a href="#云编程-MapReduce" class="headerlink" title="云编程 MapReduce"></a>云编程 MapReduce</h1><h2 id="并行和分布式编程范式"><a href="#并行和分布式编程范式" class="headerlink" title="并行和分布式编程范式"></a>并行和分布式编程范式</h2><p>我们把并行和分布式程序定义为运行在多个计算引擎或一个分布式计算系统上的并行程序。这个术语包含计算机科学中的两个基本概念：分布式计算系统和并行计算。<strong>分布式计算系统是一系列由网络连接的计算引擎，它们完成一个共同目标：运行一个作业或者一个应用</strong>。计算机集群或工作站网络就是分布式计算系统的一个实例。并行计算是同时<strong>运用多个计算引擎（并不一定需要网络连接）来运行一个作业或者一个应用。</strong> </p>
<h3 id="并行和分布式编程范式需要考虑的因素"><a href="#并行和分布式编程范式需要考虑的因素" class="headerlink" title="并行和分布式编程范式需要考虑的因素"></a>并行和分布式编程范式需要考虑的因素</h3><p>由多个网络节点或者工作机组成用并行或分布式方式来运行并行程序，该系统包括以下方面 :<br>1.<strong>分区</strong>：分区适用于计算和数据两方面：<br><strong>计算分区</strong>：计算分区是把一个给定的<strong>任务或者程序分割成多个小任务</strong>。分区过程很大程度上依靠正确识别可以并发执行的作业或程序的每一小部分。<br><strong>数据分区</strong>：数据分区是把输入或中间<strong>数据分割成更小的部分</strong>。类似地，一旦识别出输入数据的并行性，它也可以被分割成多个部分，能在不同的工作机上运行。数据块可由程序的不同部分或者同一程序的副本来处理。 </p>
<p>2.<strong>映射</strong>：映射是把更<strong>小的程序部分或者更小的数据分块分配给底层的资源</strong>。这个过程的目的在于合理分配这些部分或者分块，使它们能够同时在不同的工作机上运行。映射通常由系统中的资源分配器来处理。</p>
<p>3.<strong>同步</strong>：因为不同工作机可以执行不同的任务，工作机之间的同步和协调就很有必要。这样可以避免竞争条件，不同工作机之间的数据依赖也能被恰当地管理。不同工作机多路访问共享资源可能引起竞争条件。然而，当一个工作机需要其他工作机处理的数据时会产生数据依赖。</p>
<p>4.<strong>通信</strong>：因为<strong>数据依赖是工作机之间通信的一个主要原因</strong>，当中间数据准备好在工作机之间传送时，通信通常就开始了。</p>
<p>5.<strong>调度</strong>：对于一项作业或一个程序，当计算部分（任务）或数据块的数量多于可用的工作机数量时，调度程序就会选择一个任务或数据块的序列来分配给工作机。值得注意的是，<strong>资源分配器完成计算或数据块到工作机的实际映射</strong>，<strong>而调度器只是基于一套称为调度策略的规则</strong>，来从没有分配的任务队列中选择下一个任务。对于多作业或多程序，调度器会选择运行在分布式计算系统上的一个任务或程序的序列。 </p>
<h3 id="设计并行和分布式编程范式的动机"><a href="#设计并行和分布式编程范式的动机" class="headerlink" title="设计并行和分布式编程范式的动机"></a>设计并行和分布式编程范式的动机</h3><p>提供并行和分布式编程范式或模型来抽象用户数据流的多个部分。<br>编写并行程序的简单性是度量并行和分布式编程范式的重要标准。并行和分布式编程模型背后的其他动机还有：（1）提高程序员的生产效率，（2）减少程序进入市场的时间，（3）更有效地利用底层资源，（4）提高系统的吞吐量，（5）支持更高层的抽象。<br>MapReduce、Hadoop和Spark等是广泛使用的并行和分布式编程模型。这些模型是为信息检索应用而开发的，不过已经显示出它们也适用于各种重要应用 </p>
<h2 id="MapReduce、Twister和迭代MapReduce"><a href="#MapReduce、Twister和迭代MapReduce" class="headerlink" title="MapReduce、Twister和迭代MapReduce"></a>MapReduce、Twister和迭代MapReduce</h2><p>MapReduce是一个软件框架，可以支持大规模数据集上的并行和分布式计算。这个软件框架抽象化了在分布式计算系统上运行一个并行程序的数据流，并以两个函数的形式提供给用户两个接口：Map(映射)和Reduce（化简）。用户可以重载这两个函数以实现交互和操纵运行其程序的数据流。</p>
<p> 图6-1说明了在MapReduce框架中从Map到 Reduce函数的逻辑数据流。在这个框架中，数据的‘value’345部分（key，value）是实际数据，‘key’部分只是被MapReduce控制器使用来控制数据流。</p>
<p><a href="https://imgtu.com/i/5LxBdJ"><img src="https://z3.ax1x.com/2021/10/28/5LxBdJ.png" alt="5LxBdJ.png"></a></p>
<h3 id="MapReduce的形式化定义"><a href="#MapReduce的形式化定义" class="headerlink" title="MapReduce的形式化定义"></a>MapReduce的形式化定义</h3><p>MapReduce软件框架向用户提供了一个具有<strong>数据流和控制流的抽象层</strong>，并<strong>隐藏了所有数据流实现的步骤</strong>，比如，数据分块、映射、同步、通信和调度。这里，虽然在这样的框架中数据流已被预定义，但抽象层还提供两个定义完善的接口，这两个接口的形式就是Map和Reduce这两个函数。这两个主函数能由用户重载以达到特定目标。</p>
<p>用户首先重载Map和Reduce函数，然后从库里调用提供的函数MapReduce(Spec, &amp; Results)来开始数据流。MapReduce函数<strong>MapReduce(Spec, &amp; Results)<strong>有一个重要的参数，这个参数是一个</strong>规范对象‘Spec’</strong>。它首先在用户的程序里初始化，然后用户编写代码来填入输入和输出文件名，以及其他可选调节参数。这个对象还填入了Map和Reduce函数的名字，以识别这些用户定义的函数和MapReduce库里提供的函数。<br>下面给出了用户程序的整个结构，包括Map、Reduce和Main函数。Map和Reduce是两个主要的子程序。它们被调用来实现在主程序中执行的所需函数。</p>
<h3 id="MapReduce逻辑数据流"><a href="#MapReduce逻辑数据流" class="headerlink" title="MapReduce逻辑数据流"></a>MapReduce逻辑数据流</h3><p>Map和Reduce函数的输入数据有特殊的结构。输出数据也一样。Map函数的输入数据是以（key, value）对的形式出现。例如，key是输入文件的行偏移量，value是行内容。Map函数的输出数据的结构类似于(key, value)对，称为中间(key, value)对。换句话说，用户自定义的Map函数处理每个输入的(key, value)对，并产生很多(zero, one, or more)中间(key, value)对。这里的目的是为Map函数并行处理所有输入的(key, value)对 </p>
<p><a href="https://imgtu.com/i/5LzhcV"><img src="https://z3.ax1x.com/2021/10/28/5LzhcV.png" alt="5LzhcV.png"></a></p>
<p>反过来，Reduce函数以中间值群组的形式接受中间(key, value)对，这个中间值群组和一个中间key(key, [set of values])相关。<br>实际上，MapReduce框架形成了这些群组，首先是对中间(key, value)对排序，然后以相同的key来把value分组。<br>需要注意的是，<strong>数据的排序是为了简化分组过程</strong>。Reduce函数处理每个(key, [set of values])群组，并产生(key, value)对集合作为输出。 </p>
<h3 id="MapReduce真实数据和控制流"><a href="#MapReduce真实数据和控制流" class="headerlink" title="MapReduce真实数据和控制流"></a>MapReduce真实数据和控制流</h3><p>1.<strong>数据分区</strong>：MapReduce库将已存入GFS的输入数据（文件）分割成M部分，M也即映射任务的数量。</p>
<p>2.<strong>计算分区</strong>：计算分块通过强迫用户以Map和Reduce函数的形式编写程序，（在MapReduce框架中）被隐式地处理。所以，MapReduce库<strong>只生成用户程序的多个复制</strong>（例如，通过fork系统调用），它们包含了Map和Reduce函数，然后在多个可用的计算引擎上分配并启动它们</p>
<p>3.<strong>决定主服务器（master）和服务器（worker）</strong>：MapReduce体系结构是基于<strong>主服务器-服务器模式</strong>的。所以<strong>一个用户程序的复制变成了主服务器，其他则是服务器</strong>。主服务器挑选空闲的服务器，并分配Map和Reduce任务给它们。典型地，一个映射/化简服务器是一个计算引擎，例如集群节点，通过执行Map/Reduce函数来运行映射/化简任务。步骤4～7描述了映射服务器。</p>
<p>4.<strong>读取输入数据（数据分发）</strong>：<strong>每一个映射服务器读取其输入数据的相应部分</strong>，<strong>即输入数据分割</strong>，然后输入至其Map函数。虽然一个映射服务器可能运行多个Map函数，这意味着它分到了不止一个输入数据分割；通常每个服务器只分到一个输入分割。</p>
<p>5.<strong>Map函数</strong>：每个Map函数以（key，value）对集合的形式收到输入数据分割，来<strong>处理并产生中间（key, value）对。</strong><br>6.<strong>Combiner函数</strong>：Combiner函数是映射服务器中一个可选的本地函数，适用于中间(key, value)对。用户可以在用户程序里调用Combiner函数。Combiner函数运行用户为Reduce函数所写的相同代码，因为它们的功能是一样的。Combiner函数合并每个映射服务器的本地数据，然后送到网络传输，以有效减少通信成本。正如我们在逻辑数据流的讨论中提到的，MapReduce框架对数据进行排序并分组，然后数据被Reduce函数处理。类似地，如果用户调用Combiner函数，MapReduce框架也会对每个映射服务器的本地数据排序并分组。</p>
<p>7.<strong>Partitioning函数</strong>：正如在MapReduce数据流中提到的，具有相同键值的中间(key, value)对被分组到一起，因为每个组里的所有值都应只由一个Reduce函数来处理产生最终结果。然而在实际实现中，由于有M个map和R个化简任务，有相同key的中间(key, value)对可由不同的映射任务产生，尽管它们只应由一个Reduce函数来一起分组并处理。<br>由每一个映射服务器产生的中间(key, value)对被分成R个区域，这和化简任务的数量相同。分块是由Partitioning（分区）函数完成，并能保证有相同键值的所有(key, value)对都能存储在同一区域内。因此，由于化简服务器i读取所有映射服务器区域i中的数据，有相同key的所有(key, value)对将由相应的化简服务器i收集。 </p>
<p>8.<strong>同步</strong>：MapReduce使用简单的同步策略来协调映射服务器和化简服务器，<strong>当所有映射任务完成时，它们之间的通信就开始了</strong>。</p>
<p>9.<strong>通信</strong>：Reduce服务器i已经知道所有映射（Map）服务器的区域i的位置，<strong>使用远程过程调用来从所有映射服务器的各个区域中读取数据</strong>。由于所有化简服务器从所有映射服务器中读取数据，映射和化简服务器之间的多对多通信在网络中进行，会引发网络拥塞。这个问题是提高此类系统性能的一个主要瓶颈。</p>
<p>10**.排序和分组**：当化简服务器完成读取输入数据的过程时，数据首先在化简服务器的本地磁盘中缓冲。然后化简服务器根据key将数据排序来对中间(key, value)对进行分组，之后对出现的所有相同key进行分组。注意，缓冲数据已经排序并分组，因为一个映射服务器产生的唯一key的数量可能会多于R个区域，所以在每个映射服务器区域中可能有不止一个key。</p>
<p>11.<strong>Reduce函数</strong>：化简服务器在已分组的(key, value)对上进行迭代。对于每一个唯一的key，它把key和对应的value发送给Reduce函数。然后，这个函数处理输入数据，并将最后输出结果存入用户程序已经指定的文件中。</p>
<h3 id="计算-数据密切度"><a href="#计算-数据密切度" class="headerlink" title="计算-数据密切度"></a>计算-数据密切度</h3><p>MapReduce软件框架最早是由谷歌提出并实现的。首次实现是用C语言编码的。该实现是将谷歌文件系统 (GFS)的优势作为最底层。MapReduce可以完全适用于GFS。GFS是一个分布式文件系统，其中<strong>文件被分成固定大小的块</strong>，这些块被分发并存储在集群节点上。<br>如前所述，MapReduce库将输入数据（文件）分割成固定大小的块，理想状态下是在每个块上并行地执行Map函数。在这种情况下，由于GFS已经将文件保存成多个块，MapReduce框架只需要将包含Map函数的用户程序复制发给已经存有数据块的节点。这就是将计算发向数据，而不是将数据发给计算。注意，GFS块默认为64MB，这和MapReduce框架是相同的。</p>
<h3 id="Twister和迭代MapReduce"><a href="#Twister和迭代MapReduce" class="headerlink" title="Twister和迭代MapReduce"></a>Twister和迭代MapReduce</h3><p><strong>并行开销的两个主要来源是负载不均衡和通信</strong></p>
<p>在所有“经典并行的”松散同步应用中可以看到同样的现象，典型地需要在计算阶段加入一个迭代结构，然后是通信阶段。可以通过两个重要的改变来解决性能问题：</p>
<p>1.<strong>在各个步骤之间的流信息，不把中间结果写入磁盘。</strong></p>
<p>2**.使用长期运行的线程或进程与δ（在迭代之间）流进行通信。**</p>
<p>这些改变将会导致重大的性能提升，代价是较差的容错能力，同时更容易支持动态改变，如可用节点的数量。这个概念已经在多个项目中应用</p>
<p><a href="https://imgtu.com/i/5OkSz9"><img src="https://z3.ax1x.com/2021/10/28/5OkSz9.png" alt="5OkSz9.png"></a></p>
<h2 id="Apache的Hadoop软件库"><a href="#Apache的Hadoop软件库" class="headerlink" title="Apache的Hadoop软件库"></a>Apache的Hadoop软件库</h2><p>Hadoop是Apache用Java编码和发布的MapReduce开源实现。MapReduce的Hadoop实现使用Hadoop分布式文件系统(Hadoop Distributed File System，HDFS)作为底层，而不是GFS。Hadoop内核分为两个基本层：MapReduce 引擎和HDFS。MapReduce 引擎是运行在HDFS之上的计算引擎，使用HDFS作为它的数据存储管理器。</p>
<p>HDFS: HDFS是一个源于GFS的分布式文件系统，是在一个分布式计算系统上管理文件和存储数据。</p>
<p><strong>HDFS体系结构</strong>：HDFS有一个主从体系结构，包括一个<strong>单个NameNode作为master以及多个DataNodes作为工作机(slave)<strong>。为了在这个体系结构中存储文件，HDFS将文件分割成</strong>固定大小的块</strong>（例如64MB），并将这些块存到工作机(DataNodes)中。<strong>从块到DataNodes的映射是由NameNode决定的。</strong>NameNode (master)也管理文件系统的元数据和命名空间。在这个系统中，命名空间是维护元数据的区域，而元数据是指一个文件系统存储的所有信息，它们是所有文件的全面管理所需要的。例如，<strong>元数据中的NameNode存储了所有DataNodes上关于输入块位置的所有信息</strong>。每个DataNode，通常是集群中每个节点一个，管理这个节点上的存储。<strong>每个DataNode负责它的文件块的存储和检索</strong> </p>
<p><strong>HDFS特性</strong>：分布式文件系统为了能高效地运作，会有一些特殊的需求，比如性能、可扩展性、并发控制、容错能力和安全需求[62]。然而，因为HDFS不是一个通用的文件系统，即它仅执行特殊种类的应用，所以它不需要一个通用分布式文件系统的所有需求。例如，HDFS系统从不支持安全性。下面的讨论着重突出HDFS区别于其他一般分布式文件系统的两个重要特征。<br><strong>HDFS容错能力</strong>：HDFS的一个主要方面就是容错特征。由于Hadoop设计时默认部署在廉价的硬件上，系统硬件故障是很常见的。所以，Hadoop考虑以下几个问题来达到文件系统的可靠性要求：</p>
<p><strong>块复制</strong>：为了能在HDFS上可靠地存储数据，在这个系统中文件块被复制了。换句话说，HDFS把文件存储为一个块集，每个块都有备份并在整个集群上分发。<br><strong>备份布置</strong>：备份的布置是HDFS实现所需要的容错功能的另一个因素。虽然在整个集群的不同机架的不同节点上(DataNodes)，存储备份提供了更大的可靠性，但这有时会被忽略，因为不同机架上两个节点之间的通信成本要比同一个机架上两个不同节点之间的通信相对要高。<br><strong>Heartbeat和Blockreport消息</strong>：Heartbeats和Blockreports是在一个集群中由每个DataNode传给NameNode的周期性消息。收到Heartbeat 意味着DataNode正运行正常，而每个Blockreport包括了DataNode上所有块的一个清单。</p>
<h3 id="Hadoop-上的MapReduce-体系结构"><a href="#Hadoop-上的MapReduce-体系结构" class="headerlink" title="Hadoop 上的MapReduce 体系结构"></a>Hadoop 上的MapReduce 体系结构</h3><p>Hadoop的顶层是MapReduce引擎，管理着分布式计算系统上MapReduce作业的数据流和控制流。</p>
<p>类似于HDFS，MapReduce引擎也有一个主/从（master/slave）体系结构，由一个单独的JobTracker作为主服务器并由许多的TaskTracker作为服务器(slaves)。JobTracker在一个集群上管理MapReduce作业，并负责监视作业和分配任务给TaskTracker。TaskTracker管理着集群上单个计算节点的映射和化简任务的执行。</p>
<p><a href="https://imgtu.com/i/5OERVx"><img src="https://z3.ax1x.com/2021/10/28/5OERVx.png" alt="5OERVx.png"></a></p>
<p>每个TaskTracker节点都有许多同时运行槽，每个运行是映射任务或者化简任务。插槽是由TaskTracker 节点的CPU支持同时运行的线程数量来确定的。</p>
<p>比如，一个带有N个CPU的TaskTracker节点，每个都支持M个线程，共有M×N个同时运行的槽。需要注意的是，每个数据块都是由运行在单独的一个槽上的映射任务处理的。</p>
<p>所以， <strong>在TaskTracker 上的映射任务和在各个DataNode上的数据块之间存在一一对应关系。</strong></p>
<h3 id="在Hadoop里运行一个作业"><a href="#在Hadoop里运行一个作业" class="headerlink" title="在Hadoop里运行一个作业"></a>在Hadoop里运行一个作业</h3><p>在这个系统中有三个部分共同完成一个作业的运行：用户节点、JobTracker和数个TaskTracker。数据流最初是在运行于用户节点上的用户程序中调用runJob(conf)函数，其中conf是MapReduce 框架和HDFS中一个对象，它包含了一些调节参数。runJob(conf)函数和conf如同谷歌MapReduce第一次实现中的MapReduce(Spec, &amp;Results) 函数和Spec。图6-12描述了在Hadoop上运行一个MapReduce作业的数据流 </p>
<p><a href="https://imgtu.com/i/5OVCss"><img src="https://z3.ax1x.com/2021/10/28/5OVCss.png" alt="5OVCss.png"></a></p>
<p><strong>作业提交</strong>：每个作业都是由用户节点通过以下步骤提交给JobTracker节点，此节点可能会位于集群内一个不同的节点上：</p>
<p>一个用户节点从JobTracker请求一个新的作业ID，并计算输入文件分块。</p>
<p>用户节点复制一些资源，比如用户的JAR文件、配置文件和计算输入分块，至JobTracker文件系统。</p>
<p>用户节点通过调用submitJob()函数提交任务至JobTracker。</p>
<p><strong>任务分配</strong>：JobTracker为用户节点的每个计算输入块建立一个映射任务，并分配给TaskTracker的执行槽。当分配映射任务给TaskTracker时，JobTracker会考虑数据的定位。JobTracker也会创建化简任务，并分配给TaskTracker。 </p>
<p><strong>任务执行</strong>：把作业JAR文件复制到其文件系统之后，在TaskTracker执行一个任务（不管映射还是化简）的控制流就开始了。在启动Java虚拟机（Java Virtual Machine，JVM）来运行它的映射或化简任务后，就开始执行作业JAR文件里的指令。<br><strong>任务运行校验</strong>：通过接收从TaskTracker到JobTracker的周期性心跳监听消息来完成任务运行校验。每个心跳监听会告知JobTracker传送中的TaskTracker是可用的，以及传送中的TaskTracker是否准备好运行一个新的任务。 </p>
<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h2 id="Spark与Hadoop区别"><a href="#Spark与Hadoop区别" class="headerlink" title="Spark与Hadoop区别"></a>Spark与Hadoop区别</h2><p><strong>Spark把中间数据放到内存中</strong>，迭代运算效率高。MapReduce中计算结果需要落地，保存到磁盘上，这样势必会影响整体速度，而Spark支持DAG图的分布式并行计算的编程框架，减少了迭代过程中数据的落地，提高了处理效率。<br><strong>Spark容错性高</strong>。Spark引进了弹性分布式数据集RDD (Resilient Distributed Dataset) 的抽象，它是分布在一组节点中的只读对象集合，这些集合是弹性的，<strong>如果数据集一部分丢失，则可以根据“血统”（即充许基于数据衍生过程）对它们进行重建。</strong><br><strong>Spark更加通用。</strong>不像Hadoop只提供了Map和Reduce两种操作，Spark提供的数据集操作类型有很多种，大致分为：Transformations和Actions两大类。Transformations包括Map、Filter、FlatMap、Sample、GroupByKey、ReduceByKey、Union、Join、Cogroup、MapValues、Sort和PartionBy等多种操作类型，同时还提供Count, Actions包括Collect、Reduce、Lookup和Save等操作。另外各个处理节点之间的通信模型不再像Hadoop只有Shuffle一种模式，用户可以命名、物化，控制中间结果的存储、分区等。</p>
<h2 id="Resilient-Distributed-Dataset-（RDD）"><a href="#Resilient-Distributed-Dataset-（RDD）" class="headerlink" title="Resilient Distributed Dataset （RDD）"></a>Resilient Distributed Dataset （RDD）</h2><p>RDD是Spark的最基本抽象,是对分布式内存的抽象使用，实现了以操作本地集合的方式来操作分布式数据集的抽象实现。RDD是Spark最核心的东西，<strong>它表示已被分区，不可变的并能够被并行操作的数据集合，</strong>不同的数据集格式对应不同的RDD实现。<strong>RDD必须是可序列化的。RDD可以cache到内存中，每次对RDD数据集的操作之后的结果</strong>，都可以存放到内存中，下一个操作可以直接从内存中输入，省去了MapReduce大量的磁盘IO操作。这对于迭代运算比较常见的机器学习算法, 交互式数据挖掘来说，效率提升非常大。</p>
<p>来源：一种是从<strong>持久存储获取数据</strong>，另一种是<strong>从其他RDD生成</strong><br>只读：状态不可变，不能修改<br>分区：<strong>支持元素根据 Key 来分区</strong> ( Partitioning ) ，保存到多个结点上，<strong>还原时只会重新计算丢失分区的数据</strong>，而不会影响整个系统<br>路径：<strong>在 RDD 中叫世族或血统 ( lineage )</strong> ，即 RDD 有充足的信息关于它是如何从其他 RDD 产生而来的<br>持久化：<strong>可以控制存储级别（内存、磁盘等）来进行持久化</strong><br>操作：<strong>丰富的动作 ( Action )</strong> ，如Count、Reduce、Collect和Save 等</p>
<h2 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h2><h3 id="Transformation-采用lazy模式"><a href="#Transformation-采用lazy模式" class="headerlink" title="Transformation 采用lazy模式"></a>Transformation 采用lazy模式</h3><p>从一个RDD转换生成另一个RDD的操作不是马上执行，Spark在遇到Transformations操作时只会记录需要这样的操作，并不会去执行，<strong>需要等到有Actions操作的时候才会真正启动计算过程进行计算。</strong><br><strong>Actions操作</strong>会返回结果或把RDD数据<strong>写到存储系统中</strong>。<strong>Actions是触发Spark启动计算的动因</strong></p>
<h2 id="宽依赖和窄依赖"><a href="#宽依赖和窄依赖" class="headerlink" title="宽依赖和窄依赖"></a>宽依赖和窄依赖</h2><h3 id="窄依赖（Narrow-Dependencies-）"><a href="#窄依赖（Narrow-Dependencies-）" class="headerlink" title="窄依赖（Narrow Dependencies ）"></a>窄依赖（Narrow Dependencies ）</h3><p>Ø  子RDD 的每个分区依赖于常数个父分区（即与数据规模无关）<br>Ø  输入输出一对一的算子，且结果RDD 的分区结构不变，主要是map 、flatMap<br>Ø  输入输出一对一，但结果RDD 的分区结构发生了变化，如union 、coalesce<br>Ø  从输入中选择部分元素的算子，如filter 、distinct 、subtract 、sample</p>
<h3 id="宽依赖（Wide-Dependencies-）"><a href="#宽依赖（Wide-Dependencies-）" class="headerlink" title="宽依赖（Wide Dependencies ）"></a>宽依赖（Wide Dependencies ）</h3><p>Ø  子RDD 的每个分区依赖于所有父RDD 分区<br>Ø  对单个RDD 基于Key 进行重组和reduce，如groupByKey 、reduceByKey ；<br>Ø  对两个RDD 基于Key 进行join 和重组，如join</p>
<h2 id="存储内存管理"><a href="#存储内存管理" class="headerlink" title="存储内存管理"></a>存储内存管理</h2><p><a href="https://imgtu.com/i/5jF4Re"><img src="https://z3.ax1x.com/2021/10/29/5jF4Re.png" alt="5jF4Re.png"></a></p>
<p><a href="https://imgtu.com/i/5jFqdP"><img src="https://z3.ax1x.com/2021/10/29/5jFqdP.png" alt="5jFqdP.png"></a></p>
<h3 id="RDD-缓存的过程"><a href="#RDD-缓存的过程" class="headerlink" title="RDD 缓存的过程"></a>RDD 缓存的过程</h3><p>RDD 在缓存到存储内存之前，Partition 中的数据一般以迭代器（Iterator）的数据结构来访问，这是 Scala 语言中一种遍历数据集合的方法。<strong>通过 Iterator 可以获取分区中每一条序列化或者非序列化的数据项(Record)，这些 Record 的对象实例在逻辑上占用了 JVM 堆内内存的 other 部分的空间</strong>，同一 Partition 的不同 Record 的空间并不连续。<br><strong>RDD 在缓存到存储内存之后，Partition 被转换成 Block</strong>，所有Record 在堆内或堆外存储内存中占用一块连续的空间。将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll）</p>
<p>因为不能保证存储空间可以一次容纳 Iterator 中的所有数据，<strong>当前的计算任务在 Unroll 时要向 MemoryManager 申请足够的 Unroll 空间来临时占位</strong>，空间不足则 Unroll 失败，空间足够时可以继续进行。对于序列化的 Partition，其所需的 Unroll 空间可以直接累加计算，一次申请。而非序列化的 Partition 则要在遍历 Record 的过程中依次申请，即每读取一条 Record，采样估算其所需的 Unroll 空间并进行申请，空间不足时可以中断，释放已占用的 Unroll 空间。如果最终 Unroll 成功，当前 Partition 所占用的 Unroll 空间被转换为正常的缓存 RDD 的存储空间</p>
<p><a href="https://imgtu.com/i/5jAH4f"><img src="https://z3.ax1x.com/2021/10/29/5jAH4f.png" alt="5jAH4f.png"></a></p>
<h3 id="淘汰和落盘"><a href="#淘汰和落盘" class="headerlink" title="淘汰和落盘"></a>淘汰和落盘</h3><p>由于同一个 Executor 的所有的计算任务共享有限的存储内存空间，当有新的 Block 需要缓存但是剩余空间不足且无法动态占用时，就要对 LinkedHashMap 中的旧 Block 进行淘汰（Eviction），而被淘汰的 Block 如果其存储级别中同时包含存储到磁盘的要求，则要对其进行落盘（Drop），否则直接删除该 Block。</p>
<h2 id="执行内存管理"><a href="#执行内存管理" class="headerlink" title="执行内存管理"></a>执行内存管理</h2><h3 id="多任务间内存分配"><a href="#多任务间内存分配" class="headerlink" title="多任务间内存分配"></a>多任务间内存分配</h3><p>Executor 内运行的任务同样共享执行内存，<strong>Spark 用一个 HashMap 结构保存了任务到内存耗费的映射</strong>。每个任务可占用的执行内存大小的范围为 1/2N ~ 1/N，其中 N 为当前 Executor 内正在运行的任务的个数。每个任务在启动之时，<strong>要向 MemoryManager 请求申请最少为 1/2N 的执行内存，如果不能被满足要求则该任务被阻塞</strong>，直到有其他任务释放了足够的执行内存，该任务才可以被唤醒</p>
<h3 id="Shuffle-的内存占用"><a href="#Shuffle-的内存占用" class="headerlink" title="Shuffle 的内存占用"></a>Shuffle 的内存占用</h3><p>执行内存主要用来存储任务在执行 Shuffle 时占用的内存，Shuffle 是按照一定规则对 RDD 数据重新分区的过程，我们来看 Shuffle 的 Write 和 Read 两阶段对执行内存的使用<br>Shuffle Write：若在 map 端选择普通的排序方式，会采用 ExternalSorter 进行外排，在内存中存储数据时主要占用堆内执行空间。若在 map 端选择 Tungsten 的排序方式，则采用 ShuffleExternalSorter 直接对以序列化形式存储的数据排序，在内存中存储数据时可以占用堆外或堆内执行空间，取决于用户是否开启了堆外内存以及堆外执行内存是否足够。<br>Shuffle Read：在对 reduce 端的数据进行聚合时，要将数据交给 Aggregator 处理，在内存中存储数据时占用堆内执行空间。如果需要进行最终结果排序，则要将再次将数据交给 ExternalSorter 处理，占用堆内执行空间。</p>
<h2 id="BlockManager-在-spark-中扮演的角色"><a href="#BlockManager-在-spark-中扮演的角色" class="headerlink" title="BlockManager 在 spark 中扮演的角色"></a>BlockManager 在 spark 中扮演的角色</h2><p>spark shuffle 的过程总用到了 BlockManager 作为数据的中转站<br>spark broadcast 调度 task 到多个 executor 的时候， broadCast 底层使用的数据存储层<br>如果我们对一个 rdd 进行了cache, cacheManager 也是把数据放在了 blockmanager 中， 截断了计算链依赖， 后续task 运行的时候可以直接从 cacheManager 中获取到 cacherdd ，不用再从头计算。</p>
<h2 id="Block和partition的关系"><a href="#Block和partition的关系" class="headerlink" title="Block和partition的关系"></a>Block和partition的关系</h2><p>RDD 的运算是基于 partition， 每个 task 代表一个 分区上一个 stage 内的运算闭包， task 被分别调度到 多个 executor上去运行， 那么是在哪里变成了 Block 呢， 我们以 spark 2.11 源码为准， 看看这个转变过程，一个 RDD 调度到 executor 上会运行调用 getOrCompute方法。<br>如果 Block 在 BlockManager 中存在， 就会从 BlockManager 中获取，如果不存在， 就进行计算这个Block, 然后在 BlockManager 中进行存储持久化， 方便下次使用。</p>
<p>首先根据RDD id和partition index构造出block id (rdd_xx_xx)，接着从BlockManager中取出相应的block。</p>
<blockquote>
<p>如果该block存在，表示此RDD在之前已经被计算过和存储在BlockManager中，因此取出即可，无需再重新计算。<br>如果该block不存在则需要调用RDD的computeOrReadCheckpoint()函数计算出新的block，并将其存储到BlockManager中。</p>
</blockquote>
<p>需要注意的是block的计算和存储是阻塞的，若另一线程也需要用到此block则需等到该线程block的loading结束。</p>
<p>获取的时候是先从本地的 BlockManager 中获取， 如果本地没有， 然后再 从 remote 获取， 先从 driver 上获取到元数据 Block的位置， 然后去到真正的节点上fetch。<br>如果没有，就进行计算，然后根据存储级别，存储到计算节点本地的BlockManager 的内存或磁盘中，这样RDD的transformation、action就和block数据建立了联系，虽然抽象上我们的操作是在partition层面上进行的，但是partition最终还是被映射成为block，因此实际上我们的所有操作都是对block的处理和存取。</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>dls-DP</title>
    <url>/2022/02/21/dls-DP/</url>
    <content><![CDATA[<h3 id="树上背包1"><a href="#树上背包1" class="headerlink" title="树上背包1"></a><a href="http://oj.daimayuan.top/course/8/problem/269">树上背包1</a></h3><span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">ll sz[N], tmp[N], a[N], dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  sz[x] = <span class="number">1</span>;</span><br><span class="line">  dp[x][<span class="number">1</span>] = a[x];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(to);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, sz[x] + sz[to]) tmp[i] = -INF;</span><br><span class="line">    tmp[<span class="number">1</span>] = a[x];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, sz[x]) &#123;</span><br><span class="line">      <span class="built_in">rep</span>(j, <span class="number">0</span>, sz[to]) &#123; tmp[i + j] = <span class="built_in">max</span>(tmp[i + j], dp[x][i] + dp[to][j]); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sz[x] += sz[to];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, sz[x]) dp[x][i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll n, q;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    g[x].<span class="built_in">pb</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    ll u, m;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; dp[u][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树上背包2"><a href="#树上背包2" class="headerlink" title="树上背包2"></a><a href="http://oj.daimayuan.top/course/8/problem/270">树上背包2</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">ll sz[N], tmp[N], a[N], dp[N][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  sz[x] = <span class="number">1</span>;</span><br><span class="line">  dp[x][<span class="number">1</span>] = a[x];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[x]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(to);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, <span class="built_in">min</span>(<span class="number">101ll</span>, sz[x] + sz[to])) tmp[i] = -INF;</span><br><span class="line">    tmp[<span class="number">1</span>] = a[x];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="built_in">min</span>(<span class="number">101ll</span>, sz[x])) &#123;</span><br><span class="line">      <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="built_in">min</span>(<span class="number">101ll</span>, sz[to])) &#123;</span><br><span class="line">        tmp[i + j] = <span class="built_in">max</span>(tmp[i + j], dp[x][i] + dp[to][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sz[x] += sz[to];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="built_in">min</span>(<span class="number">101ll</span>, sz[x])) dp[x][i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll n, q;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    g[x].<span class="built_in">pb</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    ll u, m;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; dp[u][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树上背包3"><a href="#树上背包3" class="headerlink" title="树上背包3"></a><a href="http://oj.daimayuan.top/course/8/problem/271">树上背包3</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N], dp[N][<span class="number">10005</span>], w[N];</span><br><span class="line">ll tot, l[N], r[N], id[N];</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll u)</span> </span>&#123;</span><br><span class="line">  l[u] = ++tot;</span><br><span class="line">  id[tot] = u;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  r[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    g[x].<span class="built_in">pb</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cin &gt;&gt; a[i]; &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cin &gt;&gt; w[i]; &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123; dp[n + <span class="number">1</span>][i] = -INF; &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">dec</span>(i, n, <span class="number">1</span>) &#123;</span><br><span class="line">    ll u = id[i];</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">0</span>, m) &#123;</span><br><span class="line">      dp[i][j] = dp[r[u] + <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= w[u]) &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i + <span class="number">1</span>][j - w[u]] + a[u]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[<span class="number">1</span>][i] &gt;= <span class="number">0</span>)</span><br><span class="line">      cout &lt;&lt; dp[<span class="number">1</span>][i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树上路径1"><a href="#树上路径1" class="headerlink" title="树上路径1"></a><a href="http://oj.daimayuan.top/course/8/problem/272">树上路径1</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, f[N], dep[N], dp[N], sdp[N];</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">vector&lt;array&lt;ll, 3&gt;&gt; path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">    sdp[u] += dp[v];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[u] = sdp[u];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> p : path[u]) &#123;</span><br><span class="line">    ll tmp = sdp[u];</span><br><span class="line">    ll x = p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (x != u) &#123;</span><br><span class="line">      tmp += sdp[x] - dp[x];</span><br><span class="line">      x = f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    x = p[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (x != u) &#123;</span><br><span class="line">      tmp += sdp[x] - dp[x];</span><br><span class="line">      x = f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    tmp += p[<span class="number">2</span>];</span><br><span class="line">    dp[u] = <span class="built_in">max</span>(dp[u], tmp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">    cin &gt;&gt; f[i];</span><br><span class="line">    g[f[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    dep[i] = dep[f[i]] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    ll u, v, t;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; t;</span><br><span class="line">    ll x = u, y = v;</span><br><span class="line">    <span class="keyword">while</span> (x != y) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">        x = f[x];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        y = f[y];</span><br><span class="line">    &#125;</span><br><span class="line">    path[x].<span class="built_in">pb</span>(&#123;u, v, t&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树上路径2"><a href="#树上路径2" class="headerlink" title="树上路径2"></a><a href="http://oj.daimayuan.top/course/8/problem/273">树上路径2</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">1ll</span>&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, f[N], dep[N], dp[N][N];</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">vector&lt;array&lt;ll, 2&gt;&gt; path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(ll *a, ll *b, ll len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll sufa[N], sufb[N];</span><br><span class="line">  sufa[len + <span class="number">1</span>] = INF;</span><br><span class="line">  sufb[len + <span class="number">1</span>] = INF;</span><br><span class="line">  <span class="built_in">dec</span>(i, len, <span class="number">1</span>) &#123;</span><br><span class="line">    sufa[i] = <span class="built_in">min</span>(sufa[i + <span class="number">1</span>], a[i]);</span><br><span class="line">    sufb[i] = <span class="built_in">min</span>(sufb[i + <span class="number">1</span>], b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, len) &#123; a[i] = <span class="built_in">min</span>(a[i] + sufb[i], b[i] + sufa[i]); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll u)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, dep[u]) dp[u][i] = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> p : path[u]) &#123;</span><br><span class="line">    dp[u][dep[p[<span class="number">0</span>]]] = <span class="built_in">min</span>(dp[u][dep[p[<span class="number">0</span>]]], p[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">    <span class="built_in">merge</span>(dp[u], dp[v], dep[v]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">    cin &gt;&gt; f[i];</span><br><span class="line">    g[f[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    dep[i] = dep[f[i]] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    ll u, v, t;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; t;</span><br><span class="line">    path[v].<span class="built_in">pb</span>(&#123;u, t&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (dp[<span class="number">1</span>][<span class="number">1</span>] &gt;= INF)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树上连通块"><a href="#树上连通块" class="headerlink" title="树上连通块"></a><a href="http://oj.daimayuan.top/course/8/problem/274">树上连通块</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll INF = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">ll pre[N], suf[N], dp[N], dp2[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll u)</span> </span>&#123;</span><br><span class="line">  dp[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">    dp[u] = dp[u] * (dp[v] + <span class="number">1</span>) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll u)</span> </span>&#123;</span><br><span class="line">  ll sz = g[u].<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">0</span>, sz - <span class="number">1</span>) &#123; pre[i + <span class="number">1</span>] = pre[i] * (dp[g[u][i]] + <span class="number">1</span>) % mod; &#125;</span><br><span class="line">  suf[sz] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">dec</span>(i, sz - <span class="number">1</span>, <span class="number">0</span>) &#123; suf[i] = suf[i + <span class="number">1</span>] * (dp[g[u][i]] + <span class="number">1</span>) % mod; &#125;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">0</span>, sz - <span class="number">1</span>) &#123;</span><br><span class="line">    ll v = g[u][i];</span><br><span class="line">    dp2[v] = pre[i] * suf[i + <span class="number">1</span>] % mod;</span><br><span class="line">    <span class="keyword">if</span> (u != <span class="number">1</span>) dp2[v] = dp2[v] * (dp2[u] + <span class="number">1</span>) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    ans[v] = dp[v] * (dp2[v] + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="built_in">dfs2</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll n;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">    ll f;</span><br><span class="line">    cin &gt;&gt; f;</span><br><span class="line">    g[f].<span class="built_in">pb</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">  ans[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123; cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ICPC-Nanjing-2021-H-Crystalfly"><a href="#ICPC-Nanjing-2021-H-Crystalfly" class="headerlink" title="ICPC Nanjing 2021 H, Crystalfly"></a><a href="http://oj.daimayuan.top/course/8/problem/295">ICPC Nanjing 2021 H, Crystalfly</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">ll a[N], t[N], f[N], h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll u, ll fa)</span> </span>&#123;</span><br><span class="line">  ll mx = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    s += f[v];</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, a[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  f[u] = s + mx;</span><br><span class="line">  <span class="function">pll <span class="title">mx1</span><span class="params">(-inf, <span class="number">0</span>)</span>, <span class="title">mx2</span><span class="params">(-inf, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v != fa &amp;&amp; t[v] == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="function">pll <span class="title">tmp</span><span class="params">(a[v], v)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (mx2 &lt; tmp) mx2 = tmp;</span><br><span class="line">      <span class="keyword">if</span> (mx1 &lt; mx2) <span class="built_in">swap</span>(mx1, mx2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    ll tmp = s + h[v] - f[v];</span><br><span class="line">    <span class="keyword">if</span> (v == mx1.se)</span><br><span class="line">      tmp += mx2.fi;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      tmp += mx1.fi;</span><br><span class="line">    f[u] = <span class="built_in">max</span>(f[u], tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  h[u] = s + a[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; t[i];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">      ll u, v;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">      g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">      g[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>] + a[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ICPC-Nanjing-2020-M-Monster-Hunter"><a href="#ICPC-Nanjing-2020-M-Monster-Hunter" class="headerlink" title="ICPC Nanjing 2020 M, Monster Hunter"></a><a href="http://oj.daimayuan.top/course/8/problem/296">ICPC Nanjing 2020 M, Monster Hunter</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll sz[N], dp[N][N][<span class="number">2</span>], hp[N];</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll u)</span> </span>&#123;</span><br><span class="line">  dp[u][<span class="number">0</span>][<span class="number">0</span>] = hp[u];</span><br><span class="line">  dp[u][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[u][<span class="number">1</span>][<span class="number">0</span>] = dp[u][<span class="number">0</span>][<span class="number">1</span>] = inf;</span><br><span class="line">  sz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> ll tmp[N][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, sz[u] + sz[v]) &#123; tmp[i][<span class="number">0</span>] = tmp[i][<span class="number">1</span>] = inf; &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, sz[u]) &#123;</span><br><span class="line">      <span class="built_in">rep</span>(j, <span class="number">0</span>, sz[v]) &#123;</span><br><span class="line">        tmp[i + j][<span class="number">0</span>] = <span class="built_in">min</span>(</span><br><span class="line">            tmp[i + j][<span class="number">0</span>], dp[u][i][<span class="number">0</span>] + <span class="built_in">min</span>(dp[v][j][<span class="number">0</span>] + hp[v], dp[v][j][<span class="number">1</span>]));</span><br><span class="line">        tmp[i + j][<span class="number">1</span>] =</span><br><span class="line">            <span class="built_in">min</span>(tmp[i + j][<span class="number">1</span>], dp[u][i][<span class="number">1</span>] + <span class="built_in">min</span>(dp[v][j][<span class="number">0</span>], dp[v][j][<span class="number">1</span>]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, sz[u] + sz[v]) &#123;</span><br><span class="line">      dp[u][i][<span class="number">0</span>] = tmp[i][<span class="number">0</span>], dp[u][i][<span class="number">1</span>] = tmp[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">      ll x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      g[x].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; hp[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) cout &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">1</span>][i][<span class="number">0</span>], dp[<span class="number">1</span>][i][<span class="number">1</span>]) &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CCPC-Qinhuangdao-2020-K-Kingdom’s-Power"><a href="#CCPC-Qinhuangdao-2020-K-Kingdom’s-Power" class="headerlink" title="CCPC Qinhuangdao 2020 K, Kingdom’s Power"></a><a href="http://oj.daimayuan.top/problem/297">CCPC Qinhuangdao 2020 K, Kingdom’s Power</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll dep[N], dp[N][<span class="number">2</span>];</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll u)</span> </span>&#123;</span><br><span class="line">  dp[u][<span class="number">1</span>] = dep[u];</span><br><span class="line">  dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">    dp[u][<span class="number">1</span>] = <span class="built_in">min</span>(</span><br><span class="line">        &#123;dp[u][<span class="number">1</span>] + dp[v][<span class="number">1</span>], dp[u][<span class="number">1</span>] + dp[v][<span class="number">0</span>] + <span class="number">2</span>, dp[u][<span class="number">0</span>] + dp[v][<span class="number">1</span>]&#125;);</span><br><span class="line">    dp[u][<span class="number">0</span>] += dp[v][<span class="number">0</span>] + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="built_in">rep</span>(cas, <span class="number">1</span>, T) &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      g[x].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cas &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CF-Round-734-Div-3-F-Equidistant-Vertices"><a href="#CF-Round-734-Div-3-F-Equidistant-Vertices" class="headerlink" title="CF Round #734(Div. 3) F, Equidistant Vertices"></a><a href="http://oj.daimayuan.top/problem/298">CF Round #734(Div. 3) F, Equidistant Vertices</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, k, g[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">ll cnt[<span class="number">105</span>], dp[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123; g[i][j] = (i == j) ? <span class="number">0</span> : mod; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">      ll u, v;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">      g[u][v] = g[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">      cout &lt;&lt; n * (n - <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(k, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123; g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]); &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      <span class="built_in">rep</span>(d, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) cnt[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(u, <span class="number">1</span>, n) &#123;</span><br><span class="line">          <span class="keyword">if</span> (g[i][u] == d) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(v, <span class="number">1</span>, n) &#123;</span><br><span class="line">              <span class="keyword">if</span> (g[i][v] == <span class="number">1</span> &amp;&amp; g[i][u] == g[i][v] + g[v][u]) &#123;</span><br><span class="line">                cnt[v]++;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, k) dp[j] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">          <span class="keyword">if</span> (cnt[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dec</span>(l, k, <span class="number">1</span>) &#123; dp[l] = (dp[l] + dp[l - <span class="number">1</span>] * cnt[j]) % mod; &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + dp[k]) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数数3"><a href="#数数3" class="headerlink" title="数数3"></a><a href="http://oj.daimayuan.top/problem/248">数数3</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27; &#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>][<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll rem, ll exist, ll last, ll inc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rem == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> exist;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dp[rem][exist][last][inc] != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> dp[rem][exist][last][inc];</span><br><span class="line">  &#125;</span><br><span class="line">  ll &amp;ans = dp[rem][exist][last][inc];</span><br><span class="line">  ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>) &#123;</span><br><span class="line">    ll inc_ = (i &gt; last) ? <span class="built_in">min</span>(inc + <span class="number">1</span>, <span class="number">3ll</span>) : <span class="number">1</span>;</span><br><span class="line">    ans += <span class="built_in">dfs</span>(rem - <span class="number">1</span>, exist | (inc_ == <span class="number">3</span>), i, inc_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  x += <span class="number">1</span>;</span><br><span class="line">  vector&lt;ll&gt; d;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    d.<span class="built_in">pb</span>(x % <span class="number">10</span>);</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">  ll m = d.<span class="built_in">size</span>();</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">1</span>, m - <span class="number">1</span>) &#123; <span class="built_in">rep</span>(j, <span class="number">1</span>, <span class="number">9</span>) ans += <span class="built_in">dfs</span>(i - <span class="number">1</span>, <span class="number">0</span>, j, <span class="number">1</span>); &#125;</span><br><span class="line">  ll exist = <span class="number">0</span>, last = <span class="number">0</span>, inc = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">rep</span>(i, <span class="number">0</span>, m - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ll j = (i == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>; j &lt; d[i]; j++) &#123;</span><br><span class="line">      ll inc_ = (j &gt; last) ? <span class="built_in">min</span>(inc + <span class="number">1</span>, <span class="number">3ll</span>) : <span class="number">1</span>;</span><br><span class="line">      ans += <span class="built_in">dfs</span>(m - i - <span class="number">1</span>, exist | (inc_ == <span class="number">3</span>), j, inc_);</span><br><span class="line">    &#125;</span><br><span class="line">    inc = (d[i] &gt; last) ? <span class="built_in">min</span>(inc + <span class="number">1</span>, <span class="number">3ll</span>) : <span class="number">1</span>;</span><br><span class="line">    exist |= (inc == <span class="number">3</span>);</span><br><span class="line">    last = d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  ll l, r;</span><br><span class="line">  cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">  cout &lt;&lt; <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理</title>
    <url>/2022/02/28/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>Digital Image Procession</p>
<span id="more"></span>

<h1 id="Image-Acquisition"><a href="#Image-Acquisition" class="headerlink" title="Image Acquisition"></a>Image Acquisition</h1><p>An image is a projection of a 3D scene into a 2D<br>projection plane.</p>
<p> An image can be defined as a 2 variable function</p>
<p>$f(x,y): R^2→R$</p>
<h2 id="Notations"><a href="#Notations" class="headerlink" title="Notations"></a>Notations</h2><p><strong>• Image Intensity</strong><br>– Light <strong>energy</strong> emitted from a unit area in the image<br>– Device dependence<br>**• Image Brightness **<br>– <strong>The subjective appearance</strong> of a unit area in the image<br>– Context dependence<br>– Subjective<br><strong>• Image Gray-Level</strong><br>– The relative intensity at each unit area<br>– Between the lowest intensity (Black value) and the highest<br>intensity (White value)<br>– Device independent</p>
<h3 id="Weber-Law"><a href="#Weber-Law" class="headerlink" title="Weber Law"></a>Weber Law</h3><p>$Brightness ∝ log(f)$</p>
<h2 id="Digitization"><a href="#Digitization" class="headerlink" title="Digitization"></a>Digitization</h2><p><strong>Spatial sampling</strong>: Spatial domain</p>
<p><strong>Quantization</strong>: Gray level</p>
<p>The density of the sampling denotes the separation capability of the resulting image</p>
<p><strong>Image resolution</strong> defines the finest details that are still visible by the image</p>
<h3 id="Nyquist-Frequency"><a href="#Nyquist-Frequency" class="headerlink" title="Nyquist Frequency"></a>Nyquist Frequency</h3><p>Nyquist Rule: To observe details at frequency f (wavelength d) one must sample at frequency &gt; 2f (sampling intervals &lt; d/2)</p>
<p>The Frequency 2f is the Nyquist Frequency</p>
<h3 id="Non-uniform-Quantization"><a href="#Non-uniform-Quantization" class="headerlink" title="Non-uniform Quantization"></a>Non-uniform Quantization</h3><p> Quantize according to visual sensitivity (Weber’s Law)</p>
<h3 id="Optimal-Quantization-Lloyd-Max"><a href="#Optimal-Quantization-Lloyd-Max" class="headerlink" title="Optimal Quantization (Lloyd -Max)"></a>Optimal Quantization (Lloyd -Max)</h3><p>$Llogyds: $</p>
<blockquote>
<p>a. 首先随机选择 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 个站点<br>b. 对其他点进行划分，形成 <img src="https://www.zhihu.com/equation?tex=Voronoi" alt="[公式]"> 单元<br>c. 计算每个单元的质心，更新相应的站点<br>d. 迭代b、c这两个步骤，直至收敛</p>
</blockquote>
<h1 id="Image-Histogram"><a href="#Image-Histogram" class="headerlink" title="Image Histogram"></a>Image Histogram</h1><h2 id="Image-Characteristics"><a href="#Image-Characteristics" class="headerlink" title="Image Characteristics"></a>Image Characteristics</h2><h3 id="Image-Contrast"><a href="#Image-Contrast" class="headerlink" title="Image Contrast"></a>Image Contrast</h3><h5 id="Global-Contrast"><a href="#Global-Contrast" class="headerlink" title="Global Contrast"></a>Global Contrast</h5><p>$max{ I ( x, y)} − min{ I ( x, y)}$</p>
<p>$var{ I ( x, y)} = mean{(I ( x, y) - I_{av})^2}$</p>
<h5 id="Local-Image-Contrast"><a href="#Local-Image-Contrast" class="headerlink" title="Local Image Contrast"></a>Local Image Contrast</h5><p>$$<br>C = \mid \frac {I_p - I_n} {I_n} \mid<br>$$</p>
<p>$I_{NEW}(x,y)= α·I(x,y)+ β$</p>
<h3 id="Image-Statistics"><a href="#Image-Statistics" class="headerlink" title="Image Statistics"></a>Image Statistics</h3><p>$N = \sum_kH(k)$</p>
<p>$P(k) = H(k)/N$</p>
<p>$C(k) = \sum^k H(i)$<br>$$<br>E(I) = \frac 1 N \sum_k kH(k) = \sum_kkP(k)<br>$$</p>
<h3 id="Image-Entropy"><a href="#Image-Entropy" class="headerlink" title="Image Entropy"></a>Image Entropy</h3><p>$$<br>Entropy(I)=-\sum_kP(k)logP(k)<br>$$</p>
<h2 id="Histogram-Usage"><a href="#Histogram-Usage" class="headerlink" title="Histogram Usage"></a>Histogram Usage</h2><h3 id="KL-Distance"><a href="#KL-Distance" class="headerlink" title="KL Distance"></a>KL Distance</h3><p>$$<br>D_{KL}(A||B) = \sum_kP_A(k)log(\frac{P_A(k)}{P_B(k)})<br>$$</p>
<p>==Measures the amount of added information needed to encode image A based on the histogram of image B.==</p>
<p>Suffers from the same drawback of the Minkowski distance.</p>
<h3 id="The-Earth-Mover-Distance-EMD"><a href="#The-Earth-Mover-Distance-EMD" class="headerlink" title="The Earth Mover Distance (EMD)"></a>The Earth Mover Distance (EMD)</h3><p>$$<br>D_{EMD}(A,B) = min_F(\sum_i \sum_jf_{ij}* d_{ij}) \<br>s.t. \ f_{ij} \ge 0;P_B(k)=\sum_if_{ik});P_A(k)=\sum_if_{ki});<br>$$</p>
<p>没理解错的话就是最小费用最大流的二分图版本</p>
<h1 id="Point-Operations"><a href="#Point-Operations" class="headerlink" title="Point Operations"></a>Point Operations</h1><p>$$<br>g(x,y) = \alpha f(x,y) + \beta<br>$$</p>
<p>$$<br>M ( v ) = αv + β\<br>\alpha = \frac{q’ - p’}{q - p};\beta = p’ - \alpha p<br>$$</p>
<h2 id="Histogram-Equalization"><a href="#Histogram-Equalization" class="headerlink" title="Histogram Equalization"></a>Histogram Equalization</h2><p>Our goal: finding a gray-level transformation $M(v)$<br>such that:<br>– The histogram $H_b$ is as flat as possible.<br>– The order of gray-levels is maintained.<br>– The histogram bars are not fragmented. </p>
<p>更平，更宽，更连续</p>
<p>双指针走一下</p>
<p><a href="https://imgtu.com/i/OFznYQ"><img src="https://s1.ax1x.com/2022/05/03/OFznYQ.png" alt="OFznYQ.png"></a></p>
<h2 id="Histogram-matching"><a href="#Histogram-matching" class="headerlink" title="Histogram matching"></a>Histogram matching</h2><p>• Transforms an image A so that its histogram will match that of another image B.</p>
<p>• Usage: before comparing two images of the same scene (change detection) acquired under different lighting conditions or different camera parameters.</p>
<h1 id="Geometric-Transformation"><a href="#Geometric-Transformation" class="headerlink" title="Geometric Transformation"></a>Geometric Transformation</h1><p><a href="https://blog.csdn.net/liuweiyuxiang/article/details/86510191">一些集合变化</a></p>
<h2 id="Forward-Mapping"><a href="#Forward-Mapping" class="headerlink" title="Forward Mapping"></a>Forward Mapping</h2><p>Problems with forward mapping due to sampling:</p>
<p>– Holes (some target pixels are not populated) </p>
<p>– Overlaps (some target pixels assigned few colors)</p>
<h2 id="Inverse-Mapping"><a href="#Inverse-Mapping" class="headerlink" title="Inverse Mapping"></a>Inverse Mapping</h2><p>• Each target pixel assigned a single color.<br>• Color Interpolation is required.</p>
<h2 id="Interpolation"><a href="#Interpolation" class="headerlink" title="Interpolation"></a>Interpolation</h2><p>Interpolation: generates a new pixel by analyzing the surrounding pixels.</p>
<h3 id="Bilinear-Interpolation"><a href="#Bilinear-Interpolation" class="headerlink" title="Bilinear Interpolation"></a>Bilinear Interpolation</h3><p><a href="https://imgtu.com/i/OkdeMD"><img src="https://s1.ax1x.com/2022/05/03/OkdeMD.png" alt="OkdeMD.png"></a></p>
<h1 id="Spatial-Filtering"><a href="#Spatial-Filtering" class="headerlink" title="Spatial Filtering"></a>Spatial Filtering</h1><h2 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h2><p>$$<br>I’(u,v) = \sum_{(i,j)\in R_H} I(u-i,v-j)\cdot H(i,j) \<br>I’ = I * H<br>$$</p>
<h3 id="Linear-Operators"><a href="#Linear-Operators" class="headerlink" title="Linear Operators"></a>Linear Operators</h3><p>$$<br>F(cI) = cF(I) \<br>F(I_1 + I_2) = F(I_1) + F(I_2)<br>$$</p>
<h3 id="Properties-of-Convolution"><a href="#Properties-of-Convolution" class="headerlink" title="Properties of Convolution"></a>Properties of Convolution</h3><p>$$<br>I<em>H = H</em>I<br>$$</p>
<p>$$<br>(I ∗ H1) ∗ H2 = I ∗ (H1 ∗ H2)<br>$$</p>
<p>$$<br>(a · I) ∗ H = a · (I ∗ H) \<br>(I1 + I2) ∗ H = (I1 ∗ H) + (I2 ∗ H)<br>$$</p>
<p>$$<br>S(I ∗ H) = S(I) ∗ H<br>$$</p>
<p>The only <strong>shift-invariant</strong>, <strong>linear operators</strong> on images are convolutions </p>
<p><strong>Gaussian</strong></p>
<p>1D<br>$$<br>g_{\sigma}(x) = \frac 1 {\sqrt{2 \pi} \sigma}exp(-\frac{x^2}{2\sigma ^ 2})<br>$$<br>2D<br>$$<br>G_{\sigma}(x,y) = \frac 1 {2 \pi \sigma ^ 2}exp(-\frac{x^2 + y^2}{2\sigma ^ 2})<br>$$</p>
<p>$$<br>G(x,y) = g(x) \cdot g(y)<br>$$</p>
<h1 id="Edge-Detection"><a href="#Edge-Detection" class="headerlink" title="Edge Detection"></a>Edge Detection</h1><p>$$<br>\nabla f(x,y) = \begin{bmatrix}<br>\frac {\partial f} {\partial x} \<br>\frac {\partial f} {\partial y}<br>\end{bmatrix}<br>$$</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>经典题目</title>
    <url>/2022/03/04/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="1504-统计全-1-子矩形"><a href="#1504-统计全-1-子矩形" class="headerlink" title="1504. 统计全 1 子矩形"></a><a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones/">1504. 统计全 1 子矩形</a></h3><span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.<span class="built_in">size</span>(),m = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">row</span>(n,vector&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                    row[i][j] = mat[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(mat[i][j])</span><br><span class="line">                    row[i][j] = row[i][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    row[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            stack&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; stk;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>().first&gt;row[i][j])&#123;</span><br><span class="line">                    sum -= (stk.<span class="built_in">top</span>().first - row[i][j]) * stk.<span class="built_in">top</span>().second;</span><br><span class="line">                    h += stk.<span class="built_in">top</span>().second;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                sum += row[i][j];</span><br><span class="line">                ans += sum;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;row[i][j],h&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>经典题目</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>串串</title>
    <url>/2022/04/04/%E4%B8%B2%E4%B8%B2/</url>
    <content><![CDATA[<p>学习一些串串技术</p>
<span id="more"></span>

<h4 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> SuffixArry &#123;</span><br><span class="line">    <span class="keyword">int</span> tax[maxn], Rank[maxn], str[maxn], SA[maxn], tmp[maxn], h[maxn], n, m;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tax, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (m + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) tax[Rank[i]]++;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">2</span>, m) tax[i] += tax[i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dec</span>(i, n, <span class="number">1</span>) SA[tax[Rank[tmp[i]]]--] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f[x] == f[y] &amp;&amp; (x + w &gt; n ? <span class="number">-1</span> : f[x + w]) == (y + w &gt; n ? <span class="number">-1</span> : f[y + w]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) Rank[i] = str[i], tmp[i] = i;</span><br><span class="line">        m = <span class="number">1005</span>;</span><br><span class="line">        <span class="built_in">radix_sort</span>(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>, w = <span class="number">1</span>; p &lt; n; m = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, n - w + <span class="number">1</span>, n) tmp[++p] = i;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) SA[i] &gt; w ? tmp[++p] = SA[i] - w : <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">radix_sort</span>(m);</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">1</span>, n) tmp[i] = Rank[i];</span><br><span class="line">            Rank[SA[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">2</span>, n) Rank[SA[i]] = <span class="built_in">cmp</span>(tmp, SA[i], SA[i - <span class="number">1</span>], w) ? p : ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(string ch)</span> </span>&#123;</span><br><span class="line">        n = ch.<span class="built_in">size</span>();</span><br><span class="line">        ch = <span class="string">&#x27; &#x27;</span> + ch;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) str[i] = (<span class="keyword">int</span>)ch[i];</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Rank[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (k) --k;</span><br><span class="line">            <span class="keyword">while</span> (str[i + k] == str[SA[Rank[i] - <span class="number">1</span>] + k]) ++k;</span><br><span class="line">            h[Rank[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="寻找最小的循环移动位置"><a href="#寻找最小的循环移动位置" class="headerlink" title="寻找最小的循环移动位置"></a>寻找最小的循环移动位置</h4><p><a href="https://www.luogu.com.cn/problem/P4051">「JSOI2007」字符加密</a></p>
<h4 id="从字符串首尾取字符最小化字典序"><a href="#从字符串首尾取字符最小化字典序" class="headerlink" title="从字符串首尾取字符最小化字典序"></a>从字符串首尾取字符最小化字典序</h4><p><a href="https://www.luogu.com.cn/problem/P2870">「USACO07DEC」Best Cow Line</a></p>
<h4 id="出现至少-k-次的子串的最大长度"><a href="#出现至少-k-次的子串的最大长度" class="headerlink" title="出现至少 k 次的子串的最大长度"></a>出现至少 k 次的子串的最大长度</h4><p><a href="https://www.luogu.com.cn/problem/P2852">「USACO06DEC」Milk Patterns</a></p>
<h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz1 = word1.<span class="built_in">size</span>(), sz2  = word2.<span class="built_in">size</span>();</span><br><span class="line">        word1 = <span class="string">&#x27; &#x27;</span> + word1;</span><br><span class="line">        word2 = <span class="string">&#x27; &#x27;</span> + word2;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(sz1+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(sz2+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=sz1;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=sz2;i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=sz1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=sz2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i] == word2[j]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(&#123;dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;)+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sz1][sz2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(),len = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        map&lt;string,<span class="keyword">int</span>&gt; mp,o;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : words) mp[x],o[x]++;</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>,sz = words.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            mp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;=n-len+<span class="number">1</span>;j+=len)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                string tmp = s.<span class="built_in">substr</span>(j,len);</span><br><span class="line">                mp[tmp]++;</span><br><span class="line">                <span class="keyword">if</span>(cnt == sz)&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                    <span class="keyword">if</span>(mp == o) ans.<span class="built_in">push_back</span>(j-cnt*len<span class="number">-1</span>);</span><br><span class="line">                    string pre = s.<span class="built_in">substr</span>(j-cnt*len,len);</span><br><span class="line">                    mp[pre]--;</span><br><span class="line">                    <span class="keyword">if</span>(mp[pre] == <span class="number">0</span>) mp.<span class="built_in">erase</span>(pre);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1578H-Higher-Order-Functions"><a href="#1578H-Higher-Order-Functions" class="headerlink" title="1578H - Higher Order Functions"></a><a href="https://codeforces.com/problemset/problem/1578/H">1578H - Higher Order Functions</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">ll n, i;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ll cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            i++,cur = <span class="built_in">dfs</span>();</span><br><span class="line">        <span class="keyword">if</span> (i == n || s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(s[i++] == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="built_in">assert</span>(s[i++] == <span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cur + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    n = s.<span class="built_in">size</span>();  </span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="F2-Promising-String-hard-version"><a href="#F2-Promising-String-hard-version" class="headerlink" title=" F2 - Promising String (hard version)"></a><a href="https://codeforces.com/contest/1660/problem/F2"> F2 - Promising String (hard version)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        ll all = n, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">f</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">cnt</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        cnt[all]++;</span><br><span class="line">        f[all%<span class="number">3</span>]++;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                f[all % <span class="number">3</span>] -= cnt[all];</span><br><span class="line">                all++;</span><br><span class="line">                ans += f[all % <span class="number">3</span>];</span><br><span class="line">                cnt[all]++;</span><br><span class="line">                f[all % <span class="number">3</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                all--;</span><br><span class="line">                f[all % <span class="number">3</span>] += cnt[all];</span><br><span class="line">                ans += f[all % <span class="number">3</span>];</span><br><span class="line">                cnt[all]++;</span><br><span class="line">                f[all % <span class="number">3</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Binary-Literature"><a href="#Binary-Literature" class="headerlink" title="Binary Literature"></a><a href="https://codeforces.com/problemset/problem/1508/A">Binary Literature</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (ll i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i, a, b) for (ll i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll inf = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll n;</span><br><span class="line">vector&lt;string&gt; v0, v1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mix</span><span class="params">(string a,string b,<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    ll i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    string ans;</span><br><span class="line">    vector&lt;ll&gt; p0 = &#123; <span class="number">-1</span> &#125;, p1 = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == c) p0.<span class="built_in">push_back</span>(i); </span><br><span class="line">        <span class="keyword">if</span> (b[i] == c) p1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll j = p0[i] + <span class="number">1</span>; j &lt; p0[i + <span class="number">1</span>]; j++) ans += a[j];</span><br><span class="line">        <span class="keyword">for</span> (ll j = p1[i] + <span class="number">1</span>; j &lt; p1[i + <span class="number">1</span>]; j++) ans += b[j];</span><br><span class="line">        ans += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = p0[n] + <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) ans += a[i];</span><br><span class="line">    <span class="keyword">for</span> (ll i = p1[n] + <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) ans += b[i];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        string s;</span><br><span class="line">        v0.<span class="built_in">clear</span>(), v1.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            ll c0 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    c0++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c0 &gt;= n) v0.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">else</span> v1.<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v0.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">mix</span>(v0[<span class="number">1</span>], v0[<span class="number">0</span>], <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">mix</span>(v1[<span class="number">0</span>], v1[<span class="number">1</span>], <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">    p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[i<span class="number">-1</span>][<span class="number">0</span>]) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || dp[i][j - <span class="number">1</span>] || dp[i<span class="number">-1</span>][j]))</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p[i] == <span class="string">&#x27;?&#x27;</span> || p[i] == s[j]) &amp;&amp; (dp[i - <span class="number">1</span>][j - <span class="number">1</span>]))</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。</p>
<span id="more"></span>

<h1 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h1><p><strong>可复用性，灵活性，可扩展性，可移植性</strong></p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义算法族：让它们之间可以互相替换，让算法的变化独立于算法的客户</p>
<p>行为是通过和适当的行为“组合而来“</p>
<p>（设计原则在选择题里面）</p>
<p>设计原则：</p>
<p>把会变化的部分取出来并“封装”起来，好让其他部分不会受到影响。</p>
<p>结果: 代码变化引起的不经意后果变少，系统变得更有弹性。</p>
<p>多组合少继承</p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>动态的将责任附加到对象上</p>
<p>装饰者和被装饰者有相同的超类型</p>
<p>开闭原则：</p>
<p>对扩展开放，对修改关闭</p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>定义一个创建对象的接口，但由子类决定要实例化的类是哪一个，把实例化推迟到子类</p>
<p>设计原则：</p>
<p>依赖抽象，不依赖具体</p>
<p>不能让高层组件依赖低层组件，两者都依赖”抽象“。要遵循依赖倒置原则。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类</p>
<h1 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h1><p>单件模式保证一个类只有唯一一个实例，并且为其提供一个全局的访问点。</p>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p><strong>将”请求“封装成对象</strong>，以便使用不同的请求、队列、日志来参数化其他对象。命令模式也支持可撤销的操作</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的接口，转化成客户期望的另一个接口，适配器让原本接口不兼容的类。</p>
<p>把客户从实现的接口解耦</p>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>提供一个统一接口</p>
<p>适配器模式在于转化，外观模式在于简化</p>
<p>最小知识原则：不要让太多的类耦合在一起</p>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>好莱坞原则：</p>
<p>允许底层组件挂钩到系统，高层组件决定什么时候调用</p>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>提供一种方法顺序访问一个聚合对象中的各个元素，但是不暴露其内部表示</p>
<p>单一职责原则：</p>
<p>一个类应该只有一个引起变化的原因</p>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>（整体和部分关系的场景）</p>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1>]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><span id="more"></span>

<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>计算机系统自下而上分为：硬件，操作系统，应用程序，用户</p>
<p>操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介</p>
<p>操作系统：是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>并发、共享、虚拟、异步</p>
<h3 id="目标和功能"><a href="#目标和功能" class="headerlink" title="目标和功能"></a>目标和功能</h3><p>为给多道程序提供良好的环境，应具有以下功能：处理机管理，存储器管理，设备管理，文件管理。</p>
<p>用户与计算机硬件之间的接口：</p>
<p>命令接口：用户利用这些操作命令来组织和控制作业的执行</p>
<p>联机命令接口：交互式命令接口；脱机命令接口：批处理命令接口</p>
<p>程序接口：由一组系统调用组成。用户通过在程序中使用这些系统调用来请求操作系统来为其服务</p>
<h2 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h2><p>批处理（多道），分时，实时，网络，分布式</p>
<h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>CPU执行两种不同性质的程序：一种是操作系统内核程序，另一种是用户自编程序（简称”应用程序“）。前者是后者的管理者。</p>
<p>内核包括四个方面的内容</p>
<ol>
<li><p><strong>时钟管理</strong></p>
<p>时钟的第一功能是计时，其次是通过时钟管理实现进程的切换。</p>
</li>
<li><p><strong>中断机制</strong></p>
<p>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。</p>
</li>
<li><p><strong>原语</strong></p>
<p>具有这些特点的程序称为Atomic Operation：</p>
<p>1）处于操作系统的最底层</p>
<p>2）这些程序具有原子性</p>
<p>3）运行时间短，调用频繁</p>
</li>
<li><p><strong>系统控制的数据结构及处理</strong></p>
<p>系统中登记状态信息的数据结构很多，如作业控制块、进程控制块，设备控制块。。。为了实现有效管理，系统需要一些基本操作：</p>
<p>1）进程管理</p>
<p>2）存储器管理</p>
<p>3）设备管理</p>
</li>
</ol>
<p>核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p>
<h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>中断（外中断）：指来自CPU执行指令以外的事件发生</p>
<p>异常（内中断）：源自CPU执行指令内部的事件</p>
<p>中断处理过程：</p>
<p>关中断 保存断点 中断服务程序寻址  保存现场和屏蔽字 开中断 执行中断服务程序 关中断 恢复现场和屏蔽字 开中断 中断返回</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>指用户在程序中调用操作系统所提供的一些子功能</p>
<p><strong>中断是操作系统必须具有的功能</strong>，计算机的各种错误需要中断处理，核心态与用户态的切换也需要中断处理</p>
<p><strong>中断系统、地址映射、重置时钟</strong>都需有硬件支持</p>
<p>进入中断处理的程序在核心态执行，是操作系统程序</p>
<p>计算机通过<strong>硬件中断机制</strong>完成由用户态到核心态的转化</p>
<p>区分发生和执行：<strong>进程切换</strong>是属于系统调用执行过程中的事件</p>
<p><strong>置时钟指令</strong>只可以在核心态下执行；读时钟，取数，寄存器清零不一定</p>
<p>核心态下，CPU可以执行指令系统中的任何指令。访管是用户程序“自愿进管”的手端</p>
<p>中断的子程序只需要保存程序断点</p>
<p>外部中断处理过程，<strong>PC值由中断隐指令自动保存</strong>，而通用寄存器内容由操作系统保存</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><p>进程是程序的一次执行过程</p>
<p>进程的特征：动态性，并发性，独立性，异步性，结构性</p>
<h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><p>进程控制用的程序称为原语，执行期间不可以中断</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>允许一个进程创建另一个进程，子进程可以拥有父进程所有资源</p>
<p>过程：为新进程分配标识号，申请PCB，为进程分配资源，初始化PCB，若进程就绪队列可以接纳新进程，则进入就绪队列</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>分 正常结束，异常结束，外界干预</p>
<p>过程：根据终止进程的标识符，检索PCB，，读取状态，终止进程及其子孙，归还资源给操作系统或者给父进程，将PCB从所在队列中删除</p>
<h4 id="阻塞和唤醒"><a href="#阻塞和唤醒" class="headerlink" title="阻塞和唤醒"></a>阻塞和唤醒</h4><p>Bolck是由被阻塞进程自我调用实现的，wakeup是由一个与被唤醒进程合作，或其他相关的进程调用实现的 </p>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>进程描述信息，进程控制和管理信息，资源分配清单，处理机相关信息</p>
<h4 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h4><p>（一个程序段可以被多个进程共享）</p>
<h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>PV是低级通信方式，</p>
<p>高级通信方式：</p>
<p>共享存储</p>
<p>消息传递</p>
<ol>
<li>直接通信方式，直接把消息发送给接受消息的进程，并将它挂在进程的消息缓冲队列。</li>
<li>间接通信（信箱），发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息</li>
<li>管道通信，向管道提供输入的发送进程，以字符流形式将大量数据送入管道，接收管道输出的接收进程从管道中接收数据。为了协调，管道机制必须提供：互斥，同步，确认对方存在</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>系统发生死锁时有可能所有进程都处于阻塞态</p>
<p>一个线程阻塞，进程也阻塞</p>
<p>系统动态DLL库中的系统线程，被不同的进程调用，它们是相同的线程</p>
<p>线程切换，可能引起进程切换</p>
<p>全局变量是相对于同一进程而言的</p>
<p>进程等待某资源会进入阻塞态</p>
<p>临界资源一次只可以一个进程用，父子进程是不同的两个进程</p>
<p>父子进程不共享虚拟地址空间</p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度概念"><a href="#调度概念" class="headerlink" title="调度概念"></a>调度概念</h3><h4 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h4><ol>
<li><p>作业调度 高</p>
<p>从外存上，处于后备状态的作业中挑选一个作业，给它们分配内存</p>
</li>
<li><p>内存调度 中</p>
<p>将暂时不能运行的内存调至外存</p>
</li>
<li><p>进程调度 低</p>
<p>从就绪队列中选取一个进程，将处理机分配给它</p>
</li>
</ol>
<h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><p>不可以调度的情况：中断处理，内核程序临界区、其他需要完全屏蔽中断的原子操作。</p>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><p>抢占和非抢占：抢占就是立即停止正在执行的进程，让它来</p>
<h3 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h3><p>CPU利用率</p>
<p>吞吐量：单位时间CPU完成作业的数量</p>
<p>周转时间：从作业提交到作业完成经历的时间</p>
<p>等待时间：进程处于等待处理机状态的时间之和</p>
<p>响应时间：提交请求到系统首次产生响应的时间</p>
<h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3><p>FCFS，SJF</p>
<p>优先级调度：抢占/非抢占，静态/动态</p>
<p>高响应比优先调度：响应比：$\frac {等待时间+要求服务时间}{要求服务时间}$</p>
<p>时间片轮转</p>
<p>多级反馈队列：第$i+1$级的时间片是第$i$级的2倍，这级执行不完就给下一级，到最后一级还搞不完还是放到最后一级的队尾</p>
<p>当进程处于临界区，只要不破坏临界资源的使用规则，就不影响处理机的调度</p>
<p>分时系统，响应时间与时间片和用户数量成正比</p>
<p>中断向量本身是用于存放中断服务例行程序的入口地址</p>
<p>中断由硬件完成主要目的是为了可靠</p>
<p>FCFS有利于长作业（CPU繁忙）</p>
<p>时间片轮转调度算法是绝对可抢占的</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>一次仅允许一个进程使用的资源是临界资源</p>
<p>临界资源访问过程的4个部分：进入区、临界区、退出区、剩余区</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>直接制约关系，为了完成某个任务，建立多个进程，这些进程需要在某些位置上协调它们的工作次序</p>
<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>间接制约关系，当一个进程进入临界区使用临界资源时，另一个进程必须等待</p>
<p>要遵循的准则：</p>
<p>空闲让进，忙则等待（已有进程进入临界区就必须等），有限等待（不要一直等），让权等待（如果本来就不可以进，就立即释放处理机）</p>
<p><strong>软件方法：</strong></p>
<ol>
<li>单标志</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(turn !&#x3D; 0); 	|		while(turn !&#x3D; 0);</span><br><span class="line">critical;			|		critical;</span><br><span class="line">turn &#x3D; 1;			|		turn &#x3D; 1;</span><br><span class="line">remainder;			|		remainder;</span><br></pre></td></tr></table></figure>

<p>只有两个，而且还必须轮着来，如果一个润了，另一个也搞不了</p>
<ol start="2">
<li>双标志法先检查</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(flag[j]);		|		while(flag[i]);</span><br><span class="line">flag[i] &#x3D; 1;		|		flag[j] &#x3D; 1;</span><br><span class="line">critical;			|		critical;</span><br><span class="line">flag[i] &#x3D; 0;		|		flag[j] &#x3D; 0;</span><br><span class="line">remainder;			|		remainder;</span><br></pre></td></tr></table></figure>

<p>有可能会同时进入临界区</p>
<ol start="3">
<li>双标志法后检查</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag[i] &#x3D; 1;		|		flag[j] &#x3D; 1;</span><br><span class="line">while(flag[j]);		|		while(flag[i]);</span><br><span class="line">critical;			|		critical;</span><br><span class="line">flag[i] &#x3D; 0;		|		flag[i] &#x3D; 0;</span><br><span class="line">remainder;			|		remainder;</span><br></pre></td></tr></table></figure>

<p>两个都想进入临界区可能导致都进不了</p>
<ol start="4">
<li>Peterson’s Algorithm</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">falg[i] &#x3D; 1;turn &#x3D; j;			|		falg[j] &#x3D; 1;turn &#x3D; i;</span><br><span class="line">while(flag[j] &amp;&amp; turn &#x3D;&#x3D; j);	|		while(flag[j] &amp;&amp; turn &#x3D;&#x3D; i);</span><br><span class="line">critical;						|		critical;</span><br><span class="line">flag[i]&#x3D;0;						|		flag[j]&#x3D;0;	</span><br><span class="line">remainder;						|		remainder;	</span><br></pre></td></tr></table></figure>

<p>flag实现互斥，turn实现饥饿现象</p>
<p>只实现了有限等待，没有让权等待</p>
<p><strong>硬件方法</strong></p>
<p>通过硬件支持实现临界问题的方法称为低级方法、或称为元方法</p>
<p>中断屏蔽：</p>
<p>一个进程正在使用处理机执行它的临界区代码防止其他进程进入临界区进行访问最简单的办法就是关中断（屏蔽中断）。</p>
<p>硬件指令方法：</p>
<p>TestAndSet：</p>
<p>原子操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool testAndSet(bool * lock)&#123;</span><br><span class="line">	bool old;</span><br><span class="line">	old &#x3D; *lock;</span><br><span class="line">	*lock &#x3D; 1;</span><br><span class="line">	return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为每个临界资源分配要给lock</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while testAndSet(&amp;lock)&#123;</span><br><span class="line">	critical;</span><br><span class="line">	lock &#x3D; 0;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swap:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key &#x3D; 1;</span><br><span class="line">while(key !&#x3D; 0)&#123;</span><br><span class="line">	Swap(&amp;lock,&amp;key);</span><br><span class="line">	creitical;</span><br><span class="line">	lock &#x3D; 0;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>硬件方法不可以实现让权等待（<del>进程：我tm怎么知道可不可以进</del>）</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>整型信号量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">	while(S&lt;&#x3D;0);</span><br><span class="line">	S &#x3D; S - 1;</span><br><span class="line">&#125;</span><br><span class="line">signal(S)&#123;</span><br><span class="line">	S &#x3D; S + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait操作，只要S&lt;=0，就会不断测试。不遵循让权等待</p>
<p><strong>记录型信号量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	int value;&#x2F;&#x2F;资源数目</span><br><span class="line">	struct process *L;&#x2F;&#x2F;所有等待这个资源的进程链表</span><br><span class="line">&#125;semaphore;</span><br><span class="line">void wait(semaphore S)&#123;</span><br><span class="line">	S.value--;</span><br><span class="line">	if(S.value&lt;0)&#123;&#x2F;&#x2F; 没有while就没瞎等了</span><br><span class="line">		add this process to S.L;</span><br><span class="line">		bolck S.L;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void signal(semaphore S)&#123;</span><br><span class="line">	S.value++;</span><br><span class="line">	if(S.value&lt;&#x3D;0)&#123;</span><br><span class="line">		remove a process P from S.L;</span><br><span class="line">		wakeup(P);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用信号量实现同步</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore S &#x3D; 0;</span><br><span class="line">P1()&#123;</span><br><span class="line">	...</span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用信号量实现进程互斥</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore S &#x3D; 1;</span><br><span class="line">P1()&#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	临界区</span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	...</span><br><span class="line">	P(S);</span><br><span class="line">	临界区</span><br><span class="line">	V(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>帮助实现同步的工具</p>
<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><p>生产者-消费者，读者-写者，哲学家进餐</p>
<p>临界区说的是代码，不是程序</p>
<p>管程同时解决同步和互斥，signal和V不一样，signal是针对条件变量的</p>
<p>管程执行a.wait()，直接去阻塞队列</p>
<p>所有的互斥信号量都是1，想都不要去想</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>多个进程因竞争资源而造成一种僵局</p>
<p>原因：</p>
<p>系统资源竞争，进程推进顺序非法</p>
<p>死锁产生必要条件：</p>
<p>互斥条件（资源在一段时间只为一个进程服务）</p>
<p>不剥夺条件：不可以被强行抢走</p>
<p>请求并保持：自己有至少一个资源，还想要其他的要不到</p>
<p>循环等待：存在循环等待链</p>
<h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><p>预防、避免、检测及解除。</p>
<p>预防是提前限制（要求高），避免是动态分配过程中（要求中），检测及解除（要求低）</p>
<h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ol>
<li><p>破坏互斥</p>
<p>允许资源都可以共享</p>
</li>
<li><p>破坏不剥夺</p>
<p>请求新的不成，必须把旧的丢掉</p>
</li>
<li><p>破坏请求并保持</p>
<p>资源不满足条件就不投入运行，一旦运行就一直归它所有</p>
</li>
<li><p>破坏循环</p>
<p>编号，必须按顺序申请</p>
</li>
</ol>
<h4 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h4><ol>
<li><p>系统安全状态</p>
<p>安全状态：系统按照某种进程推进顺序为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，</p>
</li>
<li><p><a href="https://www.cnblogs.com/wkfvawl/p/11929508.html">银行家算法</a></p>
</li>
</ol>
<h4 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h4><p>top一哈</p>
<p>死锁解除：</p>
<p>资源剥夺，挂起某些死锁进程</p>
<p>撤销进程，直接把进程干掉</p>
<p>进程回退法，回退到不死锁的状态</p>
<p>注意银行家算法并不是使进程的推进顺序合理</p>
<p>进程死锁的原因是推进顺序不能当和资源分配不当，<del>给了又没全给，还不让收回来</del>，总之就是系统的锅（<del>不是钱少的锅</del>）</p>
<p>不要去考虑进程永远的执行。。。</p>
<p>办不到不互斥</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><h3 id="原理和要求"><a href="#原理和要求" class="headerlink" title="原理和要求"></a>原理和要求</h3><p>功能：分配与回收，地址转换，内存空间扩充，存储保护</p>
<p>创建进程首先要将程序和数据装入内存，<strong>编译</strong>：将用户源代码编译成若干目标模块；<strong>链接</strong>：将形成的目标模块连接起来；<strong>装入</strong>：将程序装入模块，装入内存运行。</p>
<p><strong>链接的三种方式</strong>：</p>
<p>静态链接：在程序运行之前链接成一个完整的可执行程序</p>
<p>装入时动态链接：边装边链接</p>
<p>运行时动态链接：在程序执行的时候需要的时候再链接</p>
<p><strong>装入的三种方式</strong>：</p>
<p>绝对装入：（只适用于单道程序环境）将逻辑地址转换成实际内存地址</p>
<p>可重定位装入：一次性把需要的内存全分配了</p>
<p>动态运行时装入：装入内存后，所有的地址都是相对地址</p>
<p><strong>内存保护</strong></p>
<ol>
<li>CPU中设置一对上下限寄存器，存放用户作业在主存中的下限和上限，每当CPU要访问一个地址时，都和寄存器对比一下</li>
<li>采用<strong>重定位寄存器</strong>和<strong>界地址寄存器</strong>来实现这种保护。</li>
</ol>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>单一连续分配</p>
<p>只可以单导程序</p>
<p>固定分区分配</p>
<p>分区内部存在空间浪费（内部碎片）</p>
<p>动态分区分配</p>
<p>分配策略：首次适应，最佳适应，最坏适应，邻近适应</p>
<h3 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h3><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>固定分区，产生内部碎片，动态分区产生外部碎片。每个进程平均只产生半个块大小的内部碎片</p>
<p>进程中的块称为页，内存中的块称为页框，页和页框一一对应</p>
<p>页面大小为2的整数幂。</p>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>分页是从计算机的角度考虑设计，目的是提高内存的利用率，</p>
<p>分段：按照用户进程中的自然段划分逻辑空间</p>
<p>段表：每个进程都有一张逻辑空间与内存空间映射的段表</p>
<p>共享和保护：存取控制保护和地址越界保护</p>
<h4 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h4><p>逻辑地址分成：段号，页号，页内偏移</p>
<p>段表：段号，页表长度，页表起始地址</p>
<p>段页地址空间是二维的</p>
<p>每个进程一张段表，一个段对应一张页表</p>
<p>分段有外碎片，固定分区、段页式、分页有内碎片</p>
<p>注意逻辑地址-&gt;相对地址（起始），块号*页大小（单位K也算上）</p>
<p>分段管理有利于程序动态链接</p>
<p>页表起始地址存在寄存器里面</p>
<p>分段和分页提供给用户的物理地址空间大小是不确定的</p>
<p>注意第一个空闲区要排序</p>
<p>页面大小必须相同</p>
<p>段，主要是为了方便编程，分段共享，分段保护，动态链接，动态增长</p>
<p>对主存储器的访问是以字节为单位，不要去想数组。。。</p>
<p>分页存储管理，主存的分配以物理块为单位</p>
<p>段式：查段表，查目的</p>
<p>段页式：查段，查页，查目的</p>
<p>分页是一维地址，另外两个是二位</p>
<p>静态重定位是在程序运行之前由装配程序完成，必须要连续的空间，页式是离散的。所以页式不可以用静态重定位</p>
<p>共享段S对于进程P1,P2来说，使用位置不同，所以在不同进程中的逻辑段号可能不同</p>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>多次性：作业可以分多次装入</p>
<p>对换性：可以在运行过程中换出换入</p>
<p>虚拟性：逻辑上扩充内存容量</p>
<h3 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h3><p>请求分页系统建立在基本分页系统上，为了支持虚拟存储器功能而增加请求调页功能和页面置换功能</p>
<p>当要访问的页面不在内存中时，再通过调页功能将其调入</p>
<h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>页号 物理块号 状态位 访问字段 修改位 外存地址</p>
<p>状态位：是否调入内存</p>
<p>访问字段：记录一段时间内被访问的次数，或有多长时间没被访问</p>
<p>修改位：调入内存后是否被修改过</p>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>请求分页系统中，每当要访问的页面不在内存中，便产生一个缺页中断，请求操作系统将所缺的页调入内存。</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>在分页系统上加些功能</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换OPT"><a href="#最佳置换OPT" class="headerlink" title="最佳置换OPT"></a>最佳置换OPT</h4><p> 淘汰未来最长时间不使用</p>
<h4 id="先进先出FIFO"><a href="#先进先出FIFO" class="headerlink" title="先进先出FIFO"></a>先进先出FIFO</h4><p>belady现象：分配的物理块增多导致故障数不减反增</p>
<h4 id="最近最久未使用LRU"><a href="#最近最久未使用LRU" class="headerlink" title="最近最久未使用LRU"></a>最近最久未使用LRU</h4><p>就是OPT的向前看版本</p>
<p>堆栈算法不会出现Belady，队列会</p>
<p>LRU性能好，但是需要寄存器和栈的支持</p>
<h4 id="时钟置换CLOCK"><a href="#时钟置换CLOCK" class="headerlink" title="时钟置换CLOCK"></a>时钟置换CLOCK</h4><p>在简单CLOCK基础上加上一个修改位</p>
<p>先找0 0，然后找0 1同时把使用位置为0，如果失败了就重复之前两步</p>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><h4 id="驻留集大小"><a href="#驻留集大小" class="headerlink" title="驻留集大小"></a>驻留集大小</h4><p>固定分配局部置换：每个进程分配一定数目物理块，一直不变</p>
<p>可变分配全局置换：只要发生缺页系统就给它</p>
<p>可变分配局部置换：先是观察一段时间，如果频繁缺页就给，如果不怎么缺就收</p>
<h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><p>预调页策略</p>
<p>请求调页策略：缺了才要</p>
<h4 id="从哪调页"><a href="#从哪调页" class="headerlink" title="从哪调页"></a>从哪调页</h4><p>外存分成：文件区和对换区，对换区采用连续分配方式，文件区离散分配</p>
<p>调页时会有三种情况：</p>
<p>系统拥有足够的对换空间：全部从对换区调入所需的页面（需要将这个进程相关的文件都从文件区复制到对换区）。</p>
<p>系统缺少足够的对换空间：不会被修改的文件直接从文件区调入，需要修改的部分换出时需要换到对换区，以便再从对换区换入</p>
<p>UNIX：没有运行过的页面都从文件区调入，换出的时候换到对换区</p>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>刚换出去又换进来。</p>
<p>频发发生缺页中断的原因：进程频繁访问的页面数高于可用的物理页</p>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>某段时间内进程要访问的页面集合。</p>
<p>工作集模型原理：操作系统跟踪每个进程的工作集，为进程分配大于其工作集的物理块。落在工作集内部的页面需要调入驻留集，落在工作集外的页面可以从驻留集换出</p>
<p>LRU需要对所有的页进行排序，开销大</p>
<p>合法位表示是否在内存，决定是否发生页故障</p>
<p>虚拟存储需要请求机制</p>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="系统基础"><a href="#系统基础" class="headerlink" title="系统基础"></a>系统基础</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>文件：以计算机硬盘为载体的存储在计算机上的信息集合</p>
<p>数据项：文件系统最低级的数据组织形式：</p>
<ol>
<li>基本数据项：用于描述一个对象的某种属性的一个值。</li>
<li>组合数据项：由多个数据项组成</li>
</ol>
<p>记录：一组相关的数据项的集合</p>
<p>文件：有结构的是记记录式文件，否则是流式文件</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>名称，标识符，类型，位置，大小，保护，时间、日期、用户标识</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>创建文件：在文件系统找到空间，在目录中为新文件创建条目，该条目记录文件名称、在文件系统的位置。</p>
<p>写文件：执行一个系统调用，指明文件名称和要写入的文件内容，系统搜索目录找文件位置，维护写位置指针</p>
<p>读文件：执行一个系统调用，指明文件名称和要读入文件快的内存位置，系统维护读位置指针</p>
<p>文件重定位：将当前文件位置设为给定值，并且不会读、写文件</p>
<p>删除文件：先删目录项，然后回收占用的存储空间</p>
<p>截断文件：属性不变，长度设为0并释放空间</p>
<h4 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h4><p>使用系统调用将指明文件的属性从从外存复制到内存，打开文件表的一个项目表中，将该表目的编号返回给用户。系统维护一个包含所有打开文件的信息表。关闭的时候从文件表删除这一条目</p>
<p>整个系统表包含进程的相关信息，一个进程打开一个文件，系统打开文件表就会为这个打开的文件按增加相应的条目。当另一个进程执行open，只是在进程打开表中增加一个条目</p>
<p>每个打开文件都有如下信息：文件指针，文件打开计数，文件磁盘位置，访问权限。</p>
<h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><h4 id="流式文件"><a href="#流式文件" class="headerlink" title="流式文件"></a>流式文件</h4><p>它是有序相关信息项的集合，以字节为单位。</p>
<h4 id="记录式文件"><a href="#记录式文件" class="headerlink" title="记录式文件"></a>记录式文件</h4><ol>
<li><p>顺序文件</p>
</li>
<li><p>索引文件</p>
</li>
<li><p>索引顺序文件</p>
</li>
<li><p>直接文件/散列文件</p>
</li>
</ol>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="文件控制块和索引节点"><a href="#文件控制块和索引节点" class="headerlink" title="文件控制块和索引节点"></a>文件控制块和索引节点</h4><p>FCB包含：基本信息，存取控制信息，使用信息</p>
<p>存放在磁盘上的索引结点称为磁盘索引结点，UNIX中的每个文件都有唯一的磁盘索引结点，主要包括：</p>
<p>文件主标识符</p>
<p>文件类型</p>
<p>文件存取权限</p>
<p>文件物理地址，每个索引结点中含有13个地址项</p>
<p>文件长度</p>
<p>文件链接计数</p>
<p>文件存取时间</p>
<p>文件被打开时，磁盘索引结点复制到内存的索引结点中。在内存索引结点又增加了：</p>
<p>索引结点编号</p>
<p>状态</p>
<p>访问计数</p>
<p>逻辑设备号</p>
<p>链接指针</p>
<h4 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h4><p>目录层次需要执行的操作</p>
<p>搜索</p>
<p>创建文件</p>
<p>删除文件</p>
<p>显示目录</p>
<p>修改目录</p>
<p>有几种目录结构：</p>
<p>单级，两级，多级（树形），无环图</p>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><h4 id="基于索引结点（硬链接）"><a href="#基于索引结点（硬链接）" class="headerlink" title="基于索引结点（硬链接）"></a>基于索引结点（硬链接）</h4><p>必须将共享文件/子目录连接到多个用户的目录中，文件的物理地址、其他的文件属性放在索引结点</p>
<h4 id="利用符号链接（软链接）"><a href="#利用符号链接（软链接）" class="headerlink" title="利用符号链接（软链接）"></a>利用符号链接（软链接）</h4><p>是根据路径名去找</p>
<p>硬软都是静态，两个进程对一个文件进行操作称为动态共享</p>
<h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><ol>
<li><p>访问类型</p>
<p>读，写，执行，添加，删除，列表清单</p>
<p>保护只可以在底层提供</p>
</li>
<li><p>访问控制</p>
<p>精简访问列表：拥有者，组，其他</p>
</li>
</ol>
<p>打开文件的主要工作：把指定文件的目录复制到内存指定的区域（把文件的FCB存入内存的活跃文件表，<del>不是将文件复制到主存</del>)</p>
<p>UNIX里面输入输出设备是特殊文件</p>
<p>索引文件由逻辑文件和索引表组成，对索引文件的存取，必须先查索引表。索引项只有每条记录的长度和逻辑文件的其实位置</p>
<p>目录文件放的是子目录和数据文件的信息</p>
<p>文件目录项就是FCB，包括：</p>
<p>文件基本信息（物理位置）、存取控制信息、使用信息</p>
<p>文件信息存放在索引结点中</p>
<p>一个文件在物理存储器上有一个索引结点，会共享</p>
<p>系统级安全管理包括注册和登录</p>
<p>整个系统只有一个系统打开文件表</p>
<p>防止文件受损用备份的办法，多用户权限保护是用存取控制矩阵的办法</p>
<h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><h3 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h3><h4 id="用户调用接口"><a href="#用户调用接口" class="headerlink" title="用户调用接口"></a>用户调用接口</h4><p>新建、打开、读写、关闭、删除文件，建立、删除目录。</p>
<p>每个模块对应一条系统调用</p>
<h4 id="文件目录系统"><a href="#文件目录系统" class="headerlink" title="文件目录系统"></a>文件目录系统</h4><p>文件目录系统，任务是管理活跃文件目录表、管理读写状态表、用户进程的打开文件表、组织存储设备上的文件目录结构、调用下一级存取控制模块</p>
<h4 id="存取控制验证系统"><a href="#存取控制验证系统" class="headerlink" title="存取控制验证系统"></a>存取控制验证系统</h4><p>把用户的访问要求与FCB中指示的访问控制权限进行比较</p>
<h4 id="逻辑文件系统与文件信息缓冲区"><a href="#逻辑文件系统与文件信息缓冲区" class="headerlink" title="逻辑文件系统与文件信息缓冲区"></a>逻辑文件系统与文件信息缓冲区</h4><p>逻辑文件系统与文件信息缓冲区的主要功能：根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑内相应的块号</p>
<h4 id="物理文件系统"><a href="#物理文件系统" class="headerlink" title="物理文件系统"></a>物理文件系统</h4><p>把逻辑记录所在的相对块号转换成实际的物理地址</p>
<h4 id="辅助分配模块"><a href="#辅助分配模块" class="headerlink" title="辅助分配模块"></a>辅助分配模块</h4><p>管理辅存空间，分配辅存空闲空间和回收辅存</p>
<h4 id="设备管理程序模块"><a href="#设备管理程序模块" class="headerlink" title="设备管理程序模块"></a>设备管理程序模块</h4><p>分配设备、分配设备读写用缓冲区、磁盘调度、启动设备、处理设备中断、释放读写缓冲区、释放设备等。</p>
<h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><p>在读文件之前必须打开文件，打开文件时，操作系统利用路径名找到相应目录项，目录项提供了查找文件磁盘块所需要的信息，目录有线性和哈希两种实现</p>
<h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><h3 id="文件实现——文件分配方式"><a href="#文件实现——文件分配方式" class="headerlink" title="文件实现——文件分配方式"></a>文件实现——文件分配方式</h3><h4 id="连续分配-1"><a href="#连续分配-1" class="headerlink" title="连续分配"></a>连续分配</h4><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><h3 id="文件实现——文件存储空间管理"><a href="#文件实现——文件存储空间管理" class="headerlink" title="文件实现——文件存储空间管理"></a>文件实现——文件存储空间管理</h3><p>文件存储器空间划分与初始化</p>
<p>文件存储空间管理</p>
<p>空闲表法：连续分配</p>
<p>空闲链表法：以盘块，或者盘区（一个盘区有多个盘块）</p>
<p>位示图法：$b = n(i-1)j$,$i = (b-1)/n+1,j=(b-1)%n+1$</p>
<p>成组链接法：二维链表的样子</p>
<p>直接存取就是随机存取</p>
<p>索引节点总数与长度无关</p>
<h2 id="磁盘与管理"><a href="#磁盘与管理" class="headerlink" title="磁盘与管理"></a>磁盘与管理</h2><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>$$<br>T_a = m\times n+s+\frac 1{2r}+\frac b{rN}<br>$$</p>
<h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><h4 id="SSTF最短寻道时间"><a href="#SSTF最短寻道时间" class="headerlink" title="SSTF最短寻道时间"></a>SSTF最短寻道时间</h4><h4 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h4><p>跑到端</p>
<h4 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h4><p>不跑到端</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><p>人机交互类，存储设备，网络通信设备</p>
<h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>低速设备（百字节），中速设备（万字节），高速设备（百千到千兆）</p>
<h4 id="信息交换单位"><a href="#信息交换单位" class="headerlink" title="信息交换单位"></a>信息交换单位</h4><p>块设备</p>
<p>字符设备</p>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><h4 id="程序直接控制"><a href="#程序直接控制" class="headerlink" title="程序直接控制"></a>程序直接控制</h4><h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><h3 id="I-O子系统的层次结构"><a href="#I-O子系统的层次结构" class="headerlink" title="I/O子系统的层次结构"></a>I/O子系统的层次结构</h3><p>用户层I/O软件：实现与用户交互的接口，用户可以直接调用在用户层提供的，与I/O操作有关的库函数</p>
<p>设备独立软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护、设备分配与释放等</p>
<p>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令</p>
<p>中断处理程序：用于保存被中断进程的CPU环境</p>
<p>硬件设备：I/O设备通常包括一个机械部件和一个电子部件</p>
<p>设备控制器：</p>
<p>接受和识别CPU或通道发来的命令</p>
<p>实现数据交换</p>
<p>发现和记录设备及自身的状态信息，共CPU处理使用</p>
<p>设备地址识别</p>
<p>通道处理内存与外设</p>
<p>接口用来传输信号，I/O逻辑即设备控制器</p>
<p>设备分配不考虑及时性</p>
<p>操作系统给设备分配设备绝对号</p>
<p>通道不是软件，通道的程序在主存里面</p>
<p>通道不管启动成不成功，都要回答CPU</p>
<h2 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I/O核心子系统"></a>I/O核心子系统</h2><h3 id="I-O子系统概述"><a href="#I-O子系统概述" class="headerlink" title="I/O子系统概述"></a>I/O子系统概述</h3><p>I/O核心子系统提供的服务主要有I/O调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等</p>
<h3 id="I-O调度概念"><a href="#I-O调度概念" class="headerlink" title="I/O调度概念"></a>I/O调度概念</h3><p>当一个应用程序执行阻塞I/O系统调用时，该请求就加到相应设备的队列上，I/O调度重新安排顺序</p>
<h3 id="高速缓存与缓冲区"><a href="#高速缓存与缓冲区" class="headerlink" title="高速缓存与缓冲区"></a>高速缓存与缓冲区</h3><h4 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h4><p>操作系统中使用磁盘高速缓存技术来提高磁盘I/O速度，对高速缓存复制的访问要比原始数据访问更加高效</p>
<p>高速缓存两种形式：1. 在内存中开一个单独的空间，大小固定；2. 把未利用的的内存空间作为一个缓冲池，共请求分页系统和磁盘I/O时共享</p>
<h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>缓冲区管理的关键时进程访问缓冲区的同步</p>
<p>SPOOLing不需要外围计算机</p>
<p>提高单机利用率关键技术是多道程序技术</p>
<p>SPOOLing由预输入，井管理，缓输出组成</p>
<p>SPOOLing是一种典型的虚拟设备技术，它通过将独占设备虚拟成共享设备，所以必须要现有独占设备</p>
<p>独占设备静态分配，共享的动态分配</p>
<h1 id="试题搜集"><a href="#试题搜集" class="headerlink" title="试题搜集"></a>试题搜集</h1><p>进程执行原语时屏蔽中断</p>
<p>四个同步准则：空闲让进，忙则等待，有限等待，让权等待。</p>
<p>整形信号量没有遵循让权等待，记录型遵循。记录型多的就是把等待进程放到链表里。</p>
<p>符号链 就是 软链接</p>
<p>多道程序优点是提高资源利用率和吞吐量</p>
<p>UNIX把FCB拆成索引节点和inode</p>
<p>必要条件：互斥；请求和保持；不剥夺；环路等待。</p>
<p>处理方式：</p>
<ol>
<li><p>预防死锁：采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不同时满足死锁的四个必要条件</p>
</li>
<li><p>避免死锁：在资源的动态分配过程中，防止系统进入不安全状态。</p>
</li>
<li><p>检测死锁：允许系统进入死锁，但系统及时检测，并采取措施。</p>
</li>
<li><p>解除死锁：当检测到系统进入了死锁，采取措施解除。</p>
</li>
</ol>
<p>进程的终止过程：</p>
<ol>
<li><p>从PCB集合中检索出该进程的PCB，从中读出该进程的状态。</p>
</li>
<li><p>若处于执行状态，终止该进程的执行，并置调度标志为真，重新调度。</p>
</li>
<li><p>若有子孙进程，将所有子孙进程终止。</p>
</li>
<li><p>将进程全部资源归还其父进程或系统：释放内外存空间、关闭所有打开文件、释放当前目录、释放共享内存段和各种锁定lock。</p>
</li>
<li><p>将其PCB从所在队列（或链表）中移出</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/OM7TU0"><img src="https://s1.ax1x.com/2022/05/07/OM7TU0.png" alt="OM7TU0.png"></a></p>
<p><a href="https://imgtu.com/i/OM7bCT"><img src="https://s1.ax1x.com/2022/05/07/OM7bCT.png" alt="OM7bCT.png"></a></p>
<p>程序状态字寄存器是子程序调用不一定保存，中断一定保存</p>
<p>虚拟设备：把一个物理设备变换为多个对应的逻辑设备（用共享设备模拟独占设备）</p>
<p>现代操作系统：并发、异步、虚拟</p>
<p>在设备管理中，设备独立性软件负责将逻辑设备名，映射为物理设备名，并将映射信息记录到逻辑设备表中</p>
<p>对换区采用连续分配</p>
<ol>
<li>（1）<strong>查找快表</strong>，若命中直接形成物理地址。<br> （2）<strong>若快表不命中，查找页表</strong>，看所访问的逻辑页是否在内存，若在，则更新快表，并形成物理地址。<br> （3）若所访问的逻辑页不在主存，则产生<strong>缺页中断</strong>。<br> （4）缺页中断处理程序查找页表获取所缺的页在外存的地址。<br> （5）若此时系统有空闲的物理页框，直接装入所缺的页，并更新页表和快表。否则执行页面置换算法，换出一页，换入所缺的页，再更新页表和快表。重新执行被中断的指令。</li>
<li>（1）<strong>存储保护是指在非共享情况下，某进程不可以访问其它进程的地址空间；用户进程必须通过系统调用访问OS核心区</strong>。<br>（2）<strong>动态分区存储管理</strong>中，为了实现存储保护，在硬件上增加两个寄存器，<strong>基地址寄存器</strong>， 存放本进程最低的内存物理地址。<strong>界限寄存器</strong>，存放本进程的存储区域大小。进程执行指令产生的逻辑地址若小于基地址寄存器的内容或大于界限地址寄存器的内容，则会越界自陷。</li>
<li>（1）<strong>基于索引结点的共享方式</strong>，也叫<strong>硬链接</strong>，即诸如文件的物理地址及其它的文件属性等信息不再放在目录项中，而是<strong>放在索引结点中</strong>，在文件目录中只设置该文件名及指向相应索引结点的指针。通过多个文件名链接(link)到同一个索引结点，可建立同一个文件的多个<strong>彼此平等的别名</strong>。别名的数目记录在索引结点的链接计数中。<br>（2）由系统创建一个<strong>LINK类型的新文件</strong>，并给个文件名，其内容是到另一个目录或文件路径的链接，该方法称为符号链接。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。</li>
<li>（1）<strong>输入井和输出井</strong>：在磁盘上。<br>（2） <strong>输入缓冲区和输出缓冲区：在内存。</strong>缓和CPU和磁盘速度不匹配的矛盾。<br>（3） <strong>输入进程和输出进程</strong>：<br>输入进程用于将用户要求的输入数据传送到输入缓冲区，再送入输入井。<br>  输出进程用于把用户要输出的数据由输出缓冲区存放到输出井中。<br>（4）井管理程序：用于控制作业与磁盘井之间的信息交换。</li>
</ol>
<p>逻辑盘块到物理地址，是设备驱动做的</p>
<p>线程没有独立的地址空间，线程包含CPU现场，可独立运行</p>
<p>操作系统主要功能：处理机管理，文件管理，设备管理</p>
<p>进程控制块：进程标识信息，处理机状态信息，进程调度信息，进程控制信息</p>
<p>文件：文件体，文件属性</p>
<p>前段直接访问，后段是串行访问的存储器称为直接存取存储器。磁盘是典型的直接存取设备</p>
<p>静止就是挂起</p>
<p>SPOOLing系统的组成</p>
<p>输入井、输出井：在磁盘上</p>
<p>输入缓冲区，输出缓冲区：在内存</p>
<p>输入进程和输出进程：<strong>输入进程</strong>用于将用户要求的<strong>输入数据</strong>传送到<strong>输入缓冲区</strong>，再送入<strong>输入井</strong>。</p>
<p>井管理程序:用于控制作业与磁盘井之间的信息交换。</p>
<ol>
<li><p>作业调度 高</p>
<p>从外存上，处于后备状态的作业中挑选一个作业，给它们分配内存</p>
</li>
<li><p>内存调度 中</p>
<p>将暂时不能运行的内存调至外存</p>
</li>
<li><p>进程调度 低</p>
<p>从就绪队列中选取一个进程，将处理机分配给它</p>
</li>
</ol>
<p>4.简述操作系统为提高计算机系统资源利用率所采用的各种方法。<br>答:<br>提高处理机利用率:引入多道程序设计技术<br>提高内存利用率:采用了分空间技术，虚拟存储管理技术等<br>提高外设的利用率:采用了虚拟设备技术，缓冲区等。</p>
<ol>
<li><p>名词解释：临界区、外碎片、文件的物理结构、线程、对换<br>答：<br>临界区：在每个进程中访问临界资源的一段代码。<br>外碎片：采用动态分区分配存储管理的系统，主存不断地以不等大小的分区分配<br>给各个进程，进程执行完，系统要回收分区，经过较长时间后，系统中会保<br>留许多小的空闲分区，不够分配给任何进程，称为外碎片。<br>文件的物理结构：又称文件的存储结构，文件在外存上组织形式，与存储介质的<br>存储性能有关。<br>线程：线程是进程的实体。线程是处理机调度中最接近硬件的部分，是最低级的调度。也称为轻量进程。<br>对换：是将暂时不能执行的程序或数据送到外存中，从而获得空闲内存空间来装入具备运<br>行条件的进程或进程所需要的程序和数据。</p>
</li>
<li><p>简述实现文件共享的两种方法。<br>答：由系统创建一个 LINK 类型的新文件，并给个文件名，其内容是到另一个目<br>录或文件路径的链接，该方法称为符号链接。<br>基于索引结点的共享方式：文件的物理地址及其它属性信息不放在文件目录中，<br>而是放在索引结点中(磁盘索引结点），在目录中设置指向相应索引结点的指针。<br>通过多个文件名链接(link)到同一个索引结点，可建立同一个文件的多个彼此平<br>等的别名</p>
</li>
<li><p>OS 中对空闲盘块的管理方法有哪些？简述各种方法的技术要点。<br>答：空闲链表法：每个空闲簇中有指向下一个空闲簇的指针，所有空闲簇构成一个链表。<br>空闲表法：系统为外存上的所有空闲区建立一张表，每个空闲区对应一个表项。<br>位示图法：利用二进制的一位来表示磁盘中一个盘块的使用情况。<br>成组链接法：空闲盘块栈用来存放当前可用的一组空闲盘块号。每一组含有的盘块总数和该<br>组所有的空闲盘块号记入前一组的第一个盘块中。</p>
</li>
<li><p>名词解释：原语、逻辑文件、中级调度、内碎片、抖动<br>答：<br>原语：由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整<br>体而不可分割－－要么全都完成，要么全都不做。许多系统调用是原语。<br>但并不是所有的系统调用都是原语<br>逻辑文件：从用户角度所看到的文件组织结构，是用户可以直接处理的数据及结<br>构。<br>中级调度：当系统因为存储空间紧张，而导致系统效率降低时，中级调度程序将<br>暂时不运行的进程交换至外存挂起。一旦内存空间允许，就将外存的挂<br>起进程换入内存。<br>内碎片：当系统采用固定分区分配为进程分配内存空间时，分配给每个进程的存<br>储区是固定大小，进程所需空间可能小于分区大小，多余的存储空间就是内<br>碎片。<br>抖动： 在页式存储管理中，刚被调出的页面又立刻被调入所形成的频繁调入调<br>出现象</p>
</li>
<li><p>如何理解进程的顺序性与并发性？<br>答：<br>顺序性<br>顺序性包括两层含义：（1）内部顺序性，对于一个进程来说，它的所有指<br>令是按序执行的；（2）外部顺序性，对于多个进程来说，所有进程是依次执<br>行的。<br>例如，假如有 p1 和 p2 两个进程，其活动分别为：<br>p1 活动：a1 a2 a3 a4<br>p2 活动：b1 b2 b3 b4<br>顺序执行时，有如下两种情形：<br>情形 1：a1 a2 a3 a4 b1 b2 b3 b4<br>情形 2：b1 b2 b3 b4 a1 a2 a3 a4<br>并发性包括如下两层含义：（1）内部顺序性，对于一个进程来说，它的所<br>有指令是按序执行的；（2）外部并发性，对于多个进程来说，所有进程是交叉<br>执行的。<br>例如，对于上面 p1 和 p2 两个进程来说，并发执行有许多情形，如：<br>情形 1：a1 b1 b2 a2 a3 b3 a4 b4<br>情形 2：b1 b2 a1 a2 a3 b3 b4 a4<br>并发进程在其执行过程中，出现哪种交叉情形是不可预知的，这就是并发进程的<br>不确定性，操作系统应当保证：无论出现何种交叉情形，每个进程运行的结果都<br>应当是唯一的，正确的。</p>
</li>
<li><p>简述在具有快表的请求分页系统中，将逻辑地址变换为物理地址的完整过程。<br>答：<br>（1）查找快表，若命中直接形成物理地址。<br>（2）若快表不命中，查找页表，看所访问的逻辑页是否在内存，若在，则更新<br>快表，并形成物理地址。<br>（3）若所访问的逻辑页不在主存，则产生缺页中断。<br>（4）缺页中断处理程序查找页表获取所缺的页在外存的地址。<br>（5）若此时系统有空闲的物理页框，直接装入所缺的页，并修改页表。<br>（6）否则执行页面置换算法，换出一页，换入所缺的页，再修改页表。重新执<br>行被中断的指令。</p>
</li>
<li><p>为什么要有设备驱动程序？用户进程怎样通过设备驱动程序控制设备工作？<br>答：<br>为了实现设备独立性，系统设置了设备独立性软件层，在其之下是驱动程序，<br>它是与硬件紧密相关的软件，是 I/O 进程与设备控制器之间的通信程序，负责接<br>收上层软件的命令，屏蔽了具体设备细节。负责管理设备控制器。<br>用户进程使用设备驱动程序时，其工作处理过程为：设备驱动程序将用户进<br>程抽象的 I/O 请求转换为具体的要求，读出和检查设备状态，传送必要的参数，<br>设置设备工作方式，启动 I/O 设备。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>基因比对</title>
    <url>/2022/04/21/%E5%9F%BA%E5%9B%A0%E6%AF%94%E5%AF%B9/</url>
    <content><![CDATA[<p>一些关于基因比对的记录</p>
<span id="more"></span>

<h1 id="全局比对"><a href="#全局比对" class="headerlink" title="全局比对"></a>全局比对</h1><h2 id="求最长子串"><a href="#求最长子串" class="headerlink" title="求最长子串"></a>求最长子串</h2><p>$$<br>f_{ij} =<br>\begin{cases}<br>    f_{i-1,j-1} + 1,  &amp; \text{$s_i == t_i$} \<br>    0, &amp; \text{else}<br>\end{cases}<br>$$</p>
<h2 id="Smith-Waterman"><a href="#Smith-Waterman" class="headerlink" title="Smith-Waterman"></a><a href="https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm">Smith-Waterman</a></h2>]]></content>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2022/05/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这是一波Remake</p>
<span id="more"></span>

<p>什么是似然估计?</p>
<p>从真实事件反推理论值，发生的一系列事件对应各种理论上的概率模型，确定是某个概率模型的概率，叫做似然值。</p>
<p>在这里，极大 = 最大</p>
<p>熵：系统的混乱程度</p>
<p>信息量：提供的确定性</p>
<p>假设 $i$ 事件发生的概率是 $p_i$ ,那这件事发生的信息量就是$-log p_i$ </p>
<p>熵: $-\sum p_i log p_i$</p>
<p>相对熵（KL散度）：<br>$$<br>D_{KL}(P||Q) = p_i(f_Q(q_i) - f_P(p_i)) \  =\sum p_i(-log_2q_i) - \sum p_i(-log_2p_i)<br>$$<br>以P系统为基准，后面的一部分是P自己的熵，关注的地方就放在了第一部分</p>
<p>交叉熵：<br>$$<br>H(P,Q) = \sum_i^m p_i(-log_2q_i) \<br>= -\sum x_ilog_2y_i+(1-x_i)log_2(1-y_i)<br>$$<br>和极大似然估计法的式子一样，虽然样子一样，但是是一个巧合</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式</title>
    <url>/2022/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8F/</url>
    <content><![CDATA[<p>一些嵌入式简写</p>
<span id="more"></span>

<p>PS: Processing System</p>
<p>PL: Programmable Logic</p>
<p>PS PL 都可以单独使用，单独用的时候PS相当于通用CPU，PL相当于FPGA</p>
<p>APU: Application Processor Unit，里面有两个Cortex-A9</p>
<p>DDR: Double Data Rate</p>
<p>MIO: 多功能引脚</p>
<p>EMIO: 扩展多功能引脚</p>
<p>SLCR: System-Level Control Register</p>
<p>MMU: 存储管理单元</p>
<p>SCU：侦听控制单元</p>
<p>ACP：加速器一致性接口</p>
<p>GPIO: General Purpose Input Output</p>
<p>CPSR: Current Program Status Register</p>
<p>SPSR: Saved Program Status Register</p>
<p>SP: 堆栈寄存器</p>
<p>LR: Link Register</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree</title>
    <url>/2022/06/01/Tree/</url>
    <content><![CDATA[<p>Tree</p>
<span id="more"></span>

<p><a href="https://codeforces.com/problemset/problem/1675/F">树上两点找路</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> todo[N], path[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u);</span><br><span class="line">		<span class="keyword">if</span> (todo[v]) todo[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (path[v]) path[u] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codeforces.com/problemset/problem/1454/E">环上挂树，无环图不同路径是$\frac {(n-1)n} {2}$</a></p>
<p><a href="https://codeforces.com/problemset/problem/1436/D">从每个节点到叶子节点，自底向上dp</a></p>
]]></content>
      <categories>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>随便写点题</title>
    <url>/2022/06/05/%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9%E9%A2%98/</url>
    <content><![CDATA[<p>随便写点</p>
<span id="more"></span>

<p><a href="http://118.190.20.162/view.page?gpid=T125">校门外的树CSP</a><br>$$<br>dp[i] = \sum dp[j] * cnt(j,i)<br>$$<br>朴素筛求1e5每个数字的因子 </p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>casual</tag>
      </tags>
  </entry>
  <entry>
    <title>redu</title>
    <url>/2022/06/23/redu/</url>
    <content><![CDATA[<p>something about redu</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
</search>
